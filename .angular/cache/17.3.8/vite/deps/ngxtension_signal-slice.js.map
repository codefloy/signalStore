{
  "version": 3,
  "sources": ["../../../../../node_modules/@angular/core/fesm2022/rxjs-interop.mjs", "../../../../../node_modules/ngxtension/fesm2022/ngxtension-assert-injector.mjs", "../../../../../node_modules/ngxtension/fesm2022/ngxtension-connect.mjs", "../../../../../node_modules/ngxtension/fesm2022/ngxtension-signal-slice.mjs"],
  "sourcesContent": ["/**\n * @license Angular v17.3.12\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError, ɵgetOutputDestroyRef, Injector, effect, untracked, assertNotInReactiveContext, signal, computed } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n    if (!destroyRef) {\n        assertInInjectionContext(takeUntilDestroyed);\n        destroyRef = inject(DestroyRef);\n    }\n    const destroyed$ = new Observable(observer => {\n        const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n        return unregisterFn;\n    });\n    return (source) => {\n        return source.pipe(takeUntil(destroyed$));\n    };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n    constructor(source) {\n        this.source = source;\n        this.destroyed = false;\n        this.destroyRef = inject(DestroyRef);\n        this.destroyRef.onDestroy(() => {\n            this.destroyed = true;\n        });\n    }\n    subscribe(callbackFn) {\n        if (this.destroyed) {\n            throw new ɵRuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\n                'Unexpected subscription to destroyed `OutputRef`. ' +\n                    'The owning directive/component is destroyed.');\n        }\n        // Stop yielding more values when the directive/component is already destroyed.\n        const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n            next: value => callbackFn(value),\n        });\n        return {\n            unsubscribe: () => subscription.unsubscribe(),\n        };\n    }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @developerPreview\n */\nfunction outputFromObservable(observable, opts) {\n    ngDevMode && assertInInjectionContext(outputFromObservable);\n    return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @developerPreview\n */\nfunction outputToObservable(ref) {\n    const destroyRef = ɵgetOutputDestroyRef(ref);\n    return new Observable(observer => {\n        // Complete the observable upon directive/component destroy.\n        // Note: May be `undefined` if an `EventEmitter` is declared outside\n        // of an injection context.\n        destroyRef?.onDestroy(() => observer.complete());\n        const subscription = ref.subscribe(v => observer.next(v));\n        return () => subscription.unsubscribe();\n    });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n    !options?.injector && assertInInjectionContext(toObservable);\n    const injector = options?.injector ?? inject(Injector);\n    const subject = new ReplaySubject(1);\n    const watcher = effect(() => {\n        let value;\n        try {\n            value = source();\n        }\n        catch (err) {\n            untracked(() => subject.error(err));\n            return;\n        }\n        untracked(() => subject.next(value));\n    }, { injector, manualCleanup: true });\n    injector.get(DestroyRef).onDestroy(() => {\n        watcher.destroy();\n        subject.complete();\n    });\n    return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](/guide/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n    ngDevMode &&\n        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +\n            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n    const requiresCleanup = !options?.manualCleanup;\n    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n    const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n    // the same - the returned signal gives values of type `T`.\n    let state;\n    if (options?.requireSync) {\n        // Initially the signal is in a `NoValue` state.\n        state = signal({ kind: 0 /* StateKind.NoValue */ });\n    }\n    else {\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue });\n    }\n    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n    // this, we would subscribe to the observable outside of the current reactive context, avoiding\n    // that side-effect signal reads/writes are attribute to the current consumer. The current\n    // consumer only needs to be notified when the `state` signal changes through the observable\n    // subscription. Additional context (related to async pipe):\n    // https://github.com/angular/angular/pull/50522.\n    const sub = source.subscribe({\n        next: value => state.set({ kind: 1 /* StateKind.Value */, value }),\n        error: error => {\n            if (options?.rejectErrors) {\n                // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n                // the error to end up as an uncaught exception.\n                throw error;\n            }\n            state.set({ kind: 2 /* StateKind.Error */, error });\n        },\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n        // \"complete\".\n    });\n    if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n    // to either values or errors.\n    return computed(() => {\n        const current = state();\n        switch (current.kind) {\n            case 1 /* StateKind.Value */:\n                return current.value;\n            case 2 /* StateKind.Error */:\n                throw current.error;\n            case 0 /* StateKind.NoValue */:\n                // This shouldn't really happen because the error is thrown on creation.\n                // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n                throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n        }\n    });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { outputFromObservable, outputToObservable, takeUntilDestroyed, toObservable, toSignal };\n\n", "import { assertInInjectionContext, inject, Injector, runInInjectionContext } from '@angular/core';\n\nfunction assertInjector(fn, injector, runner) {\n    !injector && assertInInjectionContext(fn);\n    const assertedInjector = injector ?? inject(Injector);\n    if (!runner)\n        return assertedInjector;\n    return runInInjectionContext(assertedInjector, runner);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { assertInjector };\n\n", "import { DestroyRef, untracked, Injector, effect } from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { assertInjector } from 'ngxtension/assert-injector';\nimport { Subscription, isObservable } from 'rxjs';\n\nfunction connect(signal, ...args) {\n    const [observable, reducer, injectorOrDestroyRef, useUntracked, originSignal,] = parseArgs(args);\n    if (observable) {\n        let destroyRef = null;\n        if (injectorOrDestroyRef instanceof DestroyRef) {\n            destroyRef = injectorOrDestroyRef; // if it's a DestroyRef, use it\n        }\n        else {\n            const injector = assertInjector(connect, injectorOrDestroyRef);\n            destroyRef = injector.get(DestroyRef);\n        }\n        return observable.pipe(takeUntilDestroyed(destroyRef)).subscribe((x) => {\n            const update = () => {\n                signal.update((prev) => {\n                    if (!isObject(prev)) {\n                        return reducer?.(prev, x) || x;\n                    }\n                    if (!isObject(x)) {\n                        const reducedValue = reducer ? reducer(prev, x) : x;\n                        return isObject(reducedValue)\n                            ? { ...prev, ...reducedValue }\n                            : reducedValue;\n                    }\n                    return { ...prev, ...(reducer?.(prev, x) || x) };\n                });\n            };\n            if (useUntracked) {\n                untracked(update);\n            }\n            else {\n                update();\n            }\n        });\n    }\n    if (originSignal) {\n        const injector = injectorOrDestroyRef instanceof Injector\n            ? assertInjector(connect, injectorOrDestroyRef)\n            : undefined;\n        return effect(() => {\n            signal.update((prev) => {\n                if (!isObject(prev)) {\n                    return originSignal();\n                }\n                return { ...prev, ...originSignal() };\n            });\n        }, {\n            allowSignalWrites: true,\n            injector,\n        });\n    }\n    return {\n        with(...args) {\n            if (!this.subscription) {\n                this.subscription = new Subscription();\n            }\n            else if (this.subscription.closed) {\n                console.info(`[ngxtension connect] ConnectedSignal has been closed.`);\n                return this;\n            }\n            this.subscription.add(connect(signal, ...args, injectorOrDestroyRef, useUntracked));\n            return this;\n        },\n        subscription: null,\n    };\n}\n// TODO: there must be a way to parse the args more efficiently\nfunction parseArgs(args) {\n    if (args.length > 3) {\n        return [\n            args[0],\n            args[1],\n            args[2],\n            args[3],\n            null,\n        ];\n    }\n    if (args.length === 3) {\n        if (typeof args[2] === 'boolean') {\n            if (isObservable(args[0])) {\n                return [\n                    args[0],\n                    null,\n                    args[1],\n                    args[2],\n                    null,\n                ];\n            }\n            else {\n                return [\n                    null,\n                    null,\n                    args[1],\n                    args[2],\n                    args[0],\n                ];\n            }\n        }\n        return [\n            args[0],\n            args[1],\n            args[2],\n            false,\n            null,\n        ];\n    }\n    if (args.length === 2) {\n        if (typeof args[1] === 'boolean') {\n            return [null, null, args[0], args[1], null];\n        }\n        if (typeof args[1] === 'function') {\n            return [\n                args[0],\n                args[1],\n                null,\n                false,\n                null,\n            ];\n        }\n        return [\n            args[0],\n            null,\n            args[1],\n            false,\n            null,\n        ];\n    }\n    if (isObservable(args[0])) {\n        return [args[0], null, null, false, null];\n    }\n    // to connect signals to other signals, we need to use a callback that includes a signal call\n    if (typeof args[0] === 'function') {\n        return [null, null, null, false, args[0]];\n    }\n    return [null, null, args[0], false, null];\n}\nfunction isObject(val) {\n    return (typeof val === 'object' &&\n        val !== undefined &&\n        val !== null &&\n        !Array.isArray(val));\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { connect };\n\n", "import { inject, DestroyRef, Injector, signal, computed, effect } from '@angular/core';\nimport { toObservable, takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { connect } from 'ngxtension/connect';\nimport { isObservable, Subject, share, take } from 'rxjs';\n\nfunction signalSlice(config) {\n    const destroyRef = inject(DestroyRef);\n    const injector = inject(Injector);\n    const { initialState, sources = [], lazySources = [], actionSources = {}, selectors = (() => ({})), effects = (() => ({})), } = config;\n    const state = signal(initialState);\n    const readonlyState = state.asReadonly();\n    const state$ = toObservable(state);\n    let lazySourcesLoaded = false;\n    const subs = [];\n    const slice = readonlyState;\n    connectSources(state, sources);\n    for (const [key, actionSource] of Object.entries(actionSources)) {\n        if (isObservable(actionSource)) {\n            addReducerProperties(readonlyState, state$, key, destroyRef, actionSource, subs);\n        }\n        else {\n            const subject = new Subject();\n            const observable = actionSource(readonlyState, subject);\n            const sharedObservable = observable.pipe(share());\n            connect(state, sharedObservable);\n            addReducerProperties(readonlyState, state$, key, destroyRef, subject, subs, sharedObservable);\n        }\n    }\n    for (const key in initialState) {\n        Object.defineProperty(readonlyState, key, {\n            value: computed(() => readonlyState()[key]),\n        });\n    }\n    for (const [key, selector] of Object.entries(selectors(slice))) {\n        Object.defineProperty(readonlyState, key, {\n            value: computed(selector),\n        });\n    }\n    for (const [key, namedEffect] of Object.entries(effects(slice))) {\n        console.warn(\"The 'effects' configuration in signalSlice is deprecated. Please use standard signal effects outside of signalSlice instead.\");\n        Object.defineProperty(slice, key, {\n            value: effect((onCleanup) => {\n                const maybeCleanup = namedEffect();\n                if (maybeCleanup) {\n                    onCleanup(() => maybeCleanup());\n                }\n            }),\n        });\n    }\n    destroyRef.onDestroy(() => {\n        subs.forEach((sub) => sub.complete());\n    });\n    const connectLazySources = () => {\n        if (!lazySourcesLoaded) {\n            lazySourcesLoaded = true;\n            connectSources(state, lazySources, injector, true);\n        }\n    };\n    return new Proxy(slice, {\n        get(target, property, receiver) {\n            connectLazySources();\n            return Reflect.get(target, property, receiver);\n        },\n        apply(target, thisArg, argumentsList) {\n            connectLazySources();\n            return Reflect.apply(target, thisArg, argumentsList);\n        },\n    });\n}\nfunction connectSources(state, sources, injector, useUntracked = false) {\n    for (const source of sources) {\n        if (isObservable(source)) {\n            connect(state, source, injector, useUntracked);\n        }\n        else {\n            connect(state, source(state.asReadonly()), injector, useUntracked);\n        }\n    }\n}\nfunction addReducerProperties(readonlyState, state$, key, destroyRef, subject, subs, observableFromActionSource) {\n    Object.defineProperties(readonlyState, {\n        [key]: {\n            value: (nextValue) => {\n                if (isObservable(nextValue)) {\n                    return new Promise((res, rej) => {\n                        nextValue.pipe(takeUntilDestroyed(destroyRef)).subscribe({\n                            next: (value) => {\n                                subject.next(value);\n                            },\n                            error: (err) => {\n                                subject.error(err);\n                                rej(err);\n                            },\n                            complete: () => {\n                                subject.complete();\n                                res(readonlyState());\n                            },\n                        });\n                    });\n                }\n                if (observableFromActionSource) {\n                    observableFromActionSource\n                        .pipe(takeUntilDestroyed(destroyRef))\n                        .subscribe();\n                }\n                return new Promise((res) => {\n                    state$.pipe(take(1)).subscribe((val) => {\n                        res(val);\n                    });\n                    subject.next(nextValue);\n                });\n            },\n        },\n        [`${key}$`]: {\n            value: subject.asObservable(),\n        },\n    });\n    subs.push(subject);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { signalSlice };\n\n"],
  "mappings": "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",
  "names": ["signal", "args"]
}
