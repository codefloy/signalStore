import { InjectionToken, type Provider } from '@angular/core';
import { AbstractControl, FormGroupDirective, NgForm, type ValidationErrors } from '@angular/forms';
import { Observable } from 'rxjs';
import * as i0 from "@angular/core";
export declare const dirty$: (control: AbstractControl) => Observable<boolean>;
export declare const touched$: (control: AbstractControl) => Observable<boolean>;
/**
 *  Defines when a {@link AbstractControl control} is in an *state*.
 */
export type StateMatcher = (control: AbstractControl, parent?: FormGroupDirective | NgForm) => Observable<boolean>;
/**
 * Emits whenever the value, status, touched/untouched state of the control changes or the parent submits.
 *
 * Evaluates to `true` when the control status is `INVALID` and it is `touched` or the parent is `submitted`.
 */
export declare const NGX_DEFAULT_CONTROL_ERROR_STATE_MATCHER: StateMatcher;
export declare const NGX_CONTROL_ERROR_STATE_MATCHER: InjectionToken<StateMatcher>;
export declare const NGX_CONTROL_ERROR_PARENT: InjectionToken<FormGroupDirective | NgForm>;
/**
 * Configures {@link NgxControlError}.
 */
export declare const provideNgxControlError: (options?: {
    errorStateMatcher?: () => StateMatcher;
    parent?: () => NgForm | FormGroupDirective;
}) => Provider[];
/**
 * Represents the context of the template the {@link NgxControlError} sits on.
 */
export interface NgxControlErrorContext {
    /**
     * Reference to the `errors` of {@link NgxControlError.control}
     */
    $implicit: ValidationErrors;
    /**
     * Reference to {@link NgxControlError.control}
     */
    control: AbstractControl;
    /**
     * Reference to {@link NgxControlError.track}
     */
    track: string | string[];
}
/**
 * Structural directive for displaying form control errors consistently and reduce boilerplate.
 *
 * ## Usage
 *
 * ```html
 * <label>
 * 	<b>Name</b>
 * 	<input type="text" [formControl]="name" />
 * 	<strong *ngxControlError="name; track: 'required'">Name is required.</strong>
 * </label>
 * ```
 *
 * The template will be rendered, when the control is in an [_error state_](#configuration) and its errors include the tracked error(s).
 *
 * without `NgxControlError`:
 *
 * ```html
 * <label>
 * 	<b>Name</b>
 * 	<input type="text" [formControl]="name" />
 * 	@if (name.hasError('required') && (name.touched || form.submitted)) {
 * 	<strong>Name is required.</strong>
 * 	}
 * </label>
 * ```
 *
 * ## Configuration
 *
 * A `StateMatcher` defines when the provided control is in an _error state_.
 * A `StateMatcher` is a function which returns an observable. Every time the `StateMatcher` emits a value, the directive checks whether it should render or hide its template:
 * The directive renders its template when the `StateMatcher` emits `true` and the errors of the control include at least 1 tracked error, else its template will be hidden.
 *
 * ```ts
 * export type StateMatcher = (
 * control: AbstractControl,
 * parent?: FormGroupDirective | NgForm,
 * ) => Observable<boolean>;
 * ```
 *
 * Per default the control is considered in an _error state_ when 1. its status is `INVALID` and 2. it is `touched` or its form has been `submitted`.
 *
 * You can override this behavior:
 *
 * ```ts
 * //
 * // A control is in an error state when its status is invalid.
 * // Emits whenever statusChanges emits.
 * // You may want to add more sources, such as valueChanges.
 * //
 * export const customErrorStateMatcher: StateMatcher = (control) =>
 * control.statusChanges.pipe(
 * startWith(control.status),
 * map((status) => status === 'INVALID'),
 * );
 * ```
 *
 * ### Via DI
 *
 * ```ts
 * provideNgxControlError({ errorStateMatcher: customErrorStateMatcher });
 * ```
 *
 * ### Via Input
 *
 * ```html
 * <label>
 * 	<b>Name</b>
 * 	<input type="text" [formControl]="name" />
 * 	<strong *ngxControlError="name; track: 'required'; errorStateMatcher: customErrorStateMatcher">Name is required.</strong>
 * </label>
 * ```
 *
 * ## Integration
 *
 * ### [NGX Translate](https://github.com/ngx-translate/core)
 *
 * You can iterate over all possible errors and pass the `errors` to the translate pipe:
 *
 * ```html
 * <label>
 * 	<b>Mail</b>
 * 	<input type="email" [formControl]="mail" />
 * 	@for (error of ['required', 'email', 'myCustomError']; track error) {
 * 	<strong *ngxControlError="mail; track: error">{{ "PATH.TO.MAIL_CONTROL.ERRORS." + error | translate: mail.errors }}</strong>
 * 	}
 * </label>
 * ```
 *
 * ### [Angular Material](https://github.com/angular/components)
 *
 * ```html
 * <mat-form-field>
 * 	<mat-label>Name</mat-label>
 * 	<input matInput [formControl]="name" />
 * 	<mat-error *ngxControlError="name; track: 'required'">Name is required.</mat-error>
 * </mat-form-field>
 * ```
 */
export declare class NgxControlError {
    /** @ignore */
    private readonly templateRef;
    /** @ignore */
    private readonly viewContainerRef;
    constructor();
    /**
     * The errors this directive tracks, when a {@link control$ control} is provided.
     */
    set track(track: string | string[] | undefined);
    get track(): string | string[] | undefined;
    /**
     * The control which `errors` are tracked.
     *
     * @see {@link AbstractControl.errors}
     */
    set control(control: AbstractControl<any, any> | undefined);
    get control(): AbstractControl<any, any> | undefined;
    /**
     *  A `StateMatcher` which defines when this {@link control$ control} is in an *error state*.
     *  This directive **ONLY** renders this template when the `StateMatcher` evaluates to `true`.
     *
     *  Defaults to {@link NGX_CONTROL_ERROR_STATE_MATCHER}.
     */
    set errorStateMatcher(errorStateMatcher: StateMatcher);
    get errorStateMatcher(): StateMatcher;
    /**
     * The parent of this {@link control$ control}.
     *
     * NOTE: Might not be the control referenced by {@link AbstractControl.parent parent} of this {@link control$ control}.
     */
    set parent(parent: FormGroupDirective | NgForm | undefined);
    get parent(): FormGroupDirective | NgForm | undefined;
    /**
     * The errors this directive tracks, when a {@link control$ control} is provided.
     */
    readonly track$: import("@angular/core").WritableSignal<string | string[] | undefined>;
    /**
     * The parent of this {@link control$ control}.
     *
     * NOTE: Might not be the control referenced by {@link AbstractControl.parent parent} of this {@link control$ control}.
     */
    readonly parent$: import("@angular/core").WritableSignal<FormGroupDirective | NgForm | undefined>;
    /**
     * The control which `errors` are tracked.
     *
     * @see {@link AbstractControl.errors}
     */
    readonly control$: import("@angular/core").WritableSignal<AbstractControl<any, any> | undefined>;
    /**
     *  A `StateMatcher` which defines when this {@link control$ control} is in an *error state*.
     *  This directive **ONLY** renders this template when the `StateMatcher` evaluates to `true`.
     *
     *  Defaults to {@link NGX_CONTROL_ERROR_STATE_MATCHER}.
     */
    readonly errorStateMatcher$: import("@angular/core").WritableSignal<StateMatcher>;
    /**
     * The context of this template.
     */
    get context(): NgxControlErrorContext;
    /**
     * Whether this {@link control$ control's} errors include one of the {@link track$ tracked errors} and whether it is in an *{@link errorState$ error state}*.
     */
    private readonly _hasError$;
    /**
     * Whether this {@link control$ control's} errors include one of the {@link track$ tracked errors} and whether it is in an *{@link errorState$ error state}*.
     */
    readonly hasError$: import("@angular/core").Signal<boolean>;
    /** @ignore */
    static ngTemplateContextGuard: (directive: NgxControlError, context: unknown) => context is NgxControlErrorContext;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxControlError, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgxControlError, "[ngxControlError]", never, { "track": { "alias": "ngxControlErrorTrack"; "required": true; }; "control": { "alias": "ngxControlError"; "required": true; }; "errorStateMatcher": { "alias": "ngxControlErrorErrorStateMatcher"; "required": false; }; "parent": { "alias": "ngxControlErrorParent"; "required": false; }; }, {}, never, never, true, never>;
}
