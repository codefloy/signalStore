import { type EffectRef, type Signal } from '@angular/core';
import { type PartialOrValue, type Reducer } from 'ngxtension/connect';
import { Subject, type Observable } from 'rxjs';
type ActionSourceFn<TSignalValue, TPayload> = (state: Signal<TSignalValue>, value: TPayload) => Observable<PartialOrValue<TSignalValue>>;
type NoOptionalProperties<T> = {
    [P in keyof T]-?: T[P];
};
type NamedActionSources<TSignalValue> = {
    [actionName: string]: Subject<any> | ActionSourceFn<TSignalValue, any>;
};
type NamedSelectors = {
    [selectorName: string]: () => any;
};
type Selectors<TSignalValue> = {
    [K in keyof TSignalValue]: Signal<TSignalValue[K]>;
};
type ExtraSelectors<TSelectors extends NamedSelectors> = {
    [K in keyof TSelectors]: Signal<ReturnType<TSelectors[K]>>;
};
type NamedEffects = {
    [selectorName: string]: () => void | (() => void);
};
type Effects<TEffects extends NamedEffects> = {
    [K in keyof TEffects]: EffectRef;
};
type Action<TSignalValue, TValue> = TValue extends [void] ? () => Promise<TSignalValue> : [unknown] extends TValue ? () => Promise<TSignalValue> : (value: TValue extends [infer TInferred] ? TInferred | Observable<TInferred> : TValue | Observable<TValue>) => Promise<TSignalValue>;
type ActionMethod<TSignalValue, TActionSource extends NamedActionSources<TSignalValue>[string]> = TActionSource extends (state: Signal<TSignalValue>, value: Observable<infer TObservableValue>) => any ? Action<TSignalValue, [TObservableValue]> : TActionSource extends Subject<infer TSubjectValue> ? Action<TSignalValue, [TSubjectValue]> : never;
type ActionMethods<TSignalValue, TActionSources extends NamedActionSources<TSignalValue>> = {
    [K in keyof TActionSources]: ActionMethod<TSignalValue, TActionSources[K]>;
};
type ActionStreams<TSignalValue, TActionSources extends NamedActionSources<TSignalValue>> = {
    [K in keyof TActionSources & string as `${K}$`]: TActionSources[K] extends Reducer<TSignalValue, unknown> ? Observable<void> : TActionSources[K] extends Reducer<TSignalValue, infer TValue> ? TValue extends Observable<any> ? TValue : Observable<TValue> : never;
};
export type Source<TSignalValue> = Observable<PartialOrValue<TSignalValue>>;
type SourceConfig<TSignalValue> = Array<Source<TSignalValue> | ((state: Signal<TSignalValue>) => Source<TSignalValue>)>;
export type SignalSlice<TSignalValue extends NoOptionalProperties<TSignalValue>, TActionSources extends NamedActionSources<TSignalValue>, TSelectors extends NamedSelectors, TEffects extends NamedEffects> = Signal<TSignalValue> & Selectors<TSignalValue> & ExtraSelectors<TSelectors> & Effects<TEffects> & ActionMethods<TSignalValue, TActionSources> & ActionStreams<TSignalValue, TActionSources>;
type SelectorsState<TSignalValue extends NoOptionalProperties<TSignalValue>> = Signal<TSignalValue> & Selectors<TSignalValue>;
type EffectsState<TSignalValue extends NoOptionalProperties<TSignalValue>, TActionSources extends NamedActionSources<TSignalValue>, TSelectors extends NamedSelectors> = SelectorsState<TSignalValue> & ExtraSelectors<TSelectors> & ActionMethods<TSignalValue, TActionSources>;
export declare function signalSlice<TSignalValue extends NoOptionalProperties<TSignalValue>, TActionSources extends NamedActionSources<TSignalValue>, TSelectors extends NamedSelectors, TEffects extends NamedEffects>(config: {
    initialState: TSignalValue;
    sources?: SourceConfig<TSignalValue>;
    lazySources?: SourceConfig<TSignalValue>;
    actionSources?: TActionSources;
    selectors?: (state: SelectorsState<TSignalValue>) => TSelectors;
    /** @deprecated */
    effects?: (state: EffectsState<TSignalValue, TActionSources, TSelectors>) => TEffects;
}): SignalSlice<TSignalValue, TActionSources, TSelectors, TEffects>;
export {};
