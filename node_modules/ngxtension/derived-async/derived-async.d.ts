import { Injector, type CreateComputedOptions, type Signal } from '@angular/core';
import { Observable } from 'rxjs';
type derivedAsyncBehavior = 'switch' | 'merge' | 'concat' | 'exhaust';
interface derivedAsyncOptions<T> extends CreateComputedOptions<T> {
    injector?: Injector;
    behavior?: derivedAsyncBehavior;
}
type OptionsWithInitialValue<T> = {
    initialValue: T;
} & derivedAsyncOptions<T>;
type OptionsWithOptionalInitialValue<T> = {
    initialValue?: undefined;
} & derivedAsyncOptions<T>;
type OptionsWithRequireSync<T> = {
    requireSync: true;
} & derivedAsyncOptions<T>;
type ObservableComputation<T> = (previousValue?: T | undefined) => Observable<T> | T;
type PromiseComputation<T> = (previousValue?: T | undefined) => Promise<T> | T;
/**
 * A computed value that can be async! This is useful for when you need to compute a value based on a Promise or Observable.
 *
 * @example
 * ```ts
 * const value = derivedAsync(() =>
 *   fetch(`https://localhost/api/people/${this.userId()}`).then(r => r.json())
 * );
 * ```
 *
 * The computed value will be `undefined` until the promise resolves.
 * Everytime the userId changes, the fetch will be called again, and the previous fetch will be cancelled (it uses switchMap by default).
 * If the promise rejects, the error will be thrown.
 *
 * It can also be used with Observables:
 *
 * ```ts
 * const value = derivedAsync(() =>
 *  this.http.get(`https://localhost/api/people/${this.userId()}`)
 * );
 * ```
 *
 * You can also pass an `initialValue` option to set the initial value of the computed value.
 *
 * ```ts
 * const userTasks = derivedAsync(() =>
 *   this.http.get(`https://localhost/api/tasks?userId=${this.userId()}`),
 *   { initialValue: [] }
 * );
 * ```
 *
 * If you want to require that the observable emits synchronously when `derivedAsync` subscribes, you can set the `requireSync` option to `true`.
 *
 * ```ts
 * const userTasks = derivedAsync(() =>
 *   this.http.get(`https://localhost/api/tasks?userId=${this.userId()}`).pipe(
 * 	   startWith([]),
 *   ),
 *   { requireSync: true }
 * );
 *
 * You can also pass a `behavior` option to change the behavior of the computed value.
 * - `switch` (default): will cancel the previous computation when a new one is triggered
 * - `merge`: will use `mergeMap` to merge the last observable with the new one
 * - `concat`: will use `concatMap` to concat the last observable with the new one
 * - `exhaust`: will use `exhaustMap` to skip all the new emissions until the last observable completes
 *
 * You can also pass an `injector` option if you want to use it outside of the injection context.
 *
 * @param computation
 * @param options
 */
export declare function derivedAsync<T>(computation: (previousValue?: T | undefined) => Promise<T> | Observable<T> | T | undefined): Signal<T | undefined>;
export declare function derivedAsync<T>(computation: (previousValue?: T | undefined) => Observable<T> | Promise<T> | T | undefined, options: OptionsWithOptionalInitialValue<T>): Signal<T | undefined>;
export declare function derivedAsync<T>(computation: PromiseComputation<T>, options: {
    initialValue?: null;
} & derivedAsyncOptions<T>): Signal<T | null>;
export declare function derivedAsync<T>(computation: PromiseComputation<T>, options: OptionsWithInitialValue<T>): Signal<T>;
export declare function derivedAsync<T>(computation: (previousValue?: T | undefined) => Promise<T>, options: OptionsWithOptionalInitialValue<T> & {
    /**
     * @throws Because the promise will not resolve synchronously.
     */
    requireSync: true;
}): never;
export declare function derivedAsync<T>(computation: (previousValue?: T | undefined) => Promise<T>, options: OptionsWithInitialValue<T> & {
    /**
     * @throws Because the promise will not resolve synchronously.
     */
    requireSync: true;
}): never;
export declare function derivedAsync<T>(computation: (previousValue?: T | undefined) => Observable<T> | T | undefined, options: {
    initialValue?: undefined;
    requireSync?: false;
} & derivedAsyncOptions<T>): Signal<T | undefined>;
export declare function derivedAsync<T>(computation: ObservableComputation<T>, options: {
    initialValue?: null;
    requireSync?: false;
} & derivedAsyncOptions<T>): Signal<T | null>;
export declare function derivedAsync<T>(computation: ObservableComputation<T>, options: OptionsWithRequireSync<T> & {
    initialValue?: undefined;
}): Signal<T>;
export declare function derivedAsync<T>(computation: ObservableComputation<T>, options: OptionsWithRequireSync<T> & {
    initialValue: T;
}): Signal<T>;
export declare function derivedAsync<T>(computation: ObservableComputation<T>, options: OptionsWithInitialValue<T>): Signal<T>;
export {};
