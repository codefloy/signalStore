import * as i0 from '@angular/core';
import { inject, NgZone, Injectable, ElementRef, DestroyRef } from '@angular/core';
import { assertInjector } from 'ngxtension/assert-injector';
import { injectDestroy } from 'ngxtension/inject-destroy';
import { Subject } from 'rxjs';

class IsInViewportService {
    constructor() {
        this.ngZone = inject(NgZone);
        this.#observerListeners = new Map();
    }
    #observerListeners;
    #observer;
    #createObserver() {
        this.#observer = this.ngZone.runOutsideAngular(() => {
            return new IntersectionObserver((entries) => {
                for (const entry of entries) {
                    this.intersect(entry.target, entry);
                }
            });
        });
    }
    observe(element) {
        if (!this.#observer) {
            this.#createObserver();
        }
        if (this.#observerListeners.has(element)) {
            return this.#observerListeners.get(element);
        }
        this.#observerListeners.set(element, new Subject());
        this.#observer?.observe(element);
        return this.#observerListeners.get(element);
    }
    unobserve(element) {
        this.#observer?.unobserve(element);
        this.#observerListeners.get(element)?.complete();
        this.#observerListeners.delete(element);
        if (this.#observerListeners.size === 0) {
            this.#disconnect();
        }
    }
    intersect(element, entry) {
        const subject = this.#observerListeners.get(element);
        // only emit if the subject is subscribed to
        if (subject?.observed) {
            this.ngZone.run(() => subject.next(entry));
        }
    }
    #disconnect() {
        this.#observer?.disconnect();
        this.#observer = undefined;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: IsInViewportService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: IsInViewportService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: IsInViewportService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

/**
 * Injects an observable that emits whenever the element is intersecting the viewport.
 * The observable will complete when the element is destroyed.
 * @param options
 *
 * @example
 * export class MyComponent {
 *   private destroyRef = inject(DestroyRef);
 *
 *   isIntersecting$ = injectIsIntersecting();
 *   isInViewport$ = this.isIntersecting$.pipe(
 *     filter(x => x.intersectionRatio > 0),
 *     take(1),
 *   );
 *
 *   ngOnInit() {
 *     this.getData().subscribe();
 *   }
 *
 *   getData() {
 *     // Only fetch data when the element is in the viewport
 *     return this.isInViewport$.pipe(
 *       switchMap(() => this.service.getData()),
 *       takeUntil(this.destroy$)
 *     );
 *   }
 * }
 */
const injectIsIntersecting = ({ injector, element, } = {}) => {
    return assertInjector(injectDestroy, injector, () => {
        const el = element ?? inject(ElementRef).nativeElement;
        const inInViewportService = inject(IsInViewportService);
        const destroyRef = inject(DestroyRef);
        const sub = inInViewportService.observe(el);
        destroyRef.onDestroy(() => {
            inInViewportService.unobserve(el);
        });
        return sub;
    });
};

/**
 * Generated bundle index. Do not edit.
 */

export { IsInViewportService, injectIsIntersecting };
//# sourceMappingURL=ngxtension-inject-is-intersecting.mjs.map
