{"version":3,"file":"ngxtension-inject-query-params.mjs","sources":["../../../../libs/ngxtension/inject-query-params/src/inject-query-params.ts","../../../../libs/ngxtension/inject-query-params/src/ngxtension-inject-query-params.ts"],"sourcesContent":["import { assertInInjectionContext, inject, type Signal } from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport { ActivatedRoute, type Params } from '@angular/router';\nimport { map } from 'rxjs';\n\ntype QueryParamsTransformFn<ReadT> = (params: Params) => ReadT;\n\n/**\n * The `InputOptions` interface defines options for configuring the behavior of the `injectQueryParams` function.\n *\n * @template ReadT - The expected type of the read value.\n * @template WriteT - The type of the value to be written.\n * @template InitialValueT - The type of the initial value.\n */\nexport interface QueryParamsOptions<ReadT, WriteT, InitialValueT> {\n\t/**\n\t * A transformation function to convert the written value to the expected read value.\n\t *\n\t * @param v - The value to transform.\n\t * @returns The transformed value.\n\t */\n\ttransform?: (v: WriteT) => ReadT;\n\n\t/**\n\t * The initial value to use if the query parameter is not present or undefined.\n\t */\n\tinitialValue?: InitialValueT;\n}\n\n/**\n * The `injectQueryParams` function allows you to access and manipulate query parameters from the current route.\n *\n * @returns A `Signal` that emits the entire query parameters object.\n */\nexport function injectQueryParams(): Signal<Params>;\n\n/**\n * The `injectQueryParams` function allows you to access and manipulate query parameters from the current route.\n *\n * @param {string} key - The name of the query parameter to retrieve.\n * @returns {Signal} A `Signal` that emits the value of the specified query parameter, or `null` if it's not present.\n */\nexport function injectQueryParams(key: string): Signal<string | null>;\n\n/**\n * The `injectQueryParams` function allows you to access and manipulate query parameters from the current route.\n *\n * @param {string} key - The name of the query parameter to retrieve.\n * @param {QueryParamsOptions} options - Optional configuration options for the query parameter.\n * @returns {Signal} A `Signal` that emits the transformed value of the specified query parameter, or `null` if it's not present.\n */\nexport function injectQueryParams(\n\tkey?: string,\n\toptions?: QueryParamsOptions<boolean, string, boolean>,\n): Signal<boolean | null>;\n\n/**\n * The `injectQueryParams` function allows you to access and manipulate query parameters from the current route.\n *\n * @param {string} key - The name of the query parameter to retrieve.\n * @param {QueryParamsOptions} options - Optional configuration options for the query parameter.\n * @returns {Signal} A `Signal` that emits the transformed value of the specified query parameter, or `null` if it's not present.\n */\nexport function injectQueryParams(\n\tkey?: string,\n\toptions?: QueryParamsOptions<number, string, number>,\n): Signal<number | null>;\n\n/**\n * The `injectQueryParams` function allows you to access and manipulate query parameters from the current route.\n *\n * @param {string} key - The name of the query parameter to retrieve.\n * @param {QueryParamsOptions} options - Optional configuration options for the query parameter.\n * @returns {Signal} A `Signal` that emits the transformed value of the specified query parameter, or `null` if it's not present.\n */\nexport function injectQueryParams(\n\tkey?: string,\n\toptions?: QueryParamsOptions<string, string, string>,\n): Signal<string | null>;\n\n/**\n * The `injectQueryParams` function allows you to access and manipulate query parameters from the current route.\n * It retrieves the value of a query parameter based on a custom transform function applied to the query parameters object.\n *\n * @template ReadT - The expected type of the read value.\n * @param {QueryParamsTransformFn<ReadT>} fn - A transform function that takes the query parameters object (`params: Params`) and returns the desired value.\n * @returns {Signal} A `Signal` that emits the transformed value based on the provided custom transform function.\n *\n * @example\n * const searchValue = injectQueryParams((params) => params['search'] as string);\n */\nexport function injectQueryParams<ReadT>(\n\tfn: QueryParamsTransformFn<ReadT>,\n): Signal<ReadT>;\n\n/**\n * The `injectQueryParams` function allows you to access and manipulate query parameters from the current route.\n *\n * @template ReadT - The expected type of the read value.\n * @param {string} keyOrParamsTransform - The name of the query parameter to retrieve, or a transform function to apply to the query parameters object.\n * @param {QueryParamsOptions} options - Optional configuration options for the query parameter.\n * @returns {QueryParamsOptions} A `Signal` that emits the transformed value of the specified query parameter, or the entire query parameters object if no key is provided.\n *\n * @example\n * const search = injectQueryParams('search'); // returns the value of the 'search' query param\n * const search = injectQueryParams(p => p['search'] as string); // same as above but can be used with a custom transform function\n * const idParam = injectQueryParams('id', {transform: numberAttribute}); // returns the value fo the 'id' query params and transforms it into a number\n * const idParam = injectQueryParams(p => numberAttribute(p['id'])); // same as above but can be used with a custom transform function\n * const queryParams = injectQueryParams(); // returns the entire query params object\n */\nexport function injectQueryParams<ReadT>(\n\tkeyOrParamsTransform?: string | ((params: Params) => ReadT),\n\toptions: QueryParamsOptions<ReadT, string, ReadT> = {},\n): Signal<ReadT | Params | string | boolean | number | null> {\n\tassertInInjectionContext(injectQueryParams);\n\tconst route = inject(ActivatedRoute);\n\tconst queryParams = route.snapshot.queryParams || {};\n\n\tconst { transform, initialValue } = options;\n\n\tif (!keyOrParamsTransform) {\n\t\treturn toSignal(route.queryParams, { initialValue: queryParams });\n\t}\n\n\tif (typeof keyOrParamsTransform === 'function') {\n\t\treturn toSignal(route.queryParams.pipe(map(keyOrParamsTransform)), {\n\t\t\tinitialValue: keyOrParamsTransform(queryParams),\n\t\t});\n\t}\n\n\tconst getParam = (params: Params) => {\n\t\tconst param = params?.[keyOrParamsTransform] as\n\t\t\t| string\n\t\t\t| string[]\n\t\t\t| undefined;\n\n\t\tif (!param) {\n\t\t\treturn initialValue ?? null;\n\t\t}\n\n\t\tif (Array.isArray(param)) {\n\t\t\tif (param.length < 1) {\n\t\t\t\treturn initialValue ?? null;\n\t\t\t}\n\t\t\treturn transform ? transform(param[0]) : param[0];\n\t\t}\n\n\t\treturn transform ? transform(param) : param;\n\t};\n\n\treturn toSignal(route.queryParams.pipe(map(getParam)), {\n\t\tinitialValue: getParam(queryParams),\n\t});\n}\n\n/**\n * The `injectQueryParams` function namespace provides additional functionality for handling array query parameters.\n */\nexport namespace injectQueryParams {\n\t/**\n\t * Retrieve an array query parameter with optional configuration options.\n\t *\n\t * @param {string} key - The name of the array query parameter to retrieve.\n\t * @param {QueryParamsOptions} options - Optional configuration options for the array query parameter.\n\t * @returns {Signal} A `Signal` that emits an array of values for the specified query parameter, or `null` if it's not present.\n\t */\n\texport function array(\n\t\tkey: string,\n\t\toptions?: QueryParamsOptions<boolean, string, boolean[]>,\n\t): Signal<boolean[] | null>;\n\n\t/**\n\t * Retrieve an array query parameter with optional configuration options.\n\t *\n\t * @param {string} key - The name of the array query parameter to retrieve.\n\t * @param {QueryParamsOptions} options - Optional configuration options for the array query parameter.\n\t * @returns {Signal} A `Signal` that emits an array of values for the specified query parameter, or `null` if it's not present.\n\t */\n\texport function array(\n\t\tkey: string,\n\t\toptions?: QueryParamsOptions<number, string, number[]>,\n\t): Signal<number[] | null>;\n\n\t/**\n\t * Retrieve an array query parameter with optional configuration options.\n\t *\n\t * @param {string} key - The name of the array query parameter to retrieve.\n\t * @param {QueryParamsOptions} options - Optional configuration options for the array query parameter.\n\t * @returns {Signal} A `Signal` that emits an array of values for the specified query parameter, or `null` if it's not present.\n\t */\n\texport function array(\n\t\tkey: string,\n\t\toptions?: QueryParamsOptions<string, string, string[]>,\n\t): Signal<string[] | null>;\n\n\t/**\n\t * Retrieve an array query parameter with optional configuration options.\n\t *\n\t * @template ReadT - The expected type of the read value.\n\t * @param {string} key - The name of the array query parameter to retrieve.\n\t * @param {QueryParamsOptions} options - Optional configuration options for the array query parameter.\n\t * @returns {Signal} A `Signal` that emits an array of transformed values for the specified query parameter, or `null` if it's not present.\n\t */\n\texport function array<ReadT>(\n\t\tkey: string,\n\t\toptions: QueryParamsOptions<ReadT, string, ReadT[]> = {},\n\t): Signal<(ReadT | string)[] | null> {\n\t\tassertInInjectionContext(injectQueryParams.array);\n\t\tconst route = inject(ActivatedRoute);\n\t\tconst queryParams = route.snapshot.queryParams || {};\n\n\t\tconst { transform, initialValue } = options;\n\n\t\tconst transformParam = (\n\t\t\tparam: string | string[] | null,\n\t\t): (string | ReadT)[] | null => {\n\t\t\tif (!param) {\n\t\t\t\treturn initialValue ?? null;\n\t\t\t}\n\t\t\tif (Array.isArray(param)) {\n\t\t\t\tif (param.length < 1) {\n\t\t\t\t\treturn initialValue ?? null;\n\t\t\t\t}\n\t\t\t\t// Avoid passing the transform function directly into the map function,\n\t\t\t\t// because transform may inadvertently use the array index as its second argument.\n\t\t\t\t// Typically, map provides the array index as the second argument to its callback,\n\t\t\t\t// which can conflict with transform functions like numberAttribute that expect a fallbackValue as their second parameter.\n\t\t\t\t// This mismatch can lead to unexpected behavior, such as values being erroneously converted to array indices\n\t\t\t\t// instead of NaN (which would be correct)\n\t\t\t\treturn transform ? param.map((it) => transform(it)) : param;\n\t\t\t}\n\t\t\treturn [transform ? transform(param) : param];\n\t\t};\n\n\t\tconst getParam = (params: Params) => {\n\t\t\tconst param = params?.[key];\n\n\t\t\treturn transformParam(param);\n\t\t};\n\n\t\treturn toSignal(route.queryParams.pipe(map(getParam)), {\n\t\t\tinitialValue: getParam(queryParams),\n\t\t});\n\t}\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}