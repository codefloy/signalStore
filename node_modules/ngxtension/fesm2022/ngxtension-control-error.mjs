import * as i0 from '@angular/core';
import { InjectionToken, inject, TemplateRef, ViewContainerRef, signal, Directive, Input } from '@angular/core';
import { toObservable, toSignal, takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { FormGroupDirective, NgForm } from '@angular/forms';
import { filterNil } from 'ngxtension/filter-nil';
import { BehaviorSubject, distinctUntilChanged, combineLatest, startWith, map, of, switchMap, shareReplay } from 'rxjs';

const dirty$ = (control) => {
    const dirty$ = new BehaviorSubject(control.dirty);
    const markAsPristine = control.markAsPristine.bind(control);
    const markAsDirty = control.markAsDirty.bind(control);
    control.markAsPristine = (...args) => {
        markAsPristine(...args);
        dirty$.next(false);
    };
    control.markAsDirty = (...args) => {
        markAsDirty(...args);
        dirty$.next(true);
    };
    return dirty$.pipe(distinctUntilChanged());
};
const touched$ = (control) => {
    const touched$ = new BehaviorSubject(control.touched);
    const markAsTouched = control.markAsTouched.bind(control);
    const markAsUntouched = control.markAsUntouched.bind(control);
    control.markAsTouched = (...args) => {
        markAsTouched(...args);
        touched$.next(true);
    };
    control.markAsUntouched = (...args) => {
        markAsUntouched(...args);
        touched$.next(false);
    };
    return touched$.pipe(distinctUntilChanged());
};
/**
 * Emits whenever the value, status, touched/untouched state of the control changes or the parent submits.
 *
 * Evaluates to `true` when the control status is `INVALID` and it is `touched` or the parent is `submitted`.
 */
const NGX_DEFAULT_CONTROL_ERROR_STATE_MATCHER = (control, parent) => combineLatest([
    control.valueChanges.pipe(startWith(control.value)),
    control.statusChanges.pipe(startWith(control.status), distinctUntilChanged()),
    touched$(control),
    parent?.ngSubmit.pipe(map(() => true), startWith(parent.submitted), distinctUntilChanged()) ?? of(false),
], (value, status, touched, submitted) => status === 'INVALID' && (touched || submitted));
const NGX_CONTROL_ERROR_STATE_MATCHER = new InjectionToken('NGX_CONTROL_ERROR_STATE_MATCHER', { factory: () => NGX_DEFAULT_CONTROL_ERROR_STATE_MATCHER });
const NGX_CONTROL_ERROR_PARENT = new InjectionToken('NGX_CONTROL_ERROR_PARENT');
/**
 * Configures {@link NgxControlError}.
 */
const provideNgxControlError = (options) => {
    const provider = [];
    if (options?.errorStateMatcher)
        provider.push({
            provide: NGX_CONTROL_ERROR_STATE_MATCHER,
            useFactory: options.errorStateMatcher,
        });
    if (options?.parent)
        provider.push({
            provide: NGX_CONTROL_ERROR_PARENT,
            useFactory: options.parent,
        });
    return provider;
};
/**
 * Structural directive for displaying form control errors consistently and reduce boilerplate.
 *
 * ## Usage
 *
 * ```html
 * <label>
 * 	<b>Name</b>
 * 	<input type="text" [formControl]="name" />
 * 	<strong *ngxControlError="name; track: 'required'">Name is required.</strong>
 * </label>
 * ```
 *
 * The template will be rendered, when the control is in an [_error state_](#configuration) and its errors include the tracked error(s).
 *
 * without `NgxControlError`:
 *
 * ```html
 * <label>
 * 	<b>Name</b>
 * 	<input type="text" [formControl]="name" />
 * 	@if (name.hasError('required') && (name.touched || form.submitted)) {
 * 	<strong>Name is required.</strong>
 * 	}
 * </label>
 * ```
 *
 * ## Configuration
 *
 * A `StateMatcher` defines when the provided control is in an _error state_.
 * A `StateMatcher` is a function which returns an observable. Every time the `StateMatcher` emits a value, the directive checks whether it should render or hide its template:
 * The directive renders its template when the `StateMatcher` emits `true` and the errors of the control include at least 1 tracked error, else its template will be hidden.
 *
 * ```ts
 * export type StateMatcher = (
 * control: AbstractControl,
 * parent?: FormGroupDirective | NgForm,
 * ) => Observable<boolean>;
 * ```
 *
 * Per default the control is considered in an _error state_ when 1. its status is `INVALID` and 2. it is `touched` or its form has been `submitted`.
 *
 * You can override this behavior:
 *
 * ```ts
 * //
 * // A control is in an error state when its status is invalid.
 * // Emits whenever statusChanges emits.
 * // You may want to add more sources, such as valueChanges.
 * //
 * export const customErrorStateMatcher: StateMatcher = (control) =>
 * control.statusChanges.pipe(
 * startWith(control.status),
 * map((status) => status === 'INVALID'),
 * );
 * ```
 *
 * ### Via DI
 *
 * ```ts
 * provideNgxControlError({ errorStateMatcher: customErrorStateMatcher });
 * ```
 *
 * ### Via Input
 *
 * ```html
 * <label>
 * 	<b>Name</b>
 * 	<input type="text" [formControl]="name" />
 * 	<strong *ngxControlError="name; track: 'required'; errorStateMatcher: customErrorStateMatcher">Name is required.</strong>
 * </label>
 * ```
 *
 * ## Integration
 *
 * ### [NGX Translate](https://github.com/ngx-translate/core)
 *
 * You can iterate over all possible errors and pass the `errors` to the translate pipe:
 *
 * ```html
 * <label>
 * 	<b>Mail</b>
 * 	<input type="email" [formControl]="mail" />
 * 	@for (error of ['required', 'email', 'myCustomError']; track error) {
 * 	<strong *ngxControlError="mail; track: error">{{ "PATH.TO.MAIL_CONTROL.ERRORS." + error | translate: mail.errors }}</strong>
 * 	}
 * </label>
 * ```
 *
 * ### [Angular Material](https://github.com/angular/components)
 *
 * ```html
 * <mat-form-field>
 * 	<mat-label>Name</mat-label>
 * 	<input matInput [formControl]="name" />
 * 	<mat-error *ngxControlError="name; track: 'required'">Name is required.</mat-error>
 * </mat-form-field>
 * ```
 */
class NgxControlError {
    constructor() {
        /** @ignore */
        this.templateRef = inject(TemplateRef);
        /** @ignore */
        this.viewContainerRef = inject(ViewContainerRef);
        /**
         * The errors this directive tracks, when a {@link control$ control} is provided.
         */
        this.track$ = signal(undefined);
        /**
         * The parent of this {@link control$ control}.
         *
         * NOTE: Might not be the control referenced by {@link AbstractControl.parent parent} of this {@link control$ control}.
         */
        this.parent$ = signal(inject(NGX_CONTROL_ERROR_PARENT, { optional: true }) ??
            inject(FormGroupDirective, { optional: true }) ??
            inject(NgForm, { optional: true }) ??
            undefined);
        /**
         * The control which `errors` are tracked.
         *
         * @see {@link AbstractControl.errors}
         */
        this.control$ = signal(undefined);
        /**
         *  A `StateMatcher` which defines when this {@link control$ control} is in an *error state*.
         *  This directive **ONLY** renders this template when the `StateMatcher` evaluates to `true`.
         *
         *  Defaults to {@link NGX_CONTROL_ERROR_STATE_MATCHER}.
         */
        this.errorStateMatcher$ = signal(inject(NGX_CONTROL_ERROR_STATE_MATCHER));
        /**
         * Whether this {@link control$ control's} errors include one of the {@link track$ tracked errors} and whether it is in an *{@link errorState$ error state}*.
         */
        this._hasError$ = combineLatest([
            toObservable(this.track$),
            toObservable(this.errorStateMatcher$),
            toObservable(this.control$).pipe(filterNil()),
            toObservable(this.parent$),
        ]).pipe(switchMap(([track, errorStateMatcher, control, parent]) => errorStateMatcher(control, parent).pipe(map((errorState) => errorState &&
            track != null &&
            control != null &&
            (typeof track === 'string'
                ? control.hasError(track)
                : track.some((x) => control.hasError(x)))))), shareReplay(1));
        /**
         * Whether this {@link control$ control's} errors include one of the {@link track$ tracked errors} and whether it is in an *{@link errorState$ error state}*.
         */
        this.hasError$ = toSignal(this._hasError$, {
            initialValue: false,
        });
        // Whenever one of the tracked errors are included in the controls errors and the control is in an error state, render this template.
        combineLatest([toObservable(this.track$), toObservable(this.control$), this._hasError$], (track, control, hasError) => {
            this.viewContainerRef.clear();
            if (hasError && control != null && track != null)
                this.viewContainerRef.createEmbeddedView(this.templateRef, {
                    $implicit: control.errors ?? {},
                    track,
                    control,
                });
        })
            .pipe(takeUntilDestroyed())
            .subscribe();
    }
    /**
     * The errors this directive tracks, when a {@link control$ control} is provided.
     */
    set track(track) {
        this.track$.set(track);
    }
    get track() {
        return this.track$();
    }
    /**
     * The control which `errors` are tracked.
     *
     * @see {@link AbstractControl.errors}
     */
    set control(control) {
        this.control$.set(control);
    }
    get control() {
        return this.control$();
    }
    /**
     *  A `StateMatcher` which defines when this {@link control$ control} is in an *error state*.
     *  This directive **ONLY** renders this template when the `StateMatcher` evaluates to `true`.
     *
     *  Defaults to {@link NGX_CONTROL_ERROR_STATE_MATCHER}.
     */
    set errorStateMatcher(errorStateMatcher) {
        this.errorStateMatcher$.set(errorStateMatcher);
    }
    get errorStateMatcher() {
        return this.errorStateMatcher$();
    }
    /**
     * The parent of this {@link control$ control}.
     *
     * NOTE: Might not be the control referenced by {@link AbstractControl.parent parent} of this {@link control$ control}.
     */
    set parent(parent) {
        this.parent$.set(parent);
    }
    get parent() {
        return this.parent$();
    }
    /**
     * The context of this template.
     */
    get context() {
        return this.viewContainerRef.get(0)?.context;
    }
    /** @ignore */
    static { this.ngTemplateContextGuard = (directive, context) => true; }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxControlError, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.3", type: NgxControlError, isStandalone: true, selector: "[ngxControlError]", inputs: { track: ["ngxControlErrorTrack", "track"], control: ["ngxControlError", "control"], errorStateMatcher: ["ngxControlErrorErrorStateMatcher", "errorStateMatcher"], parent: ["ngxControlErrorParent", "parent"] }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxControlError, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngxControlError]',
                    standalone: true,
                }]
        }], ctorParameters: () => [], propDecorators: { track: [{
                type: Input,
                args: [{ alias: 'ngxControlErrorTrack', required: true }]
            }], control: [{
                type: Input,
                args: [{ alias: 'ngxControlError', required: true }]
            }], errorStateMatcher: [{
                type: Input,
                args: [{ alias: 'ngxControlErrorErrorStateMatcher' }]
            }], parent: [{
                type: Input,
                args: [{ alias: 'ngxControlErrorParent' }]
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { NGX_CONTROL_ERROR_PARENT, NGX_CONTROL_ERROR_STATE_MATCHER, NGX_DEFAULT_CONTROL_ERROR_STATE_MATCHER, NgxControlError, dirty$, provideNgxControlError, touched$ };
//# sourceMappingURL=ngxtension-control-error.mjs.map
