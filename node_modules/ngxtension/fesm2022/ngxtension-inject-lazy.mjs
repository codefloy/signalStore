import { assertInjector } from 'ngxtension/assert-injector';
import * as i0 from '@angular/core';
import { EnvironmentInjector, DestroyRef, createEnvironmentInjector, Injectable, ENVIRONMENT_INITIALIZER, inject } from '@angular/core';
import { defer } from 'rxjs';

class InjectLazyImpl {
    constructor() {
        this.overrides = new WeakMap(); // no need to clean up
    }
    override(type, mock) {
        this.overrides.set(type, mock);
    }
    get(injector, loader) {
        return defer(() => loader().then((serviceOrDefault) => {
            const type = 'default' in serviceOrDefault
                ? serviceOrDefault.default
                : serviceOrDefault;
            // Check if we have overrides, O(1), low overhead
            if (this.overrides.has(type)) {
                const module = this.overrides.get(type);
                return new module();
            }
            // If the service uses DestroyRef.onDestroy() it will never be called.
            // Even if injector is a NodeInjector, this works only with providedIn: root.
            // So it's the root injector that will provide the DestroyRef (and thus never call OnDestroy).
            // The solution would be to create an EnvironmentInjector that provides the class we just lazy-loaded.
            if (!(injector instanceof EnvironmentInjector)) {
                // We're passing a node injector to the function
                // This is the DestroyRef of the component
                const destroyRef = injector.get(DestroyRef);
                // This is the parent injector of the environmentInjector we're creating
                const environmentInjector = injector.get(EnvironmentInjector);
                // Creating an environment injector to destroy it afterward
                const newInjector = createEnvironmentInjector([type], environmentInjector);
                // Destroy the injector to trigger DestroyRef.onDestroy on our service
                destroyRef.onDestroy(() => newInjector.destroy());
                // We want to create the new instance of our service with our new injector
                injector = newInjector;
            }
            return injector.get(type);
        }));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: InjectLazyImpl, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: InjectLazyImpl, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: InjectLazyImpl, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
/**
 * Helper function to mock the lazy-loaded module in `injectAsync`
 *
 * @usage
 * TestBed.configureTestingModule({
 *   providers: [
 *     mockLazyProvider(SandboxService, fakeSandboxService)
 *   ]
 * });
 */
function mockLazyProvider(type, mock) {
    return [
        {
            provide: ENVIRONMENT_INITIALIZER,
            multi: true,
            useValue: () => {
                inject(InjectLazyImpl).override(type, mock);
            },
        },
    ];
}

/**
 * Loads a service lazily. The service is loaded when the observable is subscribed to.
 *
 * @param loader A function that returns a promise of the service to load.
 * @param injector The injector to use to load the service. If not provided, the current injector is used.
 * @returns An observable of the service.
 *
 * @example
 * ```ts
 * const dataService$ = injectLazy(() => import('./data-service').then((m) => m.MyService));
 * or
 * const dataService$ = injectLazy(() => import('./data-service'));
 * ```
 */
function injectLazy(loader, injector) {
    injector = assertInjector(injectLazy, injector);
    const injectImpl = injector.get(InjectLazyImpl);
    return injectImpl.get(injector, loader);
}

/**
 * Generated bundle index. Do not edit.
 */

export { InjectLazyImpl, injectLazy, mockLazyProvider };
//# sourceMappingURL=ngxtension-inject-lazy.mjs.map
