{"version":3,"file":"ngxtension-derive-loading.mjs","sources":["../../../../libs/ngxtension/derive-loading/src/derive-loading.ts","../../../../libs/ngxtension/derive-loading/src/ngxtension-derive-loading.ts"],"sourcesContent":["import {\n\tcombineLatest,\n\tdebounce,\n\tdistinctUntilChanged,\n\tmap,\n\tmerge,\n\tMonoTypeOperatorFunction,\n\tObservable,\n\tOperatorFunction,\n\tReplaySubject,\n\tshare,\n\tstartWith,\n\ttakeUntil,\n\ttimer,\n} from 'rxjs';\n\nexport type DeriveLoadingOptions = {\n\t/**\n\t * The time in milliseconds to wait before emiting the loading flag = true.\n\t */\n\tthreshold?: number;\n\t/**\n\t * The time in milliseconds to wait before emiting the loading flag = false.\n\t */\n\tloadingTime?: number;\n};\n\n/**\n * Derive a loading state from the source observable.\n *\n * It will emit a loading flag in a \"non-flickering\" way. This means\n * if the async operation finishes before the threshold time, the loading flag will not change\n * to \"true\", it will stay false.\n *\n * It will only emit \"true\" when the async operation takes longer than the threshold time.\n * It will change back to \"false\" after at least the defined threshold + loadingTime has passed.\n * If the async operation takes longer than threshold + loadingtime, \"false\" will be emitted after the operation\n * has finished.\n *\n * @param options - The options to configure the loading state derivation.\n * @returns A observable that emits the loading flag.\n *\n * @param options\n */\nexport function deriveLoading<T>(\n\toptions?: DeriveLoadingOptions,\n): OperatorFunction<T, boolean> {\n\tconst threshold = options?.threshold ?? 500;\n\tconst loadingTime = options?.loadingTime ?? 1000;\n\n\treturn function <T>(source: Observable<T>): Observable<boolean> {\n\t\tconst result$ = source.pipe(\n\t\t\tshare({\n\t\t\t\tconnector: () => new ReplaySubject(1),\n\t\t\t\tresetOnComplete: false,\n\t\t\t\tresetOnRefCountZero: true,\n\t\t\t\tresetOnError: true,\n\t\t\t}),\n\t\t);\n\n\t\treturn merge(\n\t\t\ttimer(threshold).pipe(\n\t\t\t\tmap(() => true),\n\t\t\t\ttakeUntil(result$),\n\t\t\t),\n\t\t\tcombineLatest([result$, timer(threshold + loadingTime)]).pipe(\n\t\t\t\tmap(() => false),\n\t\t\t),\n\t\t).pipe(startWith(false), distinctUntilChanged(), handleSyncValue());\n\t};\n}\n\nfunction handleSyncValue<T>(): MonoTypeOperatorFunction<any> {\n\treturn (source$: Observable<T>): Observable<T> => {\n\t\treturn new Observable<T>((observer) => {\n\t\t\tconst isReadySubject = new ReplaySubject<unknown>(1);\n\n\t\t\tconst subscription = source$\n\t\t\t\t.pipe(\n\t\t\t\t\t/* Wait for all synchronous processing to be done. */\n\t\t\t\t\tdebounce(() => isReadySubject),\n\t\t\t\t)\n\t\t\t\t.subscribe(observer);\n\n\t\t\t/* Sync emitted values have been processed now.\n\t\t\t * Mark source as ready and emit last computed state. */\n\t\t\tisReadySubject.next(undefined);\n\n\t\t\treturn () => subscription.unsubscribe();\n\t\t});\n\t};\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;AA2BA;;;;;;;;;;;;;;;;AAgBG;AACG,SAAU,aAAa,CAC5B,OAA8B,EAAA;AAE9B,IAAA,MAAM,SAAS,GAAG,OAAO,EAAE,SAAS,IAAI,GAAG,CAAC;AAC5C,IAAA,MAAM,WAAW,GAAG,OAAO,EAAE,WAAW,IAAI,IAAI,CAAC;AAEjD,IAAA,OAAO,UAAa,MAAqB,EAAA;AACxC,QAAA,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAC1B,KAAK,CAAC;YACL,SAAS,EAAE,MAAM,IAAI,aAAa,CAAC,CAAC,CAAC;AACrC,YAAA,eAAe,EAAE,KAAK;AACtB,YAAA,mBAAmB,EAAE,IAAI;AACzB,YAAA,YAAY,EAAE,IAAI;AAClB,SAAA,CAAC,CACF,CAAC;AAEF,QAAA,OAAO,KAAK,CACX,KAAK,CAAC,SAAS,CAAC,CAAC,IAAI,CACpB,GAAG,CAAC,MAAM,IAAI,CAAC,EACf,SAAS,CAAC,OAAO,CAAC,CAClB,EACD,aAAa,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,SAAS,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,IAAI,CAC5D,GAAG,CAAC,MAAM,KAAK,CAAC,CAChB,CACD,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,oBAAoB,EAAE,EAAE,eAAe,EAAE,CAAC,CAAC;AACrE,KAAC,CAAC;AACH,CAAC;AAED,SAAS,eAAe,GAAA;IACvB,OAAO,CAAC,OAAsB,KAAmB;AAChD,QAAA,OAAO,IAAI,UAAU,CAAI,CAAC,QAAQ,KAAI;AACrC,YAAA,MAAM,cAAc,GAAG,IAAI,aAAa,CAAU,CAAC,CAAC,CAAC;YAErD,MAAM,YAAY,GAAG,OAAO;iBAC1B,IAAI;;AAEJ,YAAA,QAAQ,CAAC,MAAM,cAAc,CAAC,CAC9B;iBACA,SAAS,CAAC,QAAQ,CAAC,CAAC;AAEtB;AACwD;AACxD,YAAA,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AAE/B,YAAA,OAAO,MAAM,YAAY,CAAC,WAAW,EAAE,CAAC;AACzC,SAAC,CAAC,CAAC;AACJ,KAAC,CAAC;AACH;;AC3FA;;AAEG;;;;"}