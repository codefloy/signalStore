{"version":3,"file":"ngxtension-derived-from.mjs","sources":["../../../../libs/ngxtension/derived-from/src/derived-from.ts","../../../../libs/ngxtension/derived-from/src/ngxtension-derived-from.ts"],"sourcesContent":["import {\n\tInjector,\n\tcomputed,\n\tisSignal,\n\tuntracked,\n\ttype Signal,\n} from '@angular/core';\nimport { toObservable, toSignal } from '@angular/core/rxjs-interop';\nimport { assertInjector } from 'ngxtension/assert-injector';\nimport {\n\tcombineLatest,\n\tdistinctUntilChanged,\n\tfrom,\n\tidentity,\n\tisObservable,\n\tstartWith,\n\ttype ObservableInput,\n\ttype ObservableInputTuple,\n\ttype OperatorFunction,\n} from 'rxjs';\n\nexport type ObservableSignalInput<T> = ObservableInput<T> | Signal<T>;\nexport type DerivedFromOptions<T> = {\n\treadonly injector?: Injector;\n\treadonly initialValue?: T | null;\n}; //Pick<ToSignalOptions<T>,'injector' | 'initialValue'>;\nexport type InferObservableSignalOutput<I> = {\n\t[K in keyof I]: I[K] extends Signal<infer S>\n\t\t? S\n\t\t: I[K] extends ObservableInput<infer O>\n\t\t\t? O\n\t\t\t: never;\n};\n/**\n * So that we can have `fn([Observable<A>, Signal<B>]): Observable<[A, B]>`\n */\ntype ObservableSignalInputTuple<T> = {\n\t[K in keyof T]: ObservableSignalInput<T[K]> | (() => T[K]);\n};\n\nexport function derivedFrom<Input extends readonly unknown[], Output = Input>(\n\tsources: readonly [...ObservableSignalInputTuple<Input>],\n\toperator?: OperatorFunction<Input, Output>,\n\toptions?: DerivedFromOptions<Output>,\n): Signal<Output>;\n\nexport function derivedFrom<\n\tInput extends readonly unknown[],\n\tOutput = Input, //InferObservableSignalOutput<Input>\n>(\n\tsources: readonly [...ObservableSignalInputTuple<Input>],\n\toptions?: DerivedFromOptions<Input>,\n): Signal<Output>;\n\nexport function derivedFrom<Input extends object, Output = Input>(\n\tsources: ObservableSignalInputTuple<Input>,\n\toperator?: OperatorFunction<Input, Output>,\n\toptions?: DerivedFromOptions<Output>,\n): Signal<Output>;\n\nexport function derivedFrom<\n\tInput extends object,\n\tOutput = Input, //InferObservableSignalOutput<Input>\n>(\n\tsources: ObservableSignalInputTuple<Input>,\n\toptions?: DerivedFromOptions<Input>,\n): Signal<Output>;\n\n/**\n * `derivedFrom` is a function that takes an array/object with `Observable` or `Signal` values and returns a `Signal` that\n * emits the values of the `Observable` or `Signal` values. It is similar to `combineLatest` but it will emit\n * when the value of the `Observable` or `Signal` changes.\n *\n * @param {ObservableSignalInputTuple} sources - array/object of `Observable` or `Signal` values\n * @param {OperatorFunction} [operator] - operator to apply to the `Observable` or `Signal` values\n * @param {DerivedFromOptions} [options] - options to pass initialValue and/or injector to use to inject the `Observable` or `Signal` values\n * @returns {Signal} - `Signal` that emits the values of the `Observable` or `Signal` values\n *\n * @example\n *\n * ```ts\n * export class MyComponent {\n *  private readonly filtersService = inject(FiltersService);\n *  readonly pageNumber = signal(1);\n *\n *  readonly data = derivedFrom(\n *   [this.pageNumber, this.filtersService.filters$],\n *   pipe(\n *     switchMap(([pageNumber, filters]) => this.dataService.getData(pageNumber, filters)),\n *     startWith([])\n *   );\n * }\n * ```\n */\nexport function derivedFrom<Input = any, Output = Input>(\n\t...args: any[]\n): Signal<Output> {\n\tconst { normalizedSources, hasInitValue, operator, options } = _normalizeArgs<\n\t\tInput,\n\t\tOutput\n\t>(args);\n\n\tconst injector = assertInjector(derivedFrom, options?.injector);\n\t/* try { // Custom error handling for derivedFrom */\n\tconst ret: Signal<Output> = hasInitValue\n\t\t? toSignal(combineLatest(normalizedSources).pipe(operator), {\n\t\t\t\tinitialValue: options!.initialValue!,\n\t\t\t\tinjector,\n\t\t\t})\n\t\t: toSignal(combineLatest(normalizedSources).pipe(operator), {\n\t\t\t\tinjector,\n\t\t\t\trequireSync: true,\n\t\t\t});\n\treturn ret;\n}\n\nfunction _normalizeArgs<Input, Output>(\n\targs: any[],\n): {\n\tnormalizedSources: ObservableInputTuple<Input>;\n\toperator: OperatorFunction<Input, Output>;\n\thasInitValue: boolean;\n\toptions: DerivedFromOptions<Output> | undefined;\n} {\n\tif (!args || !args.length || typeof args[0] !== 'object')\n\t\t//valid even for Array\n\t\tthrow new TypeError('derivedFrom needs sources');\n\tconst hasOperator = typeof args[1] === 'function';\n\tif (args.length == 3 && !hasOperator)\n\t\tthrow new TypeError(\n\t\t\t'derivedFrom needs pipeable operator as a second argument',\n\t\t);\n\tif (!hasOperator) args.splice(1, 0, identity);\n\tconst [sources, operator, options] = args;\n\tconst hasInitValue = options?.initialValue !== undefined;\n\tconst normalizedSources = Object.entries(sources).reduce(\n\t\t(acc, [keyOrIndex, source]) => {\n\t\t\tif (isSignal(source)) {\n\t\t\t\tacc[keyOrIndex] = toObservable(source, {\n\t\t\t\t\tinjector: options?.injector,\n\t\t\t\t}).pipe(\n\t\t\t\t\tstartWith(\n\t\t\t\t\t\tuntracked(source),\n\t\t\t\t\t) /* this is done because toObservable doesn't immediatly emit initialValue of the signal */,\n\t\t\t\t);\n\t\t\t} else if (isObservable(source)) {\n\t\t\t\tacc[keyOrIndex] = source.pipe(distinctUntilChanged());\n\t\t\t} else if (typeof source === 'function') {\n\t\t\t\tconst computedFn = computed(source as () => unknown);\n\t\t\t\tacc[keyOrIndex] = toObservable(computedFn, {\n\t\t\t\t\tinjector: options?.injector,\n\t\t\t\t}).pipe(startWith(source() as any));\n\t\t\t} else {\n\t\t\t\tacc[keyOrIndex] = from(source as any).pipe(distinctUntilChanged());\n\t\t\t}\n\t\t\treturn acc;\n\t\t},\n\t\t(Array.isArray(sources) ? [] : {}) as any,\n\t);\n\treturn { normalizedSources, operator, hasInitValue, options };\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}