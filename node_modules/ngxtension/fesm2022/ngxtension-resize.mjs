import { DOCUMENT } from '@angular/common';
import * as i0 from '@angular/core';
import { inject, ElementRef, NgZone, EventEmitter, DestroyRef, Directive, Input, Output } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { createInjectionToken } from 'ngxtension/create-injection-token';
import { ReplaySubject, pipe, debounceTime, takeUntil, Observable, fromEvent, share } from 'rxjs';

const defaultResizeOptions = {
    box: 'content-box',
    scroll: false,
    offsetSize: false,
    debounce: { scroll: 50, resize: 0 },
    emitInZone: true,
    emitInitialResult: false,
};
const [injectResizeOptions, provideResizeOptions, NGX_RESIZE_OPTIONS] = createInjectionToken(() => defaultResizeOptions);
/**
 * `injectResize` returns an `Observable<ResizeResult>` that observes the `resize` event on the Host element
 * of the component. `options` passed in is merged with default options
 *
 * @see {@link defaultResizeOptions}
 *
 * @param {Partial<ResizeOptions>} [options={}]
 * @see {@link ResizeOptions}
 *
 * @returns {Observable<ResizeResult>}
 * @see {@link ResizeResult}
 */
function injectResize(options = {}) {
    const [{ nativeElement }, zone, document] = [
        inject(ElementRef),
        inject(NgZone),
        inject(DOCUMENT),
    ];
    const mergedOptions = { ...injectResizeOptions(), ...options };
    return createResizeStream(mergedOptions, nativeElement, document, zone);
}
/**
 * A directive to be used on any element instead of the Host element. For Host element, there are 3 approaches:
 * - use {@link injectResize}
 * - use `hostDirectives`  with `HostListener` on `ngxResize`
 *
 * @param {Partial<ResizeOptions>} - partial options to control `Resize` behavior. merged with default options
 * @see {@link defaultResizeOptions}
 *
 * @returns {ResizeResult} - as an Output `(ngxResize)`
 */
class NgxResize {
    constructor() {
        this.ngxResizeOptions = {};
        this.ngxResize = new EventEmitter();
        this.host = inject(ElementRef);
        this.zone = inject(NgZone);
        this.document = inject(DOCUMENT);
        this.resizeOptions = injectResizeOptions();
        this.destroyRef = inject(DestroyRef);
    }
    ngOnInit() {
        const mergedOptions = { ...this.resizeOptions, ...this.ngxResizeOptions };
        createResizeStream(mergedOptions, this.host.nativeElement, this.document, this.zone)
            .pipe(takeUntilDestroyed(this.destroyRef))
            .subscribe(this.ngxResize);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxResize, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.3", type: NgxResize, isStandalone: true, selector: "[ngxResize]", inputs: { ngxResizeOptions: "ngxResizeOptions" }, outputs: { ngxResize: "ngxResize" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxResize, decorators: [{
            type: Directive,
            args: [{ selector: '[ngxResize]', standalone: true }]
        }], propDecorators: { ngxResizeOptions: [{
                type: Input
            }], ngxResize: [{
                type: Output
            }] } });
// return ResizeResult observable
function createResizeStream({ debounce, scroll, offsetSize, box, emitInZone, emitInitialResult, }, nativeElement, document, zone) {
    const window = document.defaultView;
    const isSupport = !!window?.ResizeObserver;
    let observer;
    let lastBounds;
    let lastEntries = [];
    const torndown$ = new ReplaySubject();
    const scrollContainers = findScrollContainers(nativeElement, window, document.body);
    // set actual debounce values early, so effects know if they should react accordingly
    const scrollDebounce = debounce
        ? typeof debounce === 'number'
            ? debounce
            : debounce.scroll
        : null;
    const resizeDebounce = debounce
        ? typeof debounce === 'number'
            ? debounce
            : debounce.resize
        : null;
    const debounceAndTorndown = (debounce) => {
        return pipe(debounceTime(debounce ?? 0), takeUntil(torndown$));
    };
    return new Observable((subscriber) => {
        if (!isSupport) {
            subscriber.error('[ngx-resize] your browser does not support ResizeObserver. Please consider using a polyfill');
            return;
        }
        zone.runOutsideAngular(() => {
            if (emitInitialResult) {
                const [result] = calculateResult(nativeElement, window, offsetSize, []);
                if (emitInZone)
                    zone.run(() => void subscriber.next(result));
                else
                    subscriber.next(result);
            }
            const callback = (entries) => {
                lastEntries = entries;
                const [result, size] = calculateResult(nativeElement, window, offsetSize, entries);
                if (emitInZone)
                    zone.run(() => void subscriber.next(result));
                else
                    subscriber.next(result);
                if (!areBoundsEqual(lastBounds || {}, size))
                    lastBounds = size;
            };
            const boundCallback = () => void callback(lastEntries);
            observer = new ResizeObserver(callback);
            observer.observe(nativeElement, { box });
            if (scroll) {
                if (scrollContainers) {
                    scrollContainers.forEach((scrollContainer) => {
                        fromEvent(scrollContainer, 'scroll', {
                            capture: true,
                            passive: true,
                        })
                            .pipe(debounceAndTorndown(scrollDebounce))
                            .subscribe(boundCallback);
                    });
                }
                fromEvent(window, 'scroll', { capture: true, passive: true })
                    .pipe(debounceAndTorndown(scrollDebounce))
                    .subscribe(boundCallback);
            }
            fromEvent(window, 'resize')
                .pipe(debounceAndTorndown(resizeDebounce))
                .subscribe(boundCallback);
        });
        return () => {
            if (observer) {
                observer.unobserve(nativeElement);
                observer.disconnect();
            }
            torndown$.next();
            torndown$.complete();
        };
    }).pipe(debounceTime(scrollDebounce ?? 0), share({ connector: () => new ReplaySubject(1) }));
}
function calculateResult(nativeElement, window, offsetSize, entries) {
    const { left, top, width, height, bottom, right, x, y } = nativeElement.getBoundingClientRect();
    const size = { left, top, width, height, bottom, right, x, y };
    if (nativeElement instanceof HTMLElement && offsetSize) {
        size.height = nativeElement.offsetHeight;
        size.width = nativeElement.offsetWidth;
    }
    Object.freeze(size);
    return [{ entries, dpr: window.devicePixelRatio, ...size }, size];
}
// Returns a list of scroll offsets
function findScrollContainers(element, window, documentBody) {
    const result = [];
    if (!element || !window || element === documentBody)
        return result;
    const { overflow, overflowX, overflowY } = window.getComputedStyle(element);
    if ([overflow, overflowX, overflowY].some((prop) => prop === 'auto' || prop === 'scroll'))
        result.push(element);
    return [
        ...result,
        ...findScrollContainers(element.parentElement, window, documentBody),
    ];
}
// Checks if element boundaries are equal
const keys = [
    'x',
    'y',
    'top',
    'bottom',
    'left',
    'right',
    'width',
    'height',
];
const areBoundsEqual = (a, b) => keys.every((key) => a[key] === b[key]);

/**
 * Generated bundle index. Do not edit.
 */

export { NGX_RESIZE_OPTIONS, NgxResize, defaultResizeOptions, injectResize, injectResizeOptions, provideResizeOptions };
//# sourceMappingURL=ngxtension-resize.mjs.map
