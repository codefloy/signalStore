import { isSignal, untracked } from '@angular/core';
import { toObservable, toSignal } from '@angular/core/rxjs-interop';
import { assertInjector } from 'ngxtension/assert-injector';
import { identity, startWith, isObservable, from, distinctUntilChanged, merge } from 'rxjs';

function mergeFrom(...args) {
    const [sources, operator = identity, options = {}] = parseArgs(args);
    const normalizedSources = sources.map((source) => {
        if (isSignal(source)) {
            return toObservable(source, { injector: options.injector }).pipe(startWith(untracked(source)));
        }
        if (!isObservable(source)) {
            source = from(source);
        }
        return source.pipe(distinctUntilChanged());
    });
    const merged = merge(...normalizedSources).pipe(operator);
    return assertInjector(mergeFrom, options.injector, () => {
        if (options.initialValue !== undefined) {
            return toSignal(merged, { initialValue: options.initialValue });
        }
        return toSignal(merged, { requireSync: true });
    });
}
function parseArgs(args) {
    if (args.length === 0) {
        throw new Error(`[ngxtension] mergeFrom: Expected at least one argument, got none.`);
    }
    if (args.length === 1) {
        return [
            args[0],
            undefined,
            undefined,
        ];
    }
    if (args.length === 2) {
        const isOperator = typeof args[1] === 'function';
        if (isOperator) {
            return [
                args[0],
                args[1],
                undefined,
            ];
        }
        return [
            args[0],
            undefined,
            args[1],
        ];
    }
    return args;
}

/**
 * Generated bundle index. Do not edit.
 */

export { mergeFrom };
//# sourceMappingURL=ngxtension-merge-from.mjs.map
