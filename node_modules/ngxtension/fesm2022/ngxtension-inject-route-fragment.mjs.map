{"version":3,"file":"ngxtension-inject-route-fragment.mjs","sources":["../../../../libs/ngxtension/inject-route-fragment/src/inject-route-fragment.ts","../../../../libs/ngxtension/inject-route-fragment/src/ngxtension-inject-route-fragment.ts"],"sourcesContent":["import { inject, type Injector, type Signal } from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport { ActivatedRoute } from '@angular/router';\nimport { assertInjector } from 'ngxtension/assert-injector';\nimport { map } from 'rxjs';\n\nexport interface InjectRouteFragmentOptions<T = unknown> {\n\t/**\n\t * A transformation function.\n\t *\n\t * @param fragment - The fragment value to transform.\n\t * @returns The transformed value.\n\t */\n\ttransform?: (fragment: string | null) => T;\n\n\t/**\n\t * The optional \"custom\" Injector. If this is not provided, will be retrieved from the current injection context\n\t */\n\tinjector?: Injector;\n}\n\n/**\n * The `injectRouteFragment` function allows you to access and transform url fragment from the current route.\n *\n * @returns {Signal} A `Signal` that emits the route fragment.\n */\nexport function injectRouteFragment(): Signal<string | null>;\n\n/**\n * The `injectRouteFragment` function allows you to access and transform url fragment from the current route.\n *\n * @param {InjectRouteFragmentOptions} options - inject options like transform fn.\n * @returns {Signal} A `Signal` that emits the transformed value of url fragment.\n */\nexport function injectRouteFragment<T>(\n\toptions: InjectRouteFragmentOptions<T>,\n): Signal<T>;\n\nexport function injectRouteFragment<T>(\n\toptions?: InjectRouteFragmentOptions<T>,\n) {\n\treturn assertInjector(injectRouteFragment, options?.injector, () => {\n\t\tconst route = inject(ActivatedRoute);\n\t\tconst initialRouteFragment = route.snapshot.fragment;\n\t\tconst getFragment = (fragment: string | null) => {\n\t\t\tif (options?.transform) return options.transform(fragment);\n\t\t\treturn fragment;\n\t\t};\n\t\tconst fragment$ = route.fragment.pipe(map(getFragment));\n\n\t\treturn toSignal(fragment$, {\n\t\t\tinitialValue: getFragment(initialRouteFragment),\n\t\t});\n\t});\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;;;;;AAsCM,SAAU,mBAAmB,CAClC,OAAuC,EAAA;IAEvC,OAAO,cAAc,CAAC,mBAAmB,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAK;AAClE,QAAA,MAAM,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;AACrC,QAAA,MAAM,oBAAoB,GAAG,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;AACrD,QAAA,MAAM,WAAW,GAAG,CAAC,QAAuB,KAAI;YAC/C,IAAI,OAAO,EAAE,SAAS;AAAE,gBAAA,OAAO,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;AAC3D,YAAA,OAAO,QAAQ,CAAC;AACjB,SAAC,CAAC;AACF,QAAA,MAAM,SAAS,GAAG,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC;QAExD,OAAO,QAAQ,CAAC,SAAS,EAAE;AAC1B,YAAA,YAAY,EAAE,WAAW,CAAC,oBAAoB,CAAC;AAC/C,SAAA,CAAC,CAAC;AACJ,KAAC,CAAC,CAAC;AACJ;;ACtDA;;AAEG;;;;"}