import { Injector, type Signal } from '@angular/core';
import { type ObservableInput, type OperatorFunction } from 'rxjs';
export type ObservableSignalInput<T> = ObservableInput<T> | Signal<T>;
export type DerivedFromOptions<T> = {
    readonly injector?: Injector;
    readonly initialValue?: T | null;
};
export type InferObservableSignalOutput<I> = {
    [K in keyof I]: I[K] extends Signal<infer S> ? S : I[K] extends ObservableInput<infer O> ? O : never;
};
/**
 * So that we can have `fn([Observable<A>, Signal<B>]): Observable<[A, B]>`
 */
type ObservableSignalInputTuple<T> = {
    [K in keyof T]: ObservableSignalInput<T[K]> | (() => T[K]);
};
export declare function derivedFrom<Input extends readonly unknown[], Output = Input>(sources: readonly [...ObservableSignalInputTuple<Input>], operator?: OperatorFunction<Input, Output>, options?: DerivedFromOptions<Output>): Signal<Output>;
export declare function derivedFrom<Input extends readonly unknown[], Output = Input>(sources: readonly [...ObservableSignalInputTuple<Input>], options?: DerivedFromOptions<Input>): Signal<Output>;
export declare function derivedFrom<Input extends object, Output = Input>(sources: ObservableSignalInputTuple<Input>, operator?: OperatorFunction<Input, Output>, options?: DerivedFromOptions<Output>): Signal<Output>;
export declare function derivedFrom<Input extends object, Output = Input>(sources: ObservableSignalInputTuple<Input>, options?: DerivedFromOptions<Input>): Signal<Output>;
export {};
