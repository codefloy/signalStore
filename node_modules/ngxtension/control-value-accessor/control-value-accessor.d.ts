import { Injector, type OnInit } from '@angular/core';
import { type ControlValueAccessor } from '@angular/forms';
import * as i0 from "@angular/core";
/** @see {@link NgxControlValueAccessor.compareTo}. */
export type NgxControlValueAccessorCompareTo<T = any> = (a?: T, b?: T) => boolean;
export declare const injectCvaCompareTo: {
    (): NgxControlValueAccessorCompareTo<any>;
    (injectOptions: import("@angular/core").InjectOptions & {
        optional?: false | undefined;
    } & {
        injector?: Injector | undefined;
    }): NgxControlValueAccessorCompareTo<any>;
    (injectOptions: import("@angular/core").InjectOptions & {
        injector?: Injector | undefined;
    }): NgxControlValueAccessorCompareTo<any> | null;
}, provideCvaCompareTo: (() => import("@angular/core").Provider) & ((value: NgxControlValueAccessorCompareTo<any> | (() => NgxControlValueAccessorCompareTo<any>), isFunctionValue: boolean) => import("@angular/core").Provider);
export declare const injectCvaDefaultValue: {
    (): any;
    (injectOptions: import("@angular/core").InjectOptions & {
        optional?: false | undefined;
    } & {
        injector?: Injector | undefined;
    }): any;
    (injectOptions: import("@angular/core").InjectOptions & {
        injector?: Injector | undefined;
    }): any;
}, provideCvaDefaultValue: (() => import("@angular/core").Provider) & (((value: any, isFunctionValue: boolean) => import("@angular/core").Provider) | ((value: any) => import("@angular/core").Provider));
/**
 * Provides a {@link NgxControlValueAccessorCompareTo comparator} based on a property of `T`.
 *
 * @example
 * ```ts
 * interface User {
 * 	id: string;
 * 	name: string;
 * }
 *
 * provideCvaCompareToByProp<User>('id');
 * ```
 */
export declare const provideCvaCompareToByProp: <T>(prop: keyof T) => import("@angular/core").Provider;
/**
 * `NgxControlValueAccessor` is a directive to reduce boilerplate when building components, which implement the [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor) interface.
 *
 * ## Usage
 *
 * `NgxControlValueAccessor` implements the [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor) interface and exposes a _simpler_ api. Declare `NgxControlValueAccessor` in the `hostDirectives` section of your component and inject the instance in order to wire up your template:
 *
 * - `NgxControlValueAccessor.value` for syncing the value
 * - `NgxControlValueAccessor.disabled` for syncing the disabled state
 * - `NgxControlValueAccessor.markAsTouched` for marking the view as _touched_
 *
 * The value and disabled state are also available as signals:
 *
 * - `NgxControlValueAccessor.value$`
 * - `NgxControlValueAccessor.disabled$`
 *
 * ### Example
 *
 * In this example `NgxControlValueAccessor` is used to create a `CustomInput` component.
 *
 * ```ts
 * @Component({
 *   selector: 'custom-input',
 *   hostDirectives: [NgxControlValueAccessor],
 *   template: `
 *     <label>
 *       <b>Custom label</b>
 *       <input
 *         type="text"
 *         (input)="cva.value = $event.target.value"
 *         [value]="cva.value$()"
 *         [disabled]="cva.disabled$()"
 *         (blur)="cva.markAsTouched()"
 *       />
 *     </label>
 *   `,
 *   standalone: true,
 * })
 * export class CustomInput {
 *   protected cva = inject<NgxControlValueAccessor<string>>(
 *     NgxControlValueAccessor,
 *   );
 * }
 * ```
 *
 * With usage:
 *
 * ```html
 * <custom-input [formControl]="control" />
 * <custom-input [(ngModel)]="value" />
 * ```
 *
 * ## Non Primitive Values
 *
 * When your model is a non primitive datatype, you should provide a _comparator_. It is a pure function which tells `NgxControlValueAccessor`, whether two values are _semantically_ equal:
 *
 * ```ts
 * (a, b) => boolean;
 * ```
 *
 * ### Example
 *
 * In this example `NgxControlValueAccessor` is used to create a `User` select. A `User` is identified by its `id`.
 *
 * ```ts
 * interface User {
 *   id: string;
 *   name: string;
 * }
 *
 * const userComparator: NgxControlValueAccessorCompareTo<User> = (a, b) =>
 *   a?.id === b?.id;
 *
 * provideCvaCompareTo(userComparator, true);
 *
 * // or
 *
 * provideCvaCompareToByProp<User>('id');
 * ```
 *
 * Full example:
 *
 * ```ts
 * @Component({
 *   selector: 'user-select',
 *   standalone: true,
 *   hostDirectives: [NgxControlValueAccessor],
 *   providers: [provideCvaCompareToByProp<User>('id')],
 *   template: `
 *     <label>
 *       <b>Select a user:</b>
 *       <select
 *         [disabled]="cva.disabled$()"
 *         (blur)="cva.markAsTouched()"
 *         (change)="onChange($event)"
 *       >
 *         <option [selected]="cva.value === null">-- no user selected --</option>
 *         @for (user of users; track user.id) {
 *           <option [value]="user.id" [selected]="user.id === cva.value?.id">
 *             {{ user.name }}
 *           </option>
 *         }
 *       </select>
 *     </label>
 *   `,
 * })
 * export class UserSelect {
 *   protected cva = inject<NgxControlValueAccessor<User | null>>(
 *     NgxControlValueAccessor,
 *   );
 *
 *   protected onChange = (event: Event) =>
 *     (this.cva.value =
 *       this.users.find(({ id }) => event.target.value === id) ?? null);
 *
 *   @Input()
 *   users: User[] = [];
 * }
 * ```
 *
 * With usage:
 *
 * ```html
 * <user-select [formControl]="userControl" [options]="users" />
 * <user-select [(ngModel)]="user" [options]="users" />
 * ```
 *
 * ## Without `NgControl`
 *
 * Optionally you can expose `inputs` and `outputs` in the `hostDirectives` declaration
 * and use it without a `NgControl` directive.
 *
 * ```ts
 * hostDirectives: [
 *   {
 *     directive: NgxControlValueAccessor,
 *     inputs: ['value'],
 *     outputs: ['valueChange'],
 *   },
 * ];
 * ```
 *
 * ```html
 * <custom-input [(value)]="value" />
 * ```
 */
export declare class NgxControlValueAccessor<T = any> implements ControlValueAccessor, OnInit {
    /** @ignore */
    private readonly injector;
    /** @ignore */
    private readonly ngControl;
    /** @ignore */
    constructor();
    /** @ignore */
    private initialValue;
    /** The value of this. If a control is present, it reflects it's value. */
    readonly value$: import("@angular/core").WritableSignal<T>;
    /** Whether this is disabled. If a control is present, it reflects it's disabled state. */
    readonly disabled$: import("@angular/core").WritableSignal<boolean>;
    /**
     * A comparator, which determines value changes. Should return true, if two values are considered semanticly equal.
     *
     * Defaults to {@link Object.is} in order to align with change detection behavior for inputs.
     */
    readonly compareTo$: import("@angular/core").WritableSignal<NgxControlValueAccessorCompareTo<T>>;
    /** @ignore */
    ngOnInit(): void;
    /** The value of this. If a control is present, it reflects it's value. */
    set value(value: T);
    get value(): T;
    /** Whether this is disabled. If a control is present, it reflects it's disabled state. */
    set disabled(disabled: boolean);
    get disabled(): boolean;
    /**
     * A comparator, which determines value changes. Should return true, if two values are considered semanticly equal.
     *
     * Defaults to {@link Object.is} in order to align with change detection behavior for inputs.
     */
    set compareTo(compareTo: NgxControlValueAccessorCompareTo<T>);
    get compareTo(): NgxControlValueAccessorCompareTo<T>;
    /**
     * Emits whenever this {@link NgxControlValueAccessor.value$ value} changes.
     */
    readonly valueChange: import("rxjs").Observable<T>;
    /**
     * This function should be called when this host is considered `touched`.
     *
     * NOTE: Whenever a `blur` event is triggered on this host, this function is called.
     *
     * @see {@link NgxControlValueAccessor.registerOnTouched}
     * @see {@link NgxControlValueAccessor.ngControl}
     */
    markAsTouched: () => void;
    /** This function is set by the forms api, if a control is present. */
    private onChange;
    /** This function is set by the forms api, if a control is present. */
    private onTouched;
    /**
     * `NgModel` sets up the control in `ngOnChanges`. Idk if bug or on purpose, but `writeValue` and `setDisabledState` are called before the inputs are set.
     * {@link https://github.com/angular/angular/blob/main/packages/forms/src/directives/ng_model.ts#L223}
     *
     * @ignore
     */
    private get registered();
    writeValue: (value: T) => void;
    registerOnChange: (onChange: (value: T) => void) => (value: T) => void;
    registerOnTouched: (onTouched: () => void) => () => void;
    setDisabledState: (disabled: boolean) => void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxControlValueAccessor<any>, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgxControlValueAccessor<any>, never, never, { "value": { "alias": "value"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "compareTo": { "alias": "compareTo"; "required": false; }; }, { "valueChange": "valueChange"; }, never, never, true, never>;
    static ngAcceptInputType_disabled: unknown;
}
