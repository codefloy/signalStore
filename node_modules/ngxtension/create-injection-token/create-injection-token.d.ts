import { InjectionToken, type EnvironmentProviders, type Host, type InjectOptions, type Injector, type Optional, type Provider, type Self, type SkipSelf, type Type } from '@angular/core';
type CreateInjectionTokenDep<TTokenType> = Type<TTokenType> | (abstract new (...args: any[]) => TTokenType) | InjectionToken<TTokenType>;
type CreateInjectionTokenDeps<TFactory extends (...args: any[]) => any, TFactoryDeps extends Parameters<TFactory> = Parameters<TFactory>> = {
    [Index in keyof TFactoryDeps]: CreateInjectionTokenDep<TFactoryDeps[Index]> | [
        ...modifiers: Array<Optional | Self | SkipSelf | Host>,
        token: CreateInjectionTokenDep<TFactoryDeps[Index]>
    ];
} & {
    length: TFactoryDeps['length'];
};
export type CreateInjectionTokenOptions<TFactory extends (...args: any[]) => any, TFactoryDeps extends Parameters<TFactory> = Parameters<TFactory>> = (TFactoryDeps[0] extends undefined ? {
    deps?: never;
} : {
    deps: CreateInjectionTokenDeps<TFactory, TFactoryDeps>;
}) & {
    isRoot?: boolean;
    isFunctionValue?: boolean;
    multi?: boolean;
    token?: InjectionToken<ReturnType<TFactory>>;
    extraProviders?: Provider | EnvironmentProviders;
};
type InjectFn<TFactoryReturn> = {
    (): TFactoryReturn;
    (injectOptions: InjectOptions & {
        optional?: false;
    } & {
        injector?: Injector;
    }): TFactoryReturn;
    (injectOptions: InjectOptions & {
        injector?: Injector;
    }): TFactoryReturn | null;
};
type ProvideFn<TNoop extends boolean, TFactoryReturn, TReturn = TFactoryReturn extends Array<infer Item> ? Item : TFactoryReturn> = (TNoop extends true ? (value: TReturn | (() => TReturn)) => Provider : () => Provider) & (TReturn extends Function ? (value: TReturn | (() => TReturn), isFunctionValue: boolean) => Provider : (value: TReturn | (() => TReturn)) => Provider);
export type CreateInjectionTokenReturn<TFactoryReturn, TNoop extends boolean = false> = [
    InjectFn<TFactoryReturn>,
    ProvideFn<TNoop, TFactoryReturn>,
    InjectionToken<TFactoryReturn>,
    () => Provider
];
/**
 * `createInjectionToken` accepts a factory function and returns a tuple of `injectFn`, `provideFn`, and the `InjectionToken`
 * that the factory function is for.
 *
 * @param {Function} factory - Factory Function that returns the value for the `InjectionToken`
 * @param {CreateInjectionTokenOptions} options - object to control how the `InjectionToken` behaves
 * @returns {CreateInjectionTokenReturn}
 *
 * @example
 * ```ts
 * const [injectCounter, provideCounter, COUNTER] = createInjectionToken(() => signal(0));
 *
 * export class Counter {
 *  counter = injectCounter(); // WritableSignal<number>
 * }
 * ```
 */
export declare function createInjectionToken<TFactory extends (...args: any[]) => any, TFactoryDeps extends Parameters<TFactory> = Parameters<TFactory>, TOptions extends CreateInjectionTokenOptions<TFactory, TFactoryDeps> = CreateInjectionTokenOptions<TFactory, TFactoryDeps>, TFactoryReturn = TOptions['multi'] extends true ? Array<ReturnType<TFactory>> : ReturnType<TFactory>>(factory: TFactory, options?: TOptions): CreateInjectionTokenReturn<TFactoryReturn>;
export declare function createNoopInjectionToken<TValue, TMulti extends boolean = false, TOptions = Pick<CreateInjectionTokenOptions<() => void, []>, 'extraProviders'> & (TValue extends (...args: any[]) => any ? {
    isFunctionValue: true;
} : {
    isFunctionValue?: never;
}) & (TMulti extends true ? {
    multi: true;
} : {
    multi?: never;
})>(description: string, options?: TOptions): CreateInjectionTokenReturn<TMulti extends true ? TValue[] : TValue, true>;
export {};
