import { computed, isSignal, untracked, } from '@angular/core';
import { toObservable, toSignal } from '@angular/core/rxjs-interop';
import { assertInjector } from 'ngxtension/assert-injector';
import { combineLatest, distinctUntilChanged, from, identity, isObservable, startWith, } from 'rxjs';
/**
 * `derivedFrom` is a function that takes an array/object with `Observable` or `Signal` values and returns a `Signal` that
 * emits the values of the `Observable` or `Signal` values. It is similar to `combineLatest` but it will emit
 * when the value of the `Observable` or `Signal` changes.
 *
 * @param {ObservableSignalInputTuple} sources - array/object of `Observable` or `Signal` values
 * @param {OperatorFunction} [operator] - operator to apply to the `Observable` or `Signal` values
 * @param {DerivedFromOptions} [options] - options to pass initialValue and/or injector to use to inject the `Observable` or `Signal` values
 * @returns {Signal} - `Signal` that emits the values of the `Observable` or `Signal` values
 *
 * @example
 *
 * ```ts
 * export class MyComponent {
 *  private readonly filtersService = inject(FiltersService);
 *  readonly pageNumber = signal(1);
 *
 *  readonly data = derivedFrom(
 *   [this.pageNumber, this.filtersService.filters$],
 *   pipe(
 *     switchMap(([pageNumber, filters]) => this.dataService.getData(pageNumber, filters)),
 *     startWith([])
 *   );
 * }
 * ```
 */
export function derivedFrom(...args) {
    const { normalizedSources, hasInitValue, operator, options } = _normalizeArgs(args);
    const injector = assertInjector(derivedFrom, options?.injector);
    /* try { // Custom error handling for derivedFrom */
    const ret = hasInitValue
        ? toSignal(combineLatest(normalizedSources).pipe(operator), {
            initialValue: options.initialValue,
            injector,
        })
        : toSignal(combineLatest(normalizedSources).pipe(operator), {
            injector,
            requireSync: true,
        });
    return ret;
}
function _normalizeArgs(args) {
    if (!args || !args.length || typeof args[0] !== 'object')
        //valid even for Array
        throw new TypeError('derivedFrom needs sources');
    const hasOperator = typeof args[1] === 'function';
    if (args.length == 3 && !hasOperator)
        throw new TypeError('derivedFrom needs pipeable operator as a second argument');
    if (!hasOperator)
        args.splice(1, 0, identity);
    const [sources, operator, options] = args;
    const hasInitValue = options?.initialValue !== undefined;
    const normalizedSources = Object.entries(sources).reduce((acc, [keyOrIndex, source]) => {
        if (isSignal(source)) {
            acc[keyOrIndex] = toObservable(source, {
                injector: options?.injector,
            }).pipe(startWith(untracked(source)) /* this is done because toObservable doesn't immediatly emit initialValue of the signal */);
        }
        else if (isObservable(source)) {
            acc[keyOrIndex] = source.pipe(distinctUntilChanged());
        }
        else if (typeof source === 'function') {
            const computedFn = computed(source);
            acc[keyOrIndex] = toObservable(computedFn, {
                injector: options?.injector,
            }).pipe(startWith(source()));
        }
        else {
            acc[keyOrIndex] = from(source).pipe(distinctUntilChanged());
        }
        return acc;
    }, (Array.isArray(sources) ? [] : {}));
    return { normalizedSources, operator, hasInitValue, options };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVyaXZlZC1mcm9tLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGlicy9uZ3h0ZW5zaW9uL2Rlcml2ZWQtZnJvbS9zcmMvZGVyaXZlZC1mcm9tLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTixRQUFRLEVBQ1IsUUFBUSxFQUNSLFNBQVMsR0FFVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUM1RCxPQUFPLEVBQ04sYUFBYSxFQUNiLG9CQUFvQixFQUNwQixJQUFJLEVBQ0osUUFBUSxFQUNSLFlBQVksRUFDWixTQUFTLEdBSVQsTUFBTSxNQUFNLENBQUM7QUFpRGQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F5Qkc7QUFDSCxNQUFNLFVBQVUsV0FBVyxDQUMxQixHQUFHLElBQVc7SUFFZCxNQUFNLEVBQUUsaUJBQWlCLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsR0FBRyxjQUFjLENBRzNFLElBQUksQ0FBQyxDQUFDO0lBRVIsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLFdBQVcsRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDaEUsb0RBQW9EO0lBQ3BELE1BQU0sR0FBRyxHQUFtQixZQUFZO1FBQ3ZDLENBQUMsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzFELFlBQVksRUFBRSxPQUFRLENBQUMsWUFBYTtZQUNwQyxRQUFRO1NBQ1IsQ0FBQztRQUNILENBQUMsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzFELFFBQVE7WUFDUixXQUFXLEVBQUUsSUFBSTtTQUNqQixDQUFDLENBQUM7SUFDTCxPQUFPLEdBQUcsQ0FBQztBQUNaLENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FDdEIsSUFBVztJQU9YLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVE7UUFDdkQsc0JBQXNCO1FBQ3RCLE1BQU0sSUFBSSxTQUFTLENBQUMsMkJBQTJCLENBQUMsQ0FBQztJQUNsRCxNQUFNLFdBQVcsR0FBRyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxVQUFVLENBQUM7SUFDbEQsSUFBSSxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVc7UUFDbkMsTUFBTSxJQUFJLFNBQVMsQ0FDbEIsMERBQTBELENBQzFELENBQUM7SUFDSCxJQUFJLENBQUMsV0FBVztRQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUM5QyxNQUFNLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDMUMsTUFBTSxZQUFZLEdBQUcsT0FBTyxFQUFFLFlBQVksS0FBSyxTQUFTLENBQUM7SUFDekQsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FDdkQsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUM3QixJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1lBQ3RCLEdBQUcsQ0FBQyxVQUFVLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFO2dCQUN0QyxRQUFRLEVBQUUsT0FBTyxFQUFFLFFBQVE7YUFDM0IsQ0FBQyxDQUFDLElBQUksQ0FDTixTQUFTLENBQ1IsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUNqQixDQUFDLDBGQUEwRixDQUM1RixDQUFDO1FBQ0gsQ0FBQzthQUFNLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7WUFDakMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZELENBQUM7YUFBTSxJQUFJLE9BQU8sTUFBTSxLQUFLLFVBQVUsRUFBRSxDQUFDO1lBQ3pDLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxNQUF1QixDQUFDLENBQUM7WUFDckQsR0FBRyxDQUFDLFVBQVUsQ0FBQyxHQUFHLFlBQVksQ0FBQyxVQUFVLEVBQUU7Z0JBQzFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsUUFBUTthQUMzQixDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQVMsQ0FBQyxDQUFDLENBQUM7UUFDckMsQ0FBQzthQUFNLENBQUM7WUFDUCxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLENBQUM7UUFDcEUsQ0FBQztRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ1osQ0FBQyxFQUNELENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQVEsQ0FDekMsQ0FBQztJQUNGLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLE9BQU8sRUFBRSxDQUFDO0FBQy9ELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRJbmplY3Rvcixcblx0Y29tcHV0ZWQsXG5cdGlzU2lnbmFsLFxuXHR1bnRyYWNrZWQsXG5cdHR5cGUgU2lnbmFsLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRvT2JzZXJ2YWJsZSwgdG9TaWduYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlL3J4anMtaW50ZXJvcCc7XG5pbXBvcnQgeyBhc3NlcnRJbmplY3RvciB9IGZyb20gJ25neHRlbnNpb24vYXNzZXJ0LWluamVjdG9yJztcbmltcG9ydCB7XG5cdGNvbWJpbmVMYXRlc3QsXG5cdGRpc3RpbmN0VW50aWxDaGFuZ2VkLFxuXHRmcm9tLFxuXHRpZGVudGl0eSxcblx0aXNPYnNlcnZhYmxlLFxuXHRzdGFydFdpdGgsXG5cdHR5cGUgT2JzZXJ2YWJsZUlucHV0LFxuXHR0eXBlIE9ic2VydmFibGVJbnB1dFR1cGxlLFxuXHR0eXBlIE9wZXJhdG9yRnVuY3Rpb24sXG59IGZyb20gJ3J4anMnO1xuXG5leHBvcnQgdHlwZSBPYnNlcnZhYmxlU2lnbmFsSW5wdXQ8VD4gPSBPYnNlcnZhYmxlSW5wdXQ8VD4gfCBTaWduYWw8VD47XG5leHBvcnQgdHlwZSBEZXJpdmVkRnJvbU9wdGlvbnM8VD4gPSB7XG5cdHJlYWRvbmx5IGluamVjdG9yPzogSW5qZWN0b3I7XG5cdHJlYWRvbmx5IGluaXRpYWxWYWx1ZT86IFQgfCBudWxsO1xufTsgLy9QaWNrPFRvU2lnbmFsT3B0aW9uczxUPiwnaW5qZWN0b3InIHwgJ2luaXRpYWxWYWx1ZSc+O1xuZXhwb3J0IHR5cGUgSW5mZXJPYnNlcnZhYmxlU2lnbmFsT3V0cHV0PEk+ID0ge1xuXHRbSyBpbiBrZXlvZiBJXTogSVtLXSBleHRlbmRzIFNpZ25hbDxpbmZlciBTPlxuXHRcdD8gU1xuXHRcdDogSVtLXSBleHRlbmRzIE9ic2VydmFibGVJbnB1dDxpbmZlciBPPlxuXHRcdFx0PyBPXG5cdFx0XHQ6IG5ldmVyO1xufTtcbi8qKlxuICogU28gdGhhdCB3ZSBjYW4gaGF2ZSBgZm4oW09ic2VydmFibGU8QT4sIFNpZ25hbDxCPl0pOiBPYnNlcnZhYmxlPFtBLCBCXT5gXG4gKi9cbnR5cGUgT2JzZXJ2YWJsZVNpZ25hbElucHV0VHVwbGU8VD4gPSB7XG5cdFtLIGluIGtleW9mIFRdOiBPYnNlcnZhYmxlU2lnbmFsSW5wdXQ8VFtLXT4gfCAoKCkgPT4gVFtLXSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZEZyb208SW5wdXQgZXh0ZW5kcyByZWFkb25seSB1bmtub3duW10sIE91dHB1dCA9IElucHV0Pihcblx0c291cmNlczogcmVhZG9ubHkgWy4uLk9ic2VydmFibGVTaWduYWxJbnB1dFR1cGxlPElucHV0Pl0sXG5cdG9wZXJhdG9yPzogT3BlcmF0b3JGdW5jdGlvbjxJbnB1dCwgT3V0cHV0Pixcblx0b3B0aW9ucz86IERlcml2ZWRGcm9tT3B0aW9uczxPdXRwdXQ+LFxuKTogU2lnbmFsPE91dHB1dD47XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkRnJvbTxcblx0SW5wdXQgZXh0ZW5kcyByZWFkb25seSB1bmtub3duW10sXG5cdE91dHB1dCA9IElucHV0LCAvL0luZmVyT2JzZXJ2YWJsZVNpZ25hbE91dHB1dDxJbnB1dD5cbj4oXG5cdHNvdXJjZXM6IHJlYWRvbmx5IFsuLi5PYnNlcnZhYmxlU2lnbmFsSW5wdXRUdXBsZTxJbnB1dD5dLFxuXHRvcHRpb25zPzogRGVyaXZlZEZyb21PcHRpb25zPElucHV0Pixcbik6IFNpZ25hbDxPdXRwdXQ+O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZEZyb208SW5wdXQgZXh0ZW5kcyBvYmplY3QsIE91dHB1dCA9IElucHV0Pihcblx0c291cmNlczogT2JzZXJ2YWJsZVNpZ25hbElucHV0VHVwbGU8SW5wdXQ+LFxuXHRvcGVyYXRvcj86IE9wZXJhdG9yRnVuY3Rpb248SW5wdXQsIE91dHB1dD4sXG5cdG9wdGlvbnM/OiBEZXJpdmVkRnJvbU9wdGlvbnM8T3V0cHV0Pixcbik6IFNpZ25hbDxPdXRwdXQ+O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZEZyb208XG5cdElucHV0IGV4dGVuZHMgb2JqZWN0LFxuXHRPdXRwdXQgPSBJbnB1dCwgLy9JbmZlck9ic2VydmFibGVTaWduYWxPdXRwdXQ8SW5wdXQ+XG4+KFxuXHRzb3VyY2VzOiBPYnNlcnZhYmxlU2lnbmFsSW5wdXRUdXBsZTxJbnB1dD4sXG5cdG9wdGlvbnM/OiBEZXJpdmVkRnJvbU9wdGlvbnM8SW5wdXQ+LFxuKTogU2lnbmFsPE91dHB1dD47XG5cbi8qKlxuICogYGRlcml2ZWRGcm9tYCBpcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gYXJyYXkvb2JqZWN0IHdpdGggYE9ic2VydmFibGVgIG9yIGBTaWduYWxgIHZhbHVlcyBhbmQgcmV0dXJucyBhIGBTaWduYWxgIHRoYXRcbiAqIGVtaXRzIHRoZSB2YWx1ZXMgb2YgdGhlIGBPYnNlcnZhYmxlYCBvciBgU2lnbmFsYCB2YWx1ZXMuIEl0IGlzIHNpbWlsYXIgdG8gYGNvbWJpbmVMYXRlc3RgIGJ1dCBpdCB3aWxsIGVtaXRcbiAqIHdoZW4gdGhlIHZhbHVlIG9mIHRoZSBgT2JzZXJ2YWJsZWAgb3IgYFNpZ25hbGAgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVTaWduYWxJbnB1dFR1cGxlfSBzb3VyY2VzIC0gYXJyYXkvb2JqZWN0IG9mIGBPYnNlcnZhYmxlYCBvciBgU2lnbmFsYCB2YWx1ZXNcbiAqIEBwYXJhbSB7T3BlcmF0b3JGdW5jdGlvbn0gW29wZXJhdG9yXSAtIG9wZXJhdG9yIHRvIGFwcGx5IHRvIHRoZSBgT2JzZXJ2YWJsZWAgb3IgYFNpZ25hbGAgdmFsdWVzXG4gKiBAcGFyYW0ge0Rlcml2ZWRGcm9tT3B0aW9uc30gW29wdGlvbnNdIC0gb3B0aW9ucyB0byBwYXNzIGluaXRpYWxWYWx1ZSBhbmQvb3IgaW5qZWN0b3IgdG8gdXNlIHRvIGluamVjdCB0aGUgYE9ic2VydmFibGVgIG9yIGBTaWduYWxgIHZhbHVlc1xuICogQHJldHVybnMge1NpZ25hbH0gLSBgU2lnbmFsYCB0aGF0IGVtaXRzIHRoZSB2YWx1ZXMgb2YgdGhlIGBPYnNlcnZhYmxlYCBvciBgU2lnbmFsYCB2YWx1ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQge1xuICogIHByaXZhdGUgcmVhZG9ubHkgZmlsdGVyc1NlcnZpY2UgPSBpbmplY3QoRmlsdGVyc1NlcnZpY2UpO1xuICogIHJlYWRvbmx5IHBhZ2VOdW1iZXIgPSBzaWduYWwoMSk7XG4gKlxuICogIHJlYWRvbmx5IGRhdGEgPSBkZXJpdmVkRnJvbShcbiAqICAgW3RoaXMucGFnZU51bWJlciwgdGhpcy5maWx0ZXJzU2VydmljZS5maWx0ZXJzJF0sXG4gKiAgIHBpcGUoXG4gKiAgICAgc3dpdGNoTWFwKChbcGFnZU51bWJlciwgZmlsdGVyc10pID0+IHRoaXMuZGF0YVNlcnZpY2UuZ2V0RGF0YShwYWdlTnVtYmVyLCBmaWx0ZXJzKSksXG4gKiAgICAgc3RhcnRXaXRoKFtdKVxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkRnJvbTxJbnB1dCA9IGFueSwgT3V0cHV0ID0gSW5wdXQ+KFxuXHQuLi5hcmdzOiBhbnlbXVxuKTogU2lnbmFsPE91dHB1dD4ge1xuXHRjb25zdCB7IG5vcm1hbGl6ZWRTb3VyY2VzLCBoYXNJbml0VmFsdWUsIG9wZXJhdG9yLCBvcHRpb25zIH0gPSBfbm9ybWFsaXplQXJnczxcblx0XHRJbnB1dCxcblx0XHRPdXRwdXRcblx0PihhcmdzKTtcblxuXHRjb25zdCBpbmplY3RvciA9IGFzc2VydEluamVjdG9yKGRlcml2ZWRGcm9tLCBvcHRpb25zPy5pbmplY3Rvcik7XG5cdC8qIHRyeSB7IC8vIEN1c3RvbSBlcnJvciBoYW5kbGluZyBmb3IgZGVyaXZlZEZyb20gKi9cblx0Y29uc3QgcmV0OiBTaWduYWw8T3V0cHV0PiA9IGhhc0luaXRWYWx1ZVxuXHRcdD8gdG9TaWduYWwoY29tYmluZUxhdGVzdChub3JtYWxpemVkU291cmNlcykucGlwZShvcGVyYXRvciksIHtcblx0XHRcdFx0aW5pdGlhbFZhbHVlOiBvcHRpb25zIS5pbml0aWFsVmFsdWUhLFxuXHRcdFx0XHRpbmplY3Rvcixcblx0XHRcdH0pXG5cdFx0OiB0b1NpZ25hbChjb21iaW5lTGF0ZXN0KG5vcm1hbGl6ZWRTb3VyY2VzKS5waXBlKG9wZXJhdG9yKSwge1xuXHRcdFx0XHRpbmplY3Rvcixcblx0XHRcdFx0cmVxdWlyZVN5bmM6IHRydWUsXG5cdFx0XHR9KTtcblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gX25vcm1hbGl6ZUFyZ3M8SW5wdXQsIE91dHB1dD4oXG5cdGFyZ3M6IGFueVtdLFxuKToge1xuXHRub3JtYWxpemVkU291cmNlczogT2JzZXJ2YWJsZUlucHV0VHVwbGU8SW5wdXQ+O1xuXHRvcGVyYXRvcjogT3BlcmF0b3JGdW5jdGlvbjxJbnB1dCwgT3V0cHV0Pjtcblx0aGFzSW5pdFZhbHVlOiBib29sZWFuO1xuXHRvcHRpb25zOiBEZXJpdmVkRnJvbU9wdGlvbnM8T3V0cHV0PiB8IHVuZGVmaW5lZDtcbn0ge1xuXHRpZiAoIWFyZ3MgfHwgIWFyZ3MubGVuZ3RoIHx8IHR5cGVvZiBhcmdzWzBdICE9PSAnb2JqZWN0Jylcblx0XHQvL3ZhbGlkIGV2ZW4gZm9yIEFycmF5XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignZGVyaXZlZEZyb20gbmVlZHMgc291cmNlcycpO1xuXHRjb25zdCBoYXNPcGVyYXRvciA9IHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nO1xuXHRpZiAoYXJncy5sZW5ndGggPT0gMyAmJiAhaGFzT3BlcmF0b3IpXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcblx0XHRcdCdkZXJpdmVkRnJvbSBuZWVkcyBwaXBlYWJsZSBvcGVyYXRvciBhcyBhIHNlY29uZCBhcmd1bWVudCcsXG5cdFx0KTtcblx0aWYgKCFoYXNPcGVyYXRvcikgYXJncy5zcGxpY2UoMSwgMCwgaWRlbnRpdHkpO1xuXHRjb25zdCBbc291cmNlcywgb3BlcmF0b3IsIG9wdGlvbnNdID0gYXJncztcblx0Y29uc3QgaGFzSW5pdFZhbHVlID0gb3B0aW9ucz8uaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQ7XG5cdGNvbnN0IG5vcm1hbGl6ZWRTb3VyY2VzID0gT2JqZWN0LmVudHJpZXMoc291cmNlcykucmVkdWNlKFxuXHRcdChhY2MsIFtrZXlPckluZGV4LCBzb3VyY2VdKSA9PiB7XG5cdFx0XHRpZiAoaXNTaWduYWwoc291cmNlKSkge1xuXHRcdFx0XHRhY2Nba2V5T3JJbmRleF0gPSB0b09ic2VydmFibGUoc291cmNlLCB7XG5cdFx0XHRcdFx0aW5qZWN0b3I6IG9wdGlvbnM/LmluamVjdG9yLFxuXHRcdFx0XHR9KS5waXBlKFxuXHRcdFx0XHRcdHN0YXJ0V2l0aChcblx0XHRcdFx0XHRcdHVudHJhY2tlZChzb3VyY2UpLFxuXHRcdFx0XHRcdCkgLyogdGhpcyBpcyBkb25lIGJlY2F1c2UgdG9PYnNlcnZhYmxlIGRvZXNuJ3QgaW1tZWRpYXRseSBlbWl0IGluaXRpYWxWYWx1ZSBvZiB0aGUgc2lnbmFsICovLFxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIGlmIChpc09ic2VydmFibGUoc291cmNlKSkge1xuXHRcdFx0XHRhY2Nba2V5T3JJbmRleF0gPSBzb3VyY2UucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjb25zdCBjb21wdXRlZEZuID0gY29tcHV0ZWQoc291cmNlIGFzICgpID0+IHVua25vd24pO1xuXHRcdFx0XHRhY2Nba2V5T3JJbmRleF0gPSB0b09ic2VydmFibGUoY29tcHV0ZWRGbiwge1xuXHRcdFx0XHRcdGluamVjdG9yOiBvcHRpb25zPy5pbmplY3Rvcixcblx0XHRcdFx0fSkucGlwZShzdGFydFdpdGgoc291cmNlKCkgYXMgYW55KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhY2Nba2V5T3JJbmRleF0gPSBmcm9tKHNvdXJjZSBhcyBhbnkpLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYWNjO1xuXHRcdH0sXG5cdFx0KEFycmF5LmlzQXJyYXkoc291cmNlcykgPyBbXSA6IHt9KSBhcyBhbnksXG5cdCk7XG5cdHJldHVybiB7IG5vcm1hbGl6ZWRTb3VyY2VzLCBvcGVyYXRvciwgaGFzSW5pdFZhbHVlLCBvcHRpb25zIH07XG59XG4iXX0=