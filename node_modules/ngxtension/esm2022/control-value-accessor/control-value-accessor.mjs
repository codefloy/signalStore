import { Directive, Injector, Input, Output, booleanAttribute, inject, runInInjectionContext, signal, } from '@angular/core';
import { toObservable } from '@angular/core/rxjs-interop';
import { NgControl, NgModel } from '@angular/forms';
import { createInjectionToken } from 'ngxtension/create-injection-token';
import { rxEffect } from 'ngxtension/rx-effect';
import { skip } from 'rxjs';
import * as i0 from "@angular/core";
const noop = () => undefined;
export const [injectCvaCompareTo, provideCvaCompareTo] = createInjectionToken(() => Object.is);
export const [injectCvaDefaultValue, provideCvaDefaultValue] = createInjectionToken(() => null);
/**
 * Provides a {@link NgxControlValueAccessorCompareTo comparator} based on a property of `T`.
 *
 * @example
 * ```ts
 * interface User {
 * 	id: string;
 * 	name: string;
 * }
 *
 * provideCvaCompareToByProp<User>('id');
 * ```
 */
export const provideCvaCompareToByProp = (prop) => provideCvaCompareTo((a, b) => Object.is(a?.[prop], b?.[prop]), true);
/**
 * `NgxControlValueAccessor` is a directive to reduce boilerplate when building components, which implement the [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor) interface.
 *
 * ## Usage
 *
 * `NgxControlValueAccessor` implements the [ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor) interface and exposes a _simpler_ api. Declare `NgxControlValueAccessor` in the `hostDirectives` section of your component and inject the instance in order to wire up your template:
 *
 * - `NgxControlValueAccessor.value` for syncing the value
 * - `NgxControlValueAccessor.disabled` for syncing the disabled state
 * - `NgxControlValueAccessor.markAsTouched` for marking the view as _touched_
 *
 * The value and disabled state are also available as signals:
 *
 * - `NgxControlValueAccessor.value$`
 * - `NgxControlValueAccessor.disabled$`
 *
 * ### Example
 *
 * In this example `NgxControlValueAccessor` is used to create a `CustomInput` component.
 *
 * ```ts
 * @Component({
 *   selector: 'custom-input',
 *   hostDirectives: [NgxControlValueAccessor],
 *   template: `
 *     <label>
 *       <b>Custom label</b>
 *       <input
 *         type="text"
 *         (input)="cva.value = $event.target.value"
 *         [value]="cva.value$()"
 *         [disabled]="cva.disabled$()"
 *         (blur)="cva.markAsTouched()"
 *       />
 *     </label>
 *   `,
 *   standalone: true,
 * })
 * export class CustomInput {
 *   protected cva = inject<NgxControlValueAccessor<string>>(
 *     NgxControlValueAccessor,
 *   );
 * }
 * ```
 *
 * With usage:
 *
 * ```html
 * <custom-input [formControl]="control" />
 * <custom-input [(ngModel)]="value" />
 * ```
 *
 * ## Non Primitive Values
 *
 * When your model is a non primitive datatype, you should provide a _comparator_. It is a pure function which tells `NgxControlValueAccessor`, whether two values are _semantically_ equal:
 *
 * ```ts
 * (a, b) => boolean;
 * ```
 *
 * ### Example
 *
 * In this example `NgxControlValueAccessor` is used to create a `User` select. A `User` is identified by its `id`.
 *
 * ```ts
 * interface User {
 *   id: string;
 *   name: string;
 * }
 *
 * const userComparator: NgxControlValueAccessorCompareTo<User> = (a, b) =>
 *   a?.id === b?.id;
 *
 * provideCvaCompareTo(userComparator, true);
 *
 * // or
 *
 * provideCvaCompareToByProp<User>('id');
 * ```
 *
 * Full example:
 *
 * ```ts
 * @Component({
 *   selector: 'user-select',
 *   standalone: true,
 *   hostDirectives: [NgxControlValueAccessor],
 *   providers: [provideCvaCompareToByProp<User>('id')],
 *   template: `
 *     <label>
 *       <b>Select a user:</b>
 *       <select
 *         [disabled]="cva.disabled$()"
 *         (blur)="cva.markAsTouched()"
 *         (change)="onChange($event)"
 *       >
 *         <option [selected]="cva.value === null">-- no user selected --</option>
 *         @for (user of users; track user.id) {
 *           <option [value]="user.id" [selected]="user.id === cva.value?.id">
 *             {{ user.name }}
 *           </option>
 *         }
 *       </select>
 *     </label>
 *   `,
 * })
 * export class UserSelect {
 *   protected cva = inject<NgxControlValueAccessor<User | null>>(
 *     NgxControlValueAccessor,
 *   );
 *
 *   protected onChange = (event: Event) =>
 *     (this.cva.value =
 *       this.users.find(({ id }) => event.target.value === id) ?? null);
 *
 *   @Input()
 *   users: User[] = [];
 * }
 * ```
 *
 * With usage:
 *
 * ```html
 * <user-select [formControl]="userControl" [options]="users" />
 * <user-select [(ngModel)]="user" [options]="users" />
 * ```
 *
 * ## Without `NgControl`
 *
 * Optionally you can expose `inputs` and `outputs` in the `hostDirectives` declaration
 * and use it without a `NgControl` directive.
 *
 * ```ts
 * hostDirectives: [
 *   {
 *     directive: NgxControlValueAccessor,
 *     inputs: ['value'],
 *     outputs: ['valueChange'],
 *   },
 * ];
 * ```
 *
 * ```html
 * <custom-input [(value)]="value" />
 * ```
 */
export class NgxControlValueAccessor {
    /** @ignore */
    constructor() {
        /** @ignore */
        this.injector = inject(Injector);
        /** @ignore */
        this.ngControl = inject(NgControl, {
            self: true,
            optional: true,
        });
        /** @ignore */
        this.initialValue = () => {
            if (this.ngControl != null)
                return this.ngControl.value;
            return injectCvaDefaultValue();
        };
        /** The value of this. If a control is present, it reflects it's value. */
        this.value$ = signal(this.initialValue(), {
            equal: (a, b) => this.compareTo(a, b),
        });
        /** Whether this is disabled. If a control is present, it reflects it's disabled state. */
        this.disabled$ = signal(this.ngControl?.disabled ?? false);
        /**
         * A comparator, which determines value changes. Should return true, if two values are considered semanticly equal.
         *
         * Defaults to {@link Object.is} in order to align with change detection behavior for inputs.
         */
        this.compareTo$ = signal(injectCvaCompareTo());
        /**
         * Emits whenever this {@link NgxControlValueAccessor.value$ value} changes.
         */
        this.valueChange = toObservable(this.value$).pipe(skip(1)); // -> hot observable
        /**
         * This function should be called when this host is considered `touched`.
         *
         * NOTE: Whenever a `blur` event is triggered on this host, this function is called.
         *
         * @see {@link NgxControlValueAccessor.registerOnTouched}
         * @see {@link NgxControlValueAccessor.ngControl}
         */
        this.markAsTouched = () => this.onTouched();
        /** This function is set by the forms api, if a control is present. */
        this.onChange = noop;
        /** This function is set by the forms api, if a control is present. */
        this.onTouched = noop;
        // control value accessor implementation
        this.writeValue = (value) => {
            if (this.registered)
                this.value = value;
        };
        this.registerOnChange = (onChange) => (this.onChange = onChange);
        this.registerOnTouched = (onTouched) => (this.onTouched = onTouched);
        this.setDisabledState = (disabled) => {
            if (this.registered)
                this.disabled$.set(disabled);
        };
        if (this.ngControl != null)
            this.ngControl.valueAccessor = this;
    }
    /** @ignore */
    ngOnInit() {
        if (this.ngControl != null) {
            runInInjectionContext(this.injector, () => {
                // NOTE: Don't use 'effect' because we have no idea if we are setting other signals here.
                // sync value
                rxEffect(toObservable(this.value$), (value) => {
                    if (!this.compareTo(this.ngControl?.value, value))
                        this.onChange(value);
                });
                // sync disabled state
                rxEffect(toObservable(this.disabled$), (disabled) => {
                    if (this.ngControl != null &&
                        this.ngControl.control != null &&
                        this.ngControl.disabled !== disabled)
                        this.ngControl.control[disabled ? 'disable' : 'enable']();
                });
            });
        }
    }
    /** The value of this. If a control is present, it reflects it's value. */
    set value(value) {
        this.value$.set(value);
    }
    get value() {
        return this.value$();
    }
    /** Whether this is disabled. If a control is present, it reflects it's disabled state. */
    set disabled(disabled) {
        this.disabled$.set(disabled);
    }
    get disabled() {
        return this.disabled$();
    }
    /**
     * A comparator, which determines value changes. Should return true, if two values are considered semanticly equal.
     *
     * Defaults to {@link Object.is} in order to align with change detection behavior for inputs.
     */
    set compareTo(compareTo) {
        if (typeof compareTo === 'function')
            this.compareTo$.set(compareTo);
    }
    get compareTo() {
        return this.compareTo$();
    }
    /**
     * `NgModel` sets up the control in `ngOnChanges`. Idk if bug or on purpose, but `writeValue` and `setDisabledState` are called before the inputs are set.
     * {@link https://github.com/angular/angular/blob/main/packages/forms/src/directives/ng_model.ts#L223}
     *
     * @ignore
     */
    get registered() {
        return this.ngControl instanceof NgModel
            ? this.ngControl._registered
            : true;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxControlValueAccessor, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "18.0.3", type: NgxControlValueAccessor, isStandalone: true, inputs: { value: "value", disabled: ["disabled", "disabled", booleanAttribute], compareTo: "compareTo" }, outputs: { valueChange: "valueChange" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxControlValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                }]
        }], ctorParameters: () => [], propDecorators: { value: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], compareTo: [{
                type: Input
            }], valueChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbC12YWx1ZS1hY2Nlc3Nvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvbmd4dGVuc2lvbi9jb250cm9sLXZhbHVlLWFjY2Vzc29yL3NyYy9jb250cm9sLXZhbHVlLWFjY2Vzc29yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTixTQUFTLEVBQ1QsUUFBUSxFQUNSLEtBQUssRUFDTCxNQUFNLEVBQ04sZ0JBQWdCLEVBQ2hCLE1BQU0sRUFDTixxQkFBcUIsRUFDckIsTUFBTSxHQUVOLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBNkIsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN6RSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDaEQsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLE1BQU0sQ0FBQzs7QUFFNUIsTUFBTSxJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDO0FBUTdCLE1BQU0sQ0FBQyxNQUFNLENBQUMsa0JBQWtCLEVBQUUsbUJBQW1CLENBQUMsR0FBRyxvQkFBb0IsQ0FFM0UsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBRW5CLE1BQU0sQ0FBQyxNQUFNLENBQUMscUJBQXFCLEVBQUUsc0JBQXNCLENBQUMsR0FDM0Qsb0JBQW9CLENBQVksR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7QUFFN0M7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsTUFBTSxDQUFDLE1BQU0seUJBQXlCLEdBQUcsQ0FBSSxJQUFhLEVBQUUsRUFBRSxDQUM3RCxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFB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QVcsUUFBUTtRQUNsQixPQUFPLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQ1csU0FBUyxDQUFDLFNBQVM7UUFDN0IsSUFBSSxPQUFPLFNBQVMsS0FBSyxVQUFVO1lBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDckUsQ0FBQztJQUVELElBQVcsU0FBUztRQUNuQixPQUFPLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUMxQixDQUFDO0lBd0JEOzs7OztPQUtHO0lBQ0gsSUFBWSxVQUFVO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLFNBQVMsWUFBWSxPQUFPO1lBQ3ZDLENBQUMsQ0FBRSxJQUFJLENBQUMsU0FBaUQsQ0FBQyxXQUFXO1lBQ3JFLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDVCxDQUFDOzhHQWxJVyx1QkFBdUI7a0dBQXZCLHVCQUF1QixtRkEyRWYsZ0JBQWdCOzsyRkEzRXhCLHVCQUF1QjtrQkFIbkMsU0FBUzttQkFBQztvQkFDVixVQUFVLEVBQUUsSUFBSTtpQkFDaEI7d0RBbUVXLEtBQUs7c0JBRGYsS0FBSztnQkFXSyxRQUFRO3NCQURsQixLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFO2dCQWUzQixTQUFTO3NCQURuQixLQUFLO2dCQWFVLFdBQVc7c0JBRDFCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHREaXJlY3RpdmUsXG5cdEluamVjdG9yLFxuXHRJbnB1dCxcblx0T3V0cHV0LFxuXHRib29sZWFuQXR0cmlidXRlLFxuXHRpbmplY3QsXG5cdHJ1bkluSW5qZWN0aW9uQ29udGV4dCxcblx0c2lnbmFsLFxuXHR0eXBlIE9uSW5pdCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0b09ic2VydmFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlL3J4anMtaW50ZXJvcCc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wsIE5nTW9kZWwsIHR5cGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBjcmVhdGVJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ25neHRlbnNpb24vY3JlYXRlLWluamVjdGlvbi10b2tlbic7XG5pbXBvcnQgeyByeEVmZmVjdCB9IGZyb20gJ25neHRlbnNpb24vcngtZWZmZWN0JztcbmltcG9ydCB7IHNraXAgfSBmcm9tICdyeGpzJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHVuZGVmaW5lZDtcblxuLyoqIEBzZWUge0BsaW5rIE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yLmNvbXBhcmVUb30uICovXG5leHBvcnQgdHlwZSBOZ3hDb250cm9sVmFsdWVBY2Nlc3NvckNvbXBhcmVUbzxUID0gYW55PiA9IChcblx0YT86IFQsXG5cdGI/OiBULFxuKSA9PiBib29sZWFuO1xuXG5leHBvcnQgY29uc3QgW2luamVjdEN2YUNvbXBhcmVUbywgcHJvdmlkZUN2YUNvbXBhcmVUb10gPSBjcmVhdGVJbmplY3Rpb25Ub2tlbjxcblx0KCkgPT4gTmd4Q29udHJvbFZhbHVlQWNjZXNzb3JDb21wYXJlVG9cbj4oKCkgPT4gT2JqZWN0LmlzKTtcblxuZXhwb3J0IGNvbnN0IFtpbmplY3RDdmFEZWZhdWx0VmFsdWUsIHByb3ZpZGVDdmFEZWZhdWx0VmFsdWVdID1cblx0Y3JlYXRlSW5qZWN0aW9uVG9rZW48KCkgPT4gYW55PigoKSA9PiBudWxsKTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHtAbGluayBOZ3hDb250cm9sVmFsdWVBY2Nlc3NvckNvbXBhcmVUbyBjb21wYXJhdG9yfSBiYXNlZCBvbiBhIHByb3BlcnR5IG9mIGBUYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGludGVyZmFjZSBVc2VyIHtcbiAqIFx0aWQ6IHN0cmluZztcbiAqIFx0bmFtZTogc3RyaW5nO1xuICogfVxuICpcbiAqIHByb3ZpZGVDdmFDb21wYXJlVG9CeVByb3A8VXNlcj4oJ2lkJyk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHByb3ZpZGVDdmFDb21wYXJlVG9CeVByb3AgPSA8VD4ocHJvcDoga2V5b2YgVCkgPT5cblx0cHJvdmlkZUN2YUNvbXBhcmVUbygoYSwgYikgPT4gT2JqZWN0LmlzKGE/Lltwcm9wXSwgYj8uW3Byb3BdKSwgdHJ1ZSk7XG5cbi8qKlxuICogYE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBpcyBhIGRpcmVjdGl2ZSB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBidWlsZGluZyBjb21wb25lbnRzLCB3aGljaCBpbXBsZW1lbnQgdGhlIFtDb250cm9sVmFsdWVBY2Nlc3Nvcl0oaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9mb3Jtcy9Db250cm9sVmFsdWVBY2Nlc3NvcikgaW50ZXJmYWNlLlxuICpcbiAqICMjIFVzYWdlXG4gKlxuICogYE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBpbXBsZW1lbnRzIHRoZSBbQ29udHJvbFZhbHVlQWNjZXNzb3JdKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvZm9ybXMvQ29udHJvbFZhbHVlQWNjZXNzb3IpIGludGVyZmFjZSBhbmQgZXhwb3NlcyBhIF9zaW1wbGVyXyBhcGkuIERlY2xhcmUgYE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBpbiB0aGUgYGhvc3REaXJlY3RpdmVzYCBzZWN0aW9uIG9mIHlvdXIgY29tcG9uZW50IGFuZCBpbmplY3QgdGhlIGluc3RhbmNlIGluIG9yZGVyIHRvIHdpcmUgdXAgeW91ciB0ZW1wbGF0ZTpcbiAqXG4gKiAtIGBOZ3hDb250cm9sVmFsdWVBY2Nlc3Nvci52YWx1ZWAgZm9yIHN5bmNpbmcgdGhlIHZhbHVlXG4gKiAtIGBOZ3hDb250cm9sVmFsdWVBY2Nlc3Nvci5kaXNhYmxlZGAgZm9yIHN5bmNpbmcgdGhlIGRpc2FibGVkIHN0YXRlXG4gKiAtIGBOZ3hDb250cm9sVmFsdWVBY2Nlc3Nvci5tYXJrQXNUb3VjaGVkYCBmb3IgbWFya2luZyB0aGUgdmlldyBhcyBfdG91Y2hlZF9cbiAqXG4gKiBUaGUgdmFsdWUgYW5kIGRpc2FibGVkIHN0YXRlIGFyZSBhbHNvIGF2YWlsYWJsZSBhcyBzaWduYWxzOlxuICpcbiAqIC0gYE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yLnZhbHVlJGBcbiAqIC0gYE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yLmRpc2FibGVkJGBcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIEluIHRoaXMgZXhhbXBsZSBgTmd4Q29udHJvbFZhbHVlQWNjZXNzb3JgIGlzIHVzZWQgdG8gY3JlYXRlIGEgYEN1c3RvbUlucHV0YCBjb21wb25lbnQuXG4gKlxuICogYGBgdHNcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2N1c3RvbS1pbnB1dCcsXG4gKiAgIGhvc3REaXJlY3RpdmVzOiBbTmd4Q29udHJvbFZhbHVlQWNjZXNzb3JdLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxsYWJlbD5cbiAqICAgICAgIDxiPkN1c3RvbSBsYWJlbDwvYj5cbiAqICAgICAgIDxpbnB1dFxuICogICAgICAgICB0eXBlPVwidGV4dFwiXG4gKiAgICAgICAgIChpbnB1dCk9XCJjdmEudmFsdWUgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXCJcbiAqICAgICAgICAgW3ZhbHVlXT1cImN2YS52YWx1ZSQoKVwiXG4gKiAgICAgICAgIFtkaXNhYmxlZF09XCJjdmEuZGlzYWJsZWQkKClcIlxuICogICAgICAgICAoYmx1cik9XCJjdmEubWFya0FzVG91Y2hlZCgpXCJcbiAqICAgICAgIC8+XG4gKiAgICAgPC9sYWJlbD5cbiAqICAgYCxcbiAqICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQ3VzdG9tSW5wdXQge1xuICogICBwcm90ZWN0ZWQgY3ZhID0gaW5qZWN0PE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yPHN0cmluZz4+KFxuICogICAgIE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogV2l0aCB1c2FnZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8Y3VzdG9tLWlucHV0IFtmb3JtQ29udHJvbF09XCJjb250cm9sXCIgLz5cbiAqIDxjdXN0b20taW5wdXQgWyhuZ01vZGVsKV09XCJ2YWx1ZVwiIC8+XG4gKiBgYGBcbiAqXG4gKiAjIyBOb24gUHJpbWl0aXZlIFZhbHVlc1xuICpcbiAqIFdoZW4geW91ciBtb2RlbCBpcyBhIG5vbiBwcmltaXRpdmUgZGF0YXR5cGUsIHlvdSBzaG91bGQgcHJvdmlkZSBhIF9jb21wYXJhdG9yXy4gSXQgaXMgYSBwdXJlIGZ1bmN0aW9uIHdoaWNoIHRlbGxzIGBOZ3hDb250cm9sVmFsdWVBY2Nlc3NvcmAsIHdoZXRoZXIgdHdvIHZhbHVlcyBhcmUgX3NlbWFudGljYWxseV8gZXF1YWw6XG4gKlxuICogYGBgdHNcbiAqIChhLCBiKSA9PiBib29sZWFuO1xuICogYGBgXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBJbiB0aGlzIGV4YW1wbGUgYE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBpcyB1c2VkIHRvIGNyZWF0ZSBhIGBVc2VyYCBzZWxlY3QuIEEgYFVzZXJgIGlzIGlkZW50aWZpZWQgYnkgaXRzIGBpZGAuXG4gKlxuICogYGBgdHNcbiAqIGludGVyZmFjZSBVc2VyIHtcbiAqICAgaWQ6IHN0cmluZztcbiAqICAgbmFtZTogc3RyaW5nO1xuICogfVxuICpcbiAqIGNvbnN0IHVzZXJDb21wYXJhdG9yOiBOZ3hDb250cm9sVmFsdWVBY2Nlc3NvckNvbXBhcmVUbzxVc2VyPiA9IChhLCBiKSA9PlxuICogICBhPy5pZCA9PT0gYj8uaWQ7XG4gKlxuICogcHJvdmlkZUN2YUNvbXBhcmVUbyh1c2VyQ29tcGFyYXRvciwgdHJ1ZSk7XG4gKlxuICogLy8gb3JcbiAqXG4gKiBwcm92aWRlQ3ZhQ29tcGFyZVRvQnlQcm9wPFVzZXI+KCdpZCcpO1xuICogYGBgXG4gKlxuICogRnVsbCBleGFtcGxlOlxuICpcbiAqIGBgYHRzXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICd1c2VyLXNlbGVjdCcsXG4gKiAgIHN0YW5kYWxvbmU6IHRydWUsXG4gKiAgIGhvc3REaXJlY3RpdmVzOiBbTmd4Q29udHJvbFZhbHVlQWNjZXNzb3JdLFxuICogICBwcm92aWRlcnM6IFtwcm92aWRlQ3ZhQ29tcGFyZVRvQnlQcm9wPFVzZXI+KCdpZCcpXSxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8bGFiZWw+XG4gKiAgICAgICA8Yj5TZWxlY3QgYSB1c2VyOjwvYj5cbiAqICAgICAgIDxzZWxlY3RcbiAqICAgICAgICAgW2Rpc2FibGVkXT1cImN2YS5kaXNhYmxlZCQoKVwiXG4gKiAgICAgICAgIChibHVyKT1cImN2YS5tYXJrQXNUb3VjaGVkKClcIlxuICogICAgICAgICAoY2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIlxuICogICAgICAgPlxuICogICAgICAgICA8b3B0aW9uIFtzZWxlY3RlZF09XCJjdmEudmFsdWUgPT09IG51bGxcIj4tLSBubyB1c2VyIHNlbGVjdGVkIC0tPC9vcHRpb24+XG4gKiAgICAgICAgIEBmb3IgKHVzZXIgb2YgdXNlcnM7IHRyYWNrIHVzZXIuaWQpIHtcbiAqICAgICAgICAgICA8b3B0aW9uIFt2YWx1ZV09XCJ1c2VyLmlkXCIgW3NlbGVjdGVkXT1cInVzZXIuaWQgPT09IGN2YS52YWx1ZT8uaWRcIj5cbiAqICAgICAgICAgICAgIHt7IHVzZXIubmFtZSB9fVxuICogICAgICAgICAgIDwvb3B0aW9uPlxuICogICAgICAgICB9XG4gKiAgICAgICA8L3NlbGVjdD5cbiAqICAgICA8L2xhYmVsPlxuICogICBgLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBVc2VyU2VsZWN0IHtcbiAqICAgcHJvdGVjdGVkIGN2YSA9IGluamVjdDxOZ3hDb250cm9sVmFsdWVBY2Nlc3NvcjxVc2VyIHwgbnVsbD4+KFxuICogICAgIE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICogICApO1xuICpcbiAqICAgcHJvdGVjdGVkIG9uQ2hhbmdlID0gKGV2ZW50OiBFdmVudCkgPT5cbiAqICAgICAodGhpcy5jdmEudmFsdWUgPVxuICogICAgICAgdGhpcy51c2Vycy5maW5kKCh7IGlkIH0pID0+IGV2ZW50LnRhcmdldC52YWx1ZSA9PT0gaWQpID8/IG51bGwpO1xuICpcbiAqICAgQElucHV0KClcbiAqICAgdXNlcnM6IFVzZXJbXSA9IFtdO1xuICogfVxuICogYGBgXG4gKlxuICogV2l0aCB1c2FnZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8dXNlci1zZWxlY3QgW2Zvcm1Db250cm9sXT1cInVzZXJDb250cm9sXCIgW29wdGlvbnNdPVwidXNlcnNcIiAvPlxuICogPHVzZXItc2VsZWN0IFsobmdNb2RlbCldPVwidXNlclwiIFtvcHRpb25zXT1cInVzZXJzXCIgLz5cbiAqIGBgYFxuICpcbiAqICMjIFdpdGhvdXQgYE5nQ29udHJvbGBcbiAqXG4gKiBPcHRpb25hbGx5IHlvdSBjYW4gZXhwb3NlIGBpbnB1dHNgIGFuZCBgb3V0cHV0c2AgaW4gdGhlIGBob3N0RGlyZWN0aXZlc2AgZGVjbGFyYXRpb25cbiAqIGFuZCB1c2UgaXQgd2l0aG91dCBhIGBOZ0NvbnRyb2xgIGRpcmVjdGl2ZS5cbiAqXG4gKiBgYGB0c1xuICogaG9zdERpcmVjdGl2ZXM6IFtcbiAqICAge1xuICogICAgIGRpcmVjdGl2ZTogTmd4Q29udHJvbFZhbHVlQWNjZXNzb3IsXG4gKiAgICAgaW5wdXRzOiBbJ3ZhbHVlJ10sXG4gKiAgICAgb3V0cHV0czogWyd2YWx1ZUNoYW5nZSddLFxuICogICB9LFxuICogXTtcbiAqIGBgYFxuICpcbiAqIGBgYGh0bWxcbiAqIDxjdXN0b20taW5wdXQgWyh2YWx1ZSldPVwidmFsdWVcIiAvPlxuICogYGBgXG4gKi9cbkBEaXJlY3RpdmUoe1xuXHRzdGFuZGFsb25lOiB0cnVlLFxufSlcbmV4cG9ydCBjbGFzcyBOZ3hDb250cm9sVmFsdWVBY2Nlc3NvcjxUID0gYW55PlxuXHRpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkluaXRcbntcblx0LyoqIEBpZ25vcmUgKi9cblx0cHJpdmF0ZSByZWFkb25seSBpbmplY3RvciA9IGluamVjdChJbmplY3Rvcik7XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0cHJpdmF0ZSByZWFkb25seSBuZ0NvbnRyb2wgPSBpbmplY3QoTmdDb250cm9sLCB7XG5cdFx0c2VsZjogdHJ1ZSxcblx0XHRvcHRpb25hbDogdHJ1ZSxcblx0fSk7XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0cHVibGljIGNvbnN0cnVjdG9yKCkge1xuXHRcdGlmICh0aGlzLm5nQ29udHJvbCAhPSBudWxsKSB0aGlzLm5nQ29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHByaXZhdGUgaW5pdGlhbFZhbHVlID0gKCk6IFQgPT4ge1xuXHRcdGlmICh0aGlzLm5nQ29udHJvbCAhPSBudWxsKSByZXR1cm4gdGhpcy5uZ0NvbnRyb2wudmFsdWU7XG5cdFx0cmV0dXJuIGluamVjdEN2YURlZmF1bHRWYWx1ZSgpO1xuXHR9O1xuXG5cdC8qKiBUaGUgdmFsdWUgb2YgdGhpcy4gSWYgYSBjb250cm9sIGlzIHByZXNlbnQsIGl0IHJlZmxlY3RzIGl0J3MgdmFsdWUuICovXG5cdHB1YmxpYyByZWFkb25seSB2YWx1ZSQgPSBzaWduYWwodGhpcy5pbml0aWFsVmFsdWUoKSwge1xuXHRcdGVxdWFsOiAoYSwgYikgPT4gdGhpcy5jb21wYXJlVG8oYSwgYiksXG5cdH0pO1xuXG5cdC8qKiBXaGV0aGVyIHRoaXMgaXMgZGlzYWJsZWQuIElmIGEgY29udHJvbCBpcyBwcmVzZW50LCBpdCByZWZsZWN0cyBpdCdzIGRpc2FibGVkIHN0YXRlLiAqL1xuXHRwdWJsaWMgcmVhZG9ubHkgZGlzYWJsZWQkID0gc2lnbmFsKHRoaXMubmdDb250cm9sPy5kaXNhYmxlZCA/PyBmYWxzZSk7XG5cblx0LyoqXG5cdCAqIEEgY29tcGFyYXRvciwgd2hpY2ggZGV0ZXJtaW5lcyB2YWx1ZSBjaGFuZ2VzLiBTaG91bGQgcmV0dXJuIHRydWUsIGlmIHR3byB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgc2VtYW50aWNseSBlcXVhbC5cblx0ICpcblx0ICogRGVmYXVsdHMgdG8ge0BsaW5rIE9iamVjdC5pc30gaW4gb3JkZXIgdG8gYWxpZ24gd2l0aCBjaGFuZ2UgZGV0ZWN0aW9uIGJlaGF2aW9yIGZvciBpbnB1dHMuXG5cdCAqL1xuXHRwdWJsaWMgcmVhZG9ubHkgY29tcGFyZVRvJCA9XG5cdFx0c2lnbmFsPE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yQ29tcGFyZVRvPFQ+PihpbmplY3RDdmFDb21wYXJlVG8oKSk7XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0cHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuXHRcdGlmICh0aGlzLm5nQ29udHJvbCAhPSBudWxsKSB7XG5cdFx0XHRydW5JbkluamVjdGlvbkNvbnRleHQodGhpcy5pbmplY3RvciwgKCkgPT4ge1xuXHRcdFx0XHQvLyBOT1RFOiBEb24ndCB1c2UgJ2VmZmVjdCcgYmVjYXVzZSB3ZSBoYXZlIG5vIGlkZWEgaWYgd2UgYXJlIHNldHRpbmcgb3RoZXIgc2lnbmFscyBoZXJlLlxuXG5cdFx0XHRcdC8vIHN5bmMgdmFsdWVcblx0XHRcdFx0cnhFZmZlY3QodG9PYnNlcnZhYmxlKHRoaXMudmFsdWUkKSwgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLmNvbXBhcmVUbyh0aGlzLm5nQ29udHJvbD8udmFsdWUsIHZhbHVlKSlcblx0XHRcdFx0XHRcdHRoaXMub25DaGFuZ2UodmFsdWUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBzeW5jIGRpc2FibGVkIHN0YXRlXG5cdFx0XHRcdHJ4RWZmZWN0KHRvT2JzZXJ2YWJsZSh0aGlzLmRpc2FibGVkJCksIChkaXNhYmxlZCkgPT4ge1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdHRoaXMubmdDb250cm9sICE9IG51bGwgJiZcblx0XHRcdFx0XHRcdHRoaXMubmdDb250cm9sLmNvbnRyb2wgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0dGhpcy5uZ0NvbnRyb2wuZGlzYWJsZWQgIT09IGRpc2FibGVkXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0dGhpcy5uZ0NvbnRyb2wuY29udHJvbFtkaXNhYmxlZCA/ICdkaXNhYmxlJyA6ICdlbmFibGUnXSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBUaGUgdmFsdWUgb2YgdGhpcy4gSWYgYSBjb250cm9sIGlzIHByZXNlbnQsIGl0IHJlZmxlY3RzIGl0J3MgdmFsdWUuICovXG5cdEBJbnB1dCgpXG5cdHB1YmxpYyBzZXQgdmFsdWUodmFsdWU6IFQpIHtcblx0XHR0aGlzLnZhbHVlJC5zZXQodmFsdWUpO1xuXHR9XG5cblx0cHVibGljIGdldCB2YWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZSQoKTtcblx0fVxuXG5cdC8qKiBXaGV0aGVyIHRoaXMgaXMgZGlzYWJsZWQuIElmIGEgY29udHJvbCBpcyBwcmVzZW50LCBpdCByZWZsZWN0cyBpdCdzIGRpc2FibGVkIHN0YXRlLiAqL1xuXHRASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcblx0cHVibGljIHNldCBkaXNhYmxlZChkaXNhYmxlZDogYm9vbGVhbikge1xuXHRcdHRoaXMuZGlzYWJsZWQkLnNldChkaXNhYmxlZCk7XG5cdH1cblxuXHRwdWJsaWMgZ2V0IGRpc2FibGVkKCkge1xuXHRcdHJldHVybiB0aGlzLmRpc2FibGVkJCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgY29tcGFyYXRvciwgd2hpY2ggZGV0ZXJtaW5lcyB2YWx1ZSBjaGFuZ2VzLiBTaG91bGQgcmV0dXJuIHRydWUsIGlmIHR3byB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgc2VtYW50aWNseSBlcXVhbC5cblx0ICpcblx0ICogRGVmYXVsdHMgdG8ge0BsaW5rIE9iamVjdC5pc30gaW4gb3JkZXIgdG8gYWxpZ24gd2l0aCBjaGFuZ2UgZGV0ZWN0aW9uIGJlaGF2aW9yIGZvciBpbnB1dHMuXG5cdCAqL1xuXHRASW5wdXQoKVxuXHRwdWJsaWMgc2V0IGNvbXBhcmVUbyhjb21wYXJlVG8pIHtcblx0XHRpZiAodHlwZW9mIGNvbXBhcmVUbyA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5jb21wYXJlVG8kLnNldChjb21wYXJlVG8pO1xuXHR9XG5cblx0cHVibGljIGdldCBjb21wYXJlVG8oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVRvJCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVtaXRzIHdoZW5ldmVyIHRoaXMge0BsaW5rIE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yLnZhbHVlJCB2YWx1ZX0gY2hhbmdlcy5cblx0ICovXG5cdEBPdXRwdXQoKVxuXHRwdWJsaWMgcmVhZG9ubHkgdmFsdWVDaGFuZ2UgPSB0b09ic2VydmFibGUodGhpcy52YWx1ZSQpLnBpcGUoc2tpcCgxKSk7IC8vIC0+IGhvdCBvYnNlcnZhYmxlXG5cblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoaXMgaG9zdCBpcyBjb25zaWRlcmVkIGB0b3VjaGVkYC5cblx0ICpcblx0ICogTk9URTogV2hlbmV2ZXIgYSBgYmx1cmAgZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIHRoaXMgaG9zdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQuXG5cdCAqXG5cdCAqIEBzZWUge0BsaW5rIE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25Ub3VjaGVkfVxuXHQgKiBAc2VlIHtAbGluayBOZ3hDb250cm9sVmFsdWVBY2Nlc3Nvci5uZ0NvbnRyb2x9XG5cdCAqL1xuXHRwdWJsaWMgbWFya0FzVG91Y2hlZCA9ICgpID0+IHRoaXMub25Ub3VjaGVkKCk7XG5cblx0LyoqIFRoaXMgZnVuY3Rpb24gaXMgc2V0IGJ5IHRoZSBmb3JtcyBhcGksIGlmIGEgY29udHJvbCBpcyBwcmVzZW50LiAqL1xuXHRwcml2YXRlIG9uQ2hhbmdlOiAodmFsdWU6IFQpID0+IHZvaWQgPSBub29wO1xuXG5cdC8qKiBUaGlzIGZ1bmN0aW9uIGlzIHNldCBieSB0aGUgZm9ybXMgYXBpLCBpZiBhIGNvbnRyb2wgaXMgcHJlc2VudC4gKi9cblx0cHJpdmF0ZSBvblRvdWNoZWQ6ICgpID0+IHZvaWQgPSBub29wO1xuXG5cdC8qKlxuXHQgKiBgTmdNb2RlbGAgc2V0cyB1cCB0aGUgY29udHJvbCBpbiBgbmdPbkNoYW5nZXNgLiBJZGsgaWYgYnVnIG9yIG9uIHB1cnBvc2UsIGJ1dCBgd3JpdGVWYWx1ZWAgYW5kIGBzZXREaXNhYmxlZFN0YXRlYCBhcmUgY2FsbGVkIGJlZm9yZSB0aGUgaW5wdXRzIGFyZSBzZXQuXG5cdCAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvbWFpbi9wYWNrYWdlcy9mb3Jtcy9zcmMvZGlyZWN0aXZlcy9uZ19tb2RlbC50cyNMMjIzfVxuXHQgKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHRwcml2YXRlIGdldCByZWdpc3RlcmVkKCkge1xuXHRcdHJldHVybiB0aGlzLm5nQ29udHJvbCBpbnN0YW5jZW9mIE5nTW9kZWxcblx0XHRcdD8gKHRoaXMubmdDb250cm9sIGFzIHVua25vd24gYXMgeyBfcmVnaXN0ZXJlZDogYm9vbGVhbiB9KS5fcmVnaXN0ZXJlZFxuXHRcdFx0OiB0cnVlO1xuXHR9XG5cblx0Ly8gY29udHJvbCB2YWx1ZSBhY2Nlc3NvciBpbXBsZW1lbnRhdGlvblxuXG5cdHB1YmxpYyB3cml0ZVZhbHVlID0gKHZhbHVlOiBUKSA9PiB7XG5cdFx0aWYgKHRoaXMucmVnaXN0ZXJlZCkgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXHR9O1xuXG5cdHB1YmxpYyByZWdpc3Rlck9uQ2hhbmdlID0gKG9uQ2hhbmdlOiAodmFsdWU6IFQpID0+IHZvaWQpID0+XG5cdFx0KHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZSk7XG5cblx0cHVibGljIHJlZ2lzdGVyT25Ub3VjaGVkID0gKG9uVG91Y2hlZDogKCkgPT4gdm9pZCkgPT5cblx0XHQodGhpcy5vblRvdWNoZWQgPSBvblRvdWNoZWQpO1xuXG5cdHB1YmxpYyBzZXREaXNhYmxlZFN0YXRlID0gKGRpc2FibGVkOiBib29sZWFuKSA9PiB7XG5cdFx0aWYgKHRoaXMucmVnaXN0ZXJlZCkgdGhpcy5kaXNhYmxlZCQuc2V0KGRpc2FibGVkKTtcblx0fTtcbn1cbiJdfQ==