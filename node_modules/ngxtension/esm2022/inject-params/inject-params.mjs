import { assertInInjectionContext, inject } from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import { ActivatedRoute } from '@angular/router';
import { map } from 'rxjs';
/**
 * Injects the params from the current route.
 * If a key is provided, it will return the value of that key.
 * If a transform function is provided, it will return the result of that function.
 * Otherwise, it will return the entire params object.
 *
 * @example
 * const userId = injectParams('id'); // returns the value of the 'id' param
 * const userId = injectParams(p => p['id'] as string); // same as above but can be used with a custom transform function
 * const params = injectParams(); // returns the entire params object
 *
 * @param keyOrTransform OPTIONAL The key of the param to return, or a transform function to apply to the params object
 */
export function injectParams(keyOrTransform) {
    assertInInjectionContext(injectParams);
    const route = inject(ActivatedRoute);
    const params = route.snapshot.params;
    if (typeof keyOrTransform === 'function') {
        return toSignal(route.params.pipe(map(keyOrTransform)), {
            initialValue: keyOrTransform(params),
        });
    }
    const getParam = (params) => keyOrTransform ? params?.[keyOrTransform] ?? null : params;
    return toSignal(route.params.pipe(map(getParam)), {
        initialValue: getParam(params),
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5qZWN0LXBhcmFtcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvbmd4dGVuc2lvbi9pbmplY3QtcGFyYW1zL3NyYy9pbmplY3QtcGFyYW1zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLEVBQWUsTUFBTSxlQUFlLENBQUM7QUFDOUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3RELE9BQU8sRUFBRSxjQUFjLEVBQWUsTUFBTSxpQkFBaUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBbUIzQjs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSCxNQUFNLFVBQVUsWUFBWSxDQUMzQixjQUFpRDtJQUVqRCx3QkFBd0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUN2QyxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDckMsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7SUFFckMsSUFBSSxPQUFPLGNBQWMsS0FBSyxVQUFVLEVBQUUsQ0FBQztRQUMxQyxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRTtZQUN2RCxZQUFZLEVBQUUsY0FBYyxDQUFDLE1BQU0sQ0FBQztTQUNwQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQsTUFBTSxRQUFRLEdBQUcsQ0FBQyxNQUFjLEVBQUUsRUFBRSxDQUNuQyxjQUFjLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLGNBQWMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0lBRTVELE9BQU8sUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFO1FBQ2pELFlBQVksRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDO0tBQzlCLENBQUMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnRJbkluamVjdGlvbkNvbnRleHQsIGluamVjdCwgdHlwZSBTaWduYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRvU2lnbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZS9yeGpzLWludGVyb3AnO1xuaW1wb3J0IHsgQWN0aXZhdGVkUm91dGUsIHR5cGUgUGFyYW1zIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIEluamVjdHMgdGhlIHBhcmFtcyBmcm9tIHRoZSBjdXJyZW50IHJvdXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0UGFyYW1zKCk6IFNpZ25hbDxQYXJhbXM+O1xuXG4vKipcbiAqIEluamVjdHMgdGhlIHBhcmFtcyBmcm9tIHRoZSBjdXJyZW50IHJvdXRlIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQga2V5LlxuICogQHBhcmFtIGtleVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0UGFyYW1zKGtleTogc3RyaW5nKTogU2lnbmFsPHN0cmluZyB8IG51bGw+O1xuXG4vKipcbiAqIEluamVjdHMgdGhlIHBhcmFtcyBmcm9tIHRoZSBjdXJyZW50IHJvdXRlIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIHByb3ZpZGVkIHRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB0cmFuc2Zvcm1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluamVjdFBhcmFtczxUPih0cmFuc2Zvcm06IChwYXJhbXM6IFBhcmFtcykgPT4gVCk6IFNpZ25hbDxUPjtcblxuLyoqXG4gKiBJbmplY3RzIHRoZSBwYXJhbXMgZnJvbSB0aGUgY3VycmVudCByb3V0ZS5cbiAqIElmIGEga2V5IGlzIHByb3ZpZGVkLCBpdCB3aWxsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhhdCBrZXkuXG4gKiBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiBpcyBwcm92aWRlZCwgaXQgd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGF0IGZ1bmN0aW9uLlxuICogT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgZW50aXJlIHBhcmFtcyBvYmplY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHVzZXJJZCA9IGluamVjdFBhcmFtcygnaWQnKTsgLy8gcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlICdpZCcgcGFyYW1cbiAqIGNvbnN0IHVzZXJJZCA9IGluamVjdFBhcmFtcyhwID0+IHBbJ2lkJ10gYXMgc3RyaW5nKTsgLy8gc2FtZSBhcyBhYm92ZSBidXQgY2FuIGJlIHVzZWQgd2l0aCBhIGN1c3RvbSB0cmFuc2Zvcm0gZnVuY3Rpb25cbiAqIGNvbnN0IHBhcmFtcyA9IGluamVjdFBhcmFtcygpOyAvLyByZXR1cm5zIHRoZSBlbnRpcmUgcGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSBrZXlPclRyYW5zZm9ybSBPUFRJT05BTCBUaGUga2V5IG9mIHRoZSBwYXJhbSB0byByZXR1cm4sIG9yIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSBwYXJhbXMgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RQYXJhbXM8VD4oXG5cdGtleU9yVHJhbnNmb3JtPzogc3RyaW5nIHwgKChwYXJhbXM6IFBhcmFtcykgPT4gVCksXG4pOiBTaWduYWw8VCB8IFBhcmFtcyB8IHN0cmluZyB8IG51bGw+IHtcblx0YXNzZXJ0SW5JbmplY3Rpb25Db250ZXh0KGluamVjdFBhcmFtcyk7XG5cdGNvbnN0IHJvdXRlID0gaW5qZWN0KEFjdGl2YXRlZFJvdXRlKTtcblx0Y29uc3QgcGFyYW1zID0gcm91dGUuc25hcHNob3QucGFyYW1zO1xuXG5cdGlmICh0eXBlb2Yga2V5T3JUcmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gdG9TaWduYWwocm91dGUucGFyYW1zLnBpcGUobWFwKGtleU9yVHJhbnNmb3JtKSksIHtcblx0XHRcdGluaXRpYWxWYWx1ZToga2V5T3JUcmFuc2Zvcm0ocGFyYW1zKSxcblx0XHR9KTtcblx0fVxuXG5cdGNvbnN0IGdldFBhcmFtID0gKHBhcmFtczogUGFyYW1zKSA9PlxuXHRcdGtleU9yVHJhbnNmb3JtID8gcGFyYW1zPy5ba2V5T3JUcmFuc2Zvcm1dID8/IG51bGwgOiBwYXJhbXM7XG5cblx0cmV0dXJuIHRvU2lnbmFsKHJvdXRlLnBhcmFtcy5waXBlKG1hcChnZXRQYXJhbSkpLCB7XG5cdFx0aW5pdGlhbFZhbHVlOiBnZXRQYXJhbShwYXJhbXMpLFxuXHR9KTtcbn1cbiJdfQ==