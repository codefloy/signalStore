import { DOCUMENT } from '@angular/common';
import { DestroyRef, Directive, ElementRef, EventEmitter, Input, NgZone, Output, inject, } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { createInjectionToken } from 'ngxtension/create-injection-token';
import { Observable, ReplaySubject, debounceTime, fromEvent, pipe, share, takeUntil, } from 'rxjs';
import * as i0 from "@angular/core";
export const defaultResizeOptions = {
    box: 'content-box',
    scroll: false,
    offsetSize: false,
    debounce: { scroll: 50, resize: 0 },
    emitInZone: true,
    emitInitialResult: false,
};
export const [injectResizeOptions, provideResizeOptions, NGX_RESIZE_OPTIONS] = createInjectionToken(() => defaultResizeOptions);
/**
 * `injectResize` returns an `Observable<ResizeResult>` that observes the `resize` event on the Host element
 * of the component. `options` passed in is merged with default options
 *
 * @see {@link defaultResizeOptions}
 *
 * @param {Partial<ResizeOptions>} [options={}]
 * @see {@link ResizeOptions}
 *
 * @returns {Observable<ResizeResult>}
 * @see {@link ResizeResult}
 */
export function injectResize(options = {}) {
    const [{ nativeElement }, zone, document] = [
        inject(ElementRef),
        inject(NgZone),
        inject(DOCUMENT),
    ];
    const mergedOptions = { ...injectResizeOptions(), ...options };
    return createResizeStream(mergedOptions, nativeElement, document, zone);
}
/**
 * A directive to be used on any element instead of the Host element. For Host element, there are 3 approaches:
 * - use {@link injectResize}
 * - use `hostDirectives`  with `HostListener` on `ngxResize`
 *
 * @param {Partial<ResizeOptions>} - partial options to control `Resize` behavior. merged with default options
 * @see {@link defaultResizeOptions}
 *
 * @returns {ResizeResult} - as an Output `(ngxResize)`
 */
export class NgxResize {
    constructor() {
        this.ngxResizeOptions = {};
        this.ngxResize = new EventEmitter();
        this.host = inject(ElementRef);
        this.zone = inject(NgZone);
        this.document = inject(DOCUMENT);
        this.resizeOptions = injectResizeOptions();
        this.destroyRef = inject(DestroyRef);
    }
    ngOnInit() {
        const mergedOptions = { ...this.resizeOptions, ...this.ngxResizeOptions };
        createResizeStream(mergedOptions, this.host.nativeElement, this.document, this.zone)
            .pipe(takeUntilDestroyed(this.destroyRef))
            .subscribe(this.ngxResize);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxResize, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.3", type: NgxResize, isStandalone: true, selector: "[ngxResize]", inputs: { ngxResizeOptions: "ngxResizeOptions" }, outputs: { ngxResize: "ngxResize" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxResize, decorators: [{
            type: Directive,
            args: [{ selector: '[ngxResize]', standalone: true }]
        }], propDecorators: { ngxResizeOptions: [{
                type: Input
            }], ngxResize: [{
                type: Output
            }] } });
// return ResizeResult observable
function createResizeStream({ debounce, scroll, offsetSize, box, emitInZone, emitInitialResult, }, nativeElement, document, zone) {
    const window = document.defaultView;
    const isSupport = !!window?.ResizeObserver;
    let observer;
    let lastBounds;
    let lastEntries = [];
    const torndown$ = new ReplaySubject();
    const scrollContainers = findScrollContainers(nativeElement, window, document.body);
    // set actual debounce values early, so effects know if they should react accordingly
    const scrollDebounce = debounce
        ? typeof debounce === 'number'
            ? debounce
            : debounce.scroll
        : null;
    const resizeDebounce = debounce
        ? typeof debounce === 'number'
            ? debounce
            : debounce.resize
        : null;
    const debounceAndTorndown = (debounce) => {
        return pipe(debounceTime(debounce ?? 0), takeUntil(torndown$));
    };
    return new Observable((subscriber) => {
        if (!isSupport) {
            subscriber.error('[ngx-resize] your browser does not support ResizeObserver. Please consider using a polyfill');
            return;
        }
        zone.runOutsideAngular(() => {
            if (emitInitialResult) {
                const [result] = calculateResult(nativeElement, window, offsetSize, []);
                if (emitInZone)
                    zone.run(() => void subscriber.next(result));
                else
                    subscriber.next(result);
            }
            const callback = (entries) => {
                lastEntries = entries;
                const [result, size] = calculateResult(nativeElement, window, offsetSize, entries);
                if (emitInZone)
                    zone.run(() => void subscriber.next(result));
                else
                    subscriber.next(result);
                if (!areBoundsEqual(lastBounds || {}, size))
                    lastBounds = size;
            };
            const boundCallback = () => void callback(lastEntries);
            observer = new ResizeObserver(callback);
            observer.observe(nativeElement, { box });
            if (scroll) {
                if (scrollContainers) {
                    scrollContainers.forEach((scrollContainer) => {
                        fromEvent(scrollContainer, 'scroll', {
                            capture: true,
                            passive: true,
                        })
                            .pipe(debounceAndTorndown(scrollDebounce))
                            .subscribe(boundCallback);
                    });
                }
                fromEvent(window, 'scroll', { capture: true, passive: true })
                    .pipe(debounceAndTorndown(scrollDebounce))
                    .subscribe(boundCallback);
            }
            fromEvent(window, 'resize')
                .pipe(debounceAndTorndown(resizeDebounce))
                .subscribe(boundCallback);
        });
        return () => {
            if (observer) {
                observer.unobserve(nativeElement);
                observer.disconnect();
            }
            torndown$.next();
            torndown$.complete();
        };
    }).pipe(debounceTime(scrollDebounce ?? 0), share({ connector: () => new ReplaySubject(1) }));
}
function calculateResult(nativeElement, window, offsetSize, entries) {
    const { left, top, width, height, bottom, right, x, y } = nativeElement.getBoundingClientRect();
    const size = { left, top, width, height, bottom, right, x, y };
    if (nativeElement instanceof HTMLElement && offsetSize) {
        size.height = nativeElement.offsetHeight;
        size.width = nativeElement.offsetWidth;
    }
    Object.freeze(size);
    return [{ entries, dpr: window.devicePixelRatio, ...size }, size];
}
// Returns a list of scroll offsets
function findScrollContainers(element, window, documentBody) {
    const result = [];
    if (!element || !window || element === documentBody)
        return result;
    const { overflow, overflowX, overflowY } = window.getComputedStyle(element);
    if ([overflow, overflowX, overflowY].some((prop) => prop === 'auto' || prop === 'scroll'))
        result.push(element);
    return [
        ...result,
        ...findScrollContainers(element.parentElement, window, documentBody),
    ];
}
// Checks if element boundaries are equal
const keys = [
    'x',
    'y',
    'top',
    'bottom',
    'left',
    'right',
    'width',
    'height',
];
const areBoundsEqual = (a, b) => keys.every((key) => a[key] === b[key]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXplLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGlicy9uZ3h0ZW5zaW9uL3Jlc2l6ZS9zcmMvcmVzaXplLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQ04sVUFBVSxFQUNWLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFDTCxNQUFNLEVBQ04sTUFBTSxFQUNOLE1BQU0sR0FFTixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN6RSxPQUFPLEVBQ04sVUFBVSxFQUNWLGFBQWEsRUFDYixZQUFZLEVBQ1osU0FBUyxFQUNULElBQUksRUFDSixLQUFLLEVBQ0wsU0FBUyxHQUVULE1BQU0sTUFBTSxDQUFDOztBQVdkLE1BQU0sQ0FBQyxNQUFNLG9CQUFvQixHQUFrQjtJQUNsRCxHQUFHLEVBQUUsYUFBYTtJQUNsQixNQUFNLEVBQUUsS0FBSztJQUNiLFVBQVUsRUFBRSxLQUFLO0lBQ2pCLFFBQVEsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRTtJQUNuQyxVQUFVLEVBQUUsSUFBSTtJQUNoQixpQkFBaUIsRUFBRSxLQUFLO0NBQ3hCLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxDQUFDLG1CQUFtQixFQUFFLG9CQUFvQixFQUFFLGtCQUFrQixDQUFDLEdBQzNFLG9CQUFvQixDQUFDLEdBQUcsRUFBRSxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFlbEQ7Ozs7Ozs7Ozs7O0dBV0c7QUFDSCxNQUFNLFVBQVUsWUFBWSxDQUMzQixVQUFrQyxFQUFFO0lBRXBDLE1BQU0sQ0FBQyxFQUFFLGFBQWEsRUFBRSxFQUFFLElB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bkMsU0FBUyxvQkFBb0IsQ0FDNUIsT0FBZ0MsRUFDaEMsTUFBcUIsRUFDckIsWUFBeUI7SUFFekIsTUFBTSxNQUFNLEdBQXVCLEVBQUUsQ0FBQztJQUN0QyxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsTUFBTSxJQUFJLE9BQU8sS0FBSyxZQUFZO1FBQUUsT0FBTyxNQUFNLENBQUM7SUFDbkUsTUFBTSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUNqRSxPQUFzQixDQUN0QixDQUFDO0lBQ0YsSUFDQyxDQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUNwQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssUUFBUSxDQUM5QztRQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdEIsT0FBTztRQUNOLEdBQUcsTUFBTTtRQUNULEdBQUcsb0JBQW9CLENBQ3JCLE9BQXVCLENBQUMsYUFBYSxFQUN0QyxNQUFNLEVBQ04sWUFBWSxDQUNaO0tBQ0QsQ0FBQztBQUNILENBQUM7QUFFRCx5Q0FBeUM7QUFDekMsTUFBTSxJQUFJLEdBQW9EO0lBQzdELEdBQUc7SUFDSCxHQUFHO0lBQ0gsS0FBSztJQUNMLFFBQVE7SUFDUixNQUFNO0lBQ04sT0FBTztJQUNQLE9BQU87SUFDUCxRQUFRO0NBQ1IsQ0FBQztBQUNGLE1BQU0sY0FBYyxHQUFHLENBQ3RCLENBQXdDLEVBQ3hDLENBQXdDLEVBQ3ZDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuXHREZXN0cm95UmVmLFxuXHREaXJlY3RpdmUsXG5cdEVsZW1lbnRSZWYsXG5cdEV2ZW50RW1pdHRlcixcblx0SW5wdXQsXG5cdE5nWm9uZSxcblx0T3V0cHV0LFxuXHRpbmplY3QsXG5cdHR5cGUgT25Jbml0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbERlc3Ryb3llZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvcnhqcy1pbnRlcm9wJztcbmltcG9ydCB7IGNyZWF0ZUluamVjdGlvblRva2VuIH0gZnJvbSAnbmd4dGVuc2lvbi9jcmVhdGUtaW5qZWN0aW9uLXRva2VuJztcbmltcG9ydCB7XG5cdE9ic2VydmFibGUsXG5cdFJlcGxheVN1YmplY3QsXG5cdGRlYm91bmNlVGltZSxcblx0ZnJvbUV2ZW50LFxuXHRwaXBlLFxuXHRzaGFyZSxcblx0dGFrZVVudGlsLFxuXHR0eXBlIE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbixcbn0gZnJvbSAncnhqcyc7XG5cbmV4cG9ydCB0eXBlIFJlc2l6ZU9wdGlvbnMgPSB7XG5cdGJveDogUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zO1xuXHRkZWJvdW5jZTogbnVtYmVyIHwgeyBzY3JvbGw6IG51bWJlcjsgcmVzaXplOiBudW1iZXIgfTtcblx0c2Nyb2xsOiBib29sZWFuO1xuXHRvZmZzZXRTaXplOiBib29sZWFuO1xuXHRlbWl0SW5ab25lOiBib29sZWFuO1xuXHRlbWl0SW5pdGlhbFJlc3VsdDogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UmVzaXplT3B0aW9uczogUmVzaXplT3B0aW9ucyA9IHtcblx0Ym94OiAnY29udGVudC1ib3gnLFxuXHRzY3JvbGw6IGZhbHNlLFxuXHRvZmZzZXRTaXplOiBmYWxzZSxcblx0ZGVib3VuY2U6IHsgc2Nyb2xsOiA1MCwgcmVzaXplOiAwIH0sXG5cdGVtaXRJblpvbmU6IHRydWUsXG5cdGVtaXRJbml0aWFsUmVzdWx0OiBmYWxzZSxcbn07XG5cbmV4cG9ydCBjb25zdCBbaW5qZWN0UmVzaXplT3B0aW9ucywgcHJvdmlkZVJlc2l6ZU9wdGlvbnMsIE5HWF9SRVNJWkVfT1BUSU9OU10gPVxuXHRjcmVhdGVJbmplY3Rpb25Ub2tlbigoKSA9PiBkZWZhdWx0UmVzaXplT3B0aW9ucyk7XG5cbmV4cG9ydCB0eXBlIFJlc2l6ZVJlc3VsdCA9IHtcblx0cmVhZG9ubHkgZW50cmllczogUmVhZG9ubHlBcnJheTxSZXNpemVPYnNlcnZlckVudHJ5Pjtcblx0cmVhZG9ubHkgeDogbnVtYmVyO1xuXHRyZWFkb25seSB5OiBudW1iZXI7XG5cdHJlYWRvbmx5IHdpZHRoOiBudW1iZXI7XG5cdHJlYWRvbmx5IGhlaWdodDogbnVtYmVyO1xuXHRyZWFkb25seSB0b3A6IG51bWJlcjtcblx0cmVhZG9ubHkgcmlnaHQ6IG51bWJlcjtcblx0cmVhZG9ubHkgYm90dG9tOiBudW1iZXI7XG5cdHJlYWRvbmx5IGxlZnQ6IG51bWJlcjtcblx0cmVhZG9ubHkgZHByOiBudW1iZXI7XG59O1xuXG4vKipcbiAqIGBpbmplY3RSZXNpemVgIHJldHVybnMgYW4gYE9ic2VydmFibGU8UmVzaXplUmVzdWx0PmAgdGhhdCBvYnNlcnZlcyB0aGUgYHJlc2l6ZWAgZXZlbnQgb24gdGhlIEhvc3QgZWxlbWVudFxuICogb2YgdGhlIGNvbXBvbmVudC4gYG9wdGlvbnNgIHBhc3NlZCBpbiBpcyBtZXJnZWQgd2l0aCBkZWZhdWx0IG9wdGlvbnNcbiAqXG4gKiBAc2VlIHtAbGluayBkZWZhdWx0UmVzaXplT3B0aW9uc31cbiAqXG4gKiBAcGFyYW0ge1BhcnRpYWw8UmVzaXplT3B0aW9ucz59IFtvcHRpb25zPXt9XVxuICogQHNlZSB7QGxpbmsgUmVzaXplT3B0aW9uc31cbiAqXG4gKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxSZXNpemVSZXN1bHQ+fVxuICogQHNlZSB7QGxpbmsgUmVzaXplUmVzdWx0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0UmVzaXplKFxuXHRvcHRpb25zOiBQYXJ0aWFsPFJlc2l6ZU9wdGlvbnM+ID0ge30sXG4pOiBPYnNlcnZhYmxlPFJlc2l6ZVJlc3VsdD4ge1xuXHRjb25zdCBbeyBuYXRpdmVFbGVtZW50IH0sIHpvbmUsIGRvY3VtZW50XSA9IFtcblx0XHRpbmplY3QoRWxlbWVudFJlZikgYXMgRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG5cdFx0aW5qZWN0KE5nWm9uZSksXG5cdFx0aW5qZWN0KERPQ1VNRU5UKSxcblx0XTtcblx0Y29uc3QgbWVyZ2VkT3B0aW9ucyA9IHsgLi4uaW5qZWN0UmVzaXplT3B0aW9ucygpLCAuLi5vcHRpb25zIH07XG5cdHJldHVybiBjcmVhdGVSZXNpemVTdHJlYW0obWVyZ2VkT3B0aW9ucywgbmF0aXZlRWxlbWVudCwgZG9jdW1lbnQsIHpvbmUpO1xufVxuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHRvIGJlIHVzZWQgb24gYW55IGVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgSG9zdCBlbGVtZW50LiBGb3IgSG9zdCBlbGVtZW50LCB0aGVyZSBhcmUgMyBhcHByb2FjaGVzOlxuICogLSB1c2Uge0BsaW5rIGluamVjdFJlc2l6ZX1cbiAqIC0gdXNlIGBob3N0RGlyZWN0aXZlc2AgIHdpdGggYEhvc3RMaXN0ZW5lcmAgb24gYG5neFJlc2l6ZWBcbiAqXG4gKiBAcGFyYW0ge1BhcnRpYWw8UmVzaXplT3B0aW9ucz59IC0gcGFydGlhbCBvcHRpb25zIHRvIGNvbnRyb2wgYFJlc2l6ZWAgYmVoYXZpb3IuIG1lcmdlZCB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuICogQHNlZSB7QGxpbmsgZGVmYXVsdFJlc2l6ZU9wdGlvbnN9XG4gKlxuICogQHJldHVybnMge1Jlc2l6ZVJlc3VsdH0gLSBhcyBhbiBPdXRwdXQgYChuZ3hSZXNpemUpYFxuICovXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbmd4UmVzaXplXScsIHN0YW5kYWxvbmU6IHRydWUgfSlcbmV4cG9ydCBjbGFzcyBOZ3hSZXNpemUgaW1wbGVtZW50cyBPbkluaXQge1xuXHRASW5wdXQoKSBuZ3hSZXNpemVPcHRpb25zOiBQYXJ0aWFsPFJlc2l6ZU9wdGlvbnM+ID0ge307XG5cdEBPdXRwdXQoKSBuZ3hSZXNpemUgPSBuZXcgRXZlbnRFbWl0dGVyPFJlc2l6ZVJlc3VsdD4oKTtcblxuXHRwcml2YXRlIGhvc3QgPSBpbmplY3QoRWxlbWVudFJlZik7XG5cdHByaXZhdGUgem9uZSA9IGluamVjdChOZ1pvbmUpO1xuXHRwcml2YXRlIGRvY3VtZW50ID0gaW5qZWN0KERPQ1VNRU5UKTtcblx0cHJpdmF0ZSByZXNpemVPcHRpb25zID0gaW5qZWN0UmVzaXplT3B0aW9ucygpO1xuXHRwcml2YXRlIGRlc3Ryb3lSZWYgPSBpbmplY3QoRGVzdHJveVJlZik7XG5cblx0bmdPbkluaXQoKSB7XG5cdFx0Y29uc3QgbWVyZ2VkT3B0aW9ucyA9IHsgLi4udGhpcy5yZXNpemVPcHRpb25zLCAuLi50aGlzLm5neFJlc2l6ZU9wdGlvbnMgfTtcblx0XHRjcmVhdGVSZXNpemVTdHJlYW0oXG5cdFx0XHRtZXJnZWRPcHRpb25zLFxuXHRcdFx0dGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQsXG5cdFx0XHR0aGlzLmRvY3VtZW50LFxuXHRcdFx0dGhpcy56b25lLFxuXHRcdClcblx0XHRcdC5waXBlKHRha2VVbnRpbERlc3Ryb3llZCh0aGlzLmRlc3Ryb3lSZWYpKVxuXHRcdFx0LnN1YnNjcmliZSh0aGlzLm5neFJlc2l6ZSk7XG5cdH1cbn1cblxuLy8gcmV0dXJuIFJlc2l6ZVJlc3VsdCBvYnNlcnZhYmxlXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVTdHJlYW0oXG5cdHtcblx0XHRkZWJvdW5jZSxcblx0XHRzY3JvbGwsXG5cdFx0b2Zmc2V0U2l6ZSxcblx0XHRib3gsXG5cdFx0ZW1pdEluWm9uZSxcblx0XHRlbWl0SW5pdGlhbFJlc3VsdCxcblx0fTogUmVzaXplT3B0aW9ucyxcblx0bmF0aXZlRWxlbWVudDogSFRNTEVsZW1lbnQsXG5cdGRvY3VtZW50OiBEb2N1bWVudCxcblx0em9uZTogTmdab25lLFxuKSB7XG5cdGNvbnN0IHdpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRjb25zdCBpc1N1cHBvcnQgPSAhIXdpbmRvdz8uUmVzaXplT2JzZXJ2ZXI7XG5cblx0bGV0IG9ic2VydmVyOiBSZXNpemVPYnNlcnZlcjtcblx0bGV0IGxhc3RCb3VuZHM6IE9taXQ8UmVzaXplUmVzdWx0LCAnZW50cmllcycgfCAnZHByJz47XG5cdGxldCBsYXN0RW50cmllczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdID0gW107XG5cblx0Y29uc3QgdG9ybmRvd24kID0gbmV3IFJlcGxheVN1YmplY3Q8dm9pZD4oKTtcblx0Y29uc3Qgc2Nyb2xsQ29udGFpbmVyczogSFRNTE9yU1ZHRWxlbWVudFtdIHwgbnVsbCA9IGZpbmRTY3JvbGxDb250YWluZXJzKFxuXHRcdG5hdGl2ZUVsZW1lbnQsXG5cdFx0d2luZG93LFxuXHRcdGRvY3VtZW50LmJvZHksXG5cdCk7XG5cblx0Ly8gc2V0IGFjdHVhbCBkZWJvdW5jZSB2YWx1ZXMgZWFybHksIHNvIGVmZmVjdHMga25vdyBpZiB0aGV5IHNob3VsZCByZWFjdCBhY2NvcmRpbmdseVxuXHRjb25zdCBzY3JvbGxEZWJvdW5jZSA9IGRlYm91bmNlXG5cdFx0PyB0eXBlb2YgZGVib3VuY2UgPT09ICdudW1iZXInXG5cdFx0XHQ/IGRlYm91bmNlXG5cdFx0XHQ6IGRlYm91bmNlLnNjcm9sbFxuXHRcdDogbnVsbDtcblx0Y29uc3QgcmVzaXplRGVib3VuY2UgPSBkZWJvdW5jZVxuXHRcdD8gdHlwZW9mIGRlYm91bmNlID09PSAnbnVtYmVyJ1xuXHRcdFx0PyBkZWJvdW5jZVxuXHRcdFx0OiBkZWJvdW5jZS5yZXNpemVcblx0XHQ6IG51bGw7XG5cblx0Y29uc3QgZGVib3VuY2VBbmRUb3JuZG93biA9IDxUPihcblx0XHRkZWJvdW5jZTogbnVtYmVyIHwgbnVsbCxcblx0KTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFQ+ID0+IHtcblx0XHRyZXR1cm4gcGlwZShkZWJvdW5jZVRpbWUoZGVib3VuY2UgPz8gMCksIHRha2VVbnRpbCh0b3JuZG93biQpKTtcblx0fTtcblxuXHRyZXR1cm4gbmV3IE9ic2VydmFibGU8UmVzaXplUmVzdWx0Pigoc3Vic2NyaWJlcikgPT4ge1xuXHRcdGlmICghaXNTdXBwb3J0KSB7XG5cdFx0XHRzdWJzY3JpYmVyLmVycm9yKFxuXHRcdFx0XHQnW25neC1yZXNpemVdIHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFJlc2l6ZU9ic2VydmVyLiBQbGVhc2UgY29uc2lkZXIgdXNpbmcgYSBwb2x5ZmlsbCcsXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuXHRcdFx0aWYgKGVtaXRJbml0aWFsUmVzdWx0KSB7XG5cdFx0XHRcdGNvbnN0IFtyZXN1bHRdID0gY2FsY3VsYXRlUmVzdWx0KG5hdGl2ZUVsZW1lbnQsIHdpbmRvdywgb2Zmc2V0U2l6ZSwgW10pO1xuXHRcdFx0XHRpZiAoZW1pdEluWm9uZSkgem9uZS5ydW4oKCkgPT4gdm9pZCBzdWJzY3JpYmVyLm5leHQocmVzdWx0KSk7XG5cdFx0XHRcdGVsc2Ugc3Vic2NyaWJlci5uZXh0KHJlc3VsdCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNhbGxiYWNrID0gKGVudHJpZXM6IFJlc2l6ZU9ic2VydmVyRW50cnlbXSkgPT4ge1xuXHRcdFx0XHRsYXN0RW50cmllcyA9IGVudHJpZXM7XG5cdFx0XHRcdGNvbnN0IFtyZXN1bHQsIHNpemVdID0gY2FsY3VsYXRlUmVzdWx0KFxuXHRcdFx0XHRcdG5hdGl2ZUVsZW1lbnQsXG5cdFx0XHRcdFx0d2luZG93LFxuXHRcdFx0XHRcdG9mZnNldFNpemUsXG5cdFx0XHRcdFx0ZW50cmllcyxcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoZW1pdEluWm9uZSkgem9uZS5ydW4oKCkgPT4gdm9pZCBzdWJzY3JpYmVyLm5leHQocmVzdWx0KSk7XG5cdFx0XHRcdGVsc2Ugc3Vic2NyaWJlci5uZXh0KHJlc3VsdCk7XG5cblx0XHRcdFx0aWYgKCFhcmVCb3VuZHNFcXVhbChsYXN0Qm91bmRzIHx8IHt9LCBzaXplKSkgbGFzdEJvdW5kcyA9IHNpemU7XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBib3VuZENhbGxiYWNrID0gKCkgPT4gdm9pZCBjYWxsYmFjayhsYXN0RW50cmllcyk7XG5cblx0XHRcdG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKTtcblxuXHRcdFx0b2JzZXJ2ZXIub2JzZXJ2ZShuYXRpdmVFbGVtZW50LCB7IGJveCB9KTtcblx0XHRcdGlmIChzY3JvbGwpIHtcblx0XHRcdFx0aWYgKHNjcm9sbENvbnRhaW5lcnMpIHtcblx0XHRcdFx0XHRzY3JvbGxDb250YWluZXJzLmZvckVhY2goKHNjcm9sbENvbnRhaW5lcikgPT4ge1xuXHRcdFx0XHRcdFx0ZnJvbUV2ZW50KHNjcm9sbENvbnRhaW5lciBhcyBIVE1MRWxlbWVudCwgJ3Njcm9sbCcsIHtcblx0XHRcdFx0XHRcdFx0Y2FwdHVyZTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0cGFzc2l2ZTogdHJ1ZSxcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdC5waXBlKGRlYm91bmNlQW5kVG9ybmRvd24oc2Nyb2xsRGVib3VuY2UpKVxuXHRcdFx0XHRcdFx0XHQuc3Vic2NyaWJlKGJvdW5kQ2FsbGJhY2spO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnJvbUV2ZW50KHdpbmRvdywgJ3Njcm9sbCcsIHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogdHJ1ZSB9KVxuXHRcdFx0XHRcdC5waXBlKGRlYm91bmNlQW5kVG9ybmRvd24oc2Nyb2xsRGVib3VuY2UpKVxuXHRcdFx0XHRcdC5zdWJzY3JpYmUoYm91bmRDYWxsYmFjayk7XG5cdFx0XHR9XG5cblx0XHRcdGZyb21FdmVudCh3aW5kb3csICdyZXNpemUnKVxuXHRcdFx0XHQucGlwZShkZWJvdW5jZUFuZFRvcm5kb3duKHJlc2l6ZURlYm91bmNlKSlcblx0XHRcdFx0LnN1YnNjcmliZShib3VuZENhbGxiYWNrKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRpZiAob2JzZXJ2ZXIpIHtcblx0XHRcdFx0b2JzZXJ2ZXIudW5vYnNlcnZlKG5hdGl2ZUVsZW1lbnQpO1xuXHRcdFx0XHRvYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cdFx0XHR9XG5cdFx0XHR0b3JuZG93biQubmV4dCgpO1xuXHRcdFx0dG9ybmRvd24kLmNvbXBsZXRlKCk7XG5cdFx0fTtcblx0fSkucGlwZShcblx0XHRkZWJvdW5jZVRpbWUoc2Nyb2xsRGVib3VuY2UgPz8gMCksXG5cdFx0c2hhcmUoeyBjb25uZWN0b3I6ICgpID0+IG5ldyBSZXBsYXlTdWJqZWN0KDEpIH0pLFxuXHQpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVSZXN1bHQoXG5cdG5hdGl2ZUVsZW1lbnQ6IEhUTUxFbGVtZW50LFxuXHR3aW5kb3c6IFdpbmRvdyxcblx0b2Zmc2V0U2l6ZTogYm9vbGVhbixcblx0ZW50cmllczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdLFxuKTogW1Jlc2l6ZVJlc3VsdCwgT21pdDxET01SZWN0LCAndG9KU09OJz5dIHtcblx0Y29uc3QgeyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIGJvdHRvbSwgcmlnaHQsIHgsIHkgfSA9XG5cdFx0bmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0Y29uc3Qgc2l6ZSA9IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LCBib3R0b20sIHJpZ2h0LCB4LCB5IH07XG5cblx0aWYgKG5hdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBvZmZzZXRTaXplKSB7XG5cdFx0c2l6ZS5oZWlnaHQgPSBuYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodDtcblx0XHRzaXplLndpZHRoID0gbmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcblx0fVxuXG5cdE9iamVjdC5mcmVlemUoc2l6ZSk7XG5cdHJldHVybiBbeyBlbnRyaWVzLCBkcHI6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAuLi5zaXplIH0sIHNpemVdO1xufVxuXG4vLyBSZXR1cm5zIGEgbGlzdCBvZiBzY3JvbGwgb2Zmc2V0c1xuZnVuY3Rpb24gZmluZFNjcm9sbENvbnRhaW5lcnMoXG5cdGVsZW1lbnQ6IEhUTUxPclNWR0VsZW1lbnQgfCBudWxsLFxuXHR3aW5kb3c6IFdpbmRvdyB8IG51bGwsXG5cdGRvY3VtZW50Qm9keTogSFRNTEVsZW1lbnQsXG4pOiBIVE1MT3JTVkdFbGVtZW50W10ge1xuXHRjb25zdCByZXN1bHQ6IEhUTUxPclNWR0VsZW1lbnRbXSA9IFtdO1xuXHRpZiAoIWVsZW1lbnQgfHwgIXdpbmRvdyB8fCBlbGVtZW50ID09PSBkb2N1bWVudEJvZHkpIHJldHVybiByZXN1bHQ7XG5cdGNvbnN0IHsgb3ZlcmZsb3csIG92ZXJmbG93WCwgb3ZlcmZsb3dZIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShcblx0XHRlbGVtZW50IGFzIEhUTUxFbGVtZW50LFxuXHQpO1xuXHRpZiAoXG5cdFx0W292ZXJmbG93LCBvdmVyZmxvd1gsIG92ZXJmbG93WV0uc29tZShcblx0XHRcdChwcm9wKSA9PiBwcm9wID09PSAnYXV0bycgfHwgcHJvcCA9PT0gJ3Njcm9sbCcsXG5cdFx0KVxuXHQpXG5cdFx0cmVzdWx0LnB1c2goZWxlbWVudCk7XG5cdHJldHVybiBbXG5cdFx0Li4ucmVzdWx0LFxuXHRcdC4uLmZpbmRTY3JvbGxDb250YWluZXJzKFxuXHRcdFx0KGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLnBhcmVudEVsZW1lbnQsXG5cdFx0XHR3aW5kb3csXG5cdFx0XHRkb2N1bWVudEJvZHksXG5cdFx0KSxcblx0XTtcbn1cblxuLy8gQ2hlY2tzIGlmIGVsZW1lbnQgYm91bmRhcmllcyBhcmUgZXF1YWxcbmNvbnN0IGtleXM6IChrZXlvZiBPbWl0PFJlc2l6ZVJlc3VsdCwgJ2VudHJpZXMnIHwgJ2Rwcic+KVtdID0gW1xuXHQneCcsXG5cdCd5Jyxcblx0J3RvcCcsXG5cdCdib3R0b20nLFxuXHQnbGVmdCcsXG5cdCdyaWdodCcsXG5cdCd3aWR0aCcsXG5cdCdoZWlnaHQnLFxuXTtcbmNvbnN0IGFyZUJvdW5kc0VxdWFsID0gKFxuXHRhOiBPbWl0PFJlc2l6ZVJlc3VsdCwgJ2VudHJpZXMnIHwgJ2Rwcic+LFxuXHRiOiBPbWl0PFJlc2l6ZVJlc3VsdCwgJ2VudHJpZXMnIHwgJ2Rwcic+LFxuKSA9PiBrZXlzLmV2ZXJ5KChrZXkpID0+IGFba2V5XSA9PT0gYltrZXldKTtcbiJdfQ==