import { DestroyRef, ENVIRONMENT_INITIALIZER, EnvironmentInjector, Injectable, createEnvironmentInjector, inject, } from '@angular/core';
import { defer } from 'rxjs';
import * as i0 from "@angular/core";
export class InjectLazyImpl {
    constructor() {
        this.overrides = new WeakMap(); // no need to clean up
    }
    override(type, mock) {
        this.overrides.set(type, mock);
    }
    get(injector, loader) {
        return defer(() => loader().then((serviceOrDefault) => {
            const type = 'default' in serviceOrDefault
                ? serviceOrDefault.default
                : serviceOrDefault;
            // Check if we have overrides, O(1), low overhead
            if (this.overrides.has(type)) {
                const module = this.overrides.get(type);
                return new module();
            }
            // If the service uses DestroyRef.onDestroy() it will never be called.
            // Even if injector is a NodeInjector, this works only with providedIn: root.
            // So it's the root injector that will provide the DestroyRef (and thus never call OnDestroy).
            // The solution would be to create an EnvironmentInjector that provides the class we just lazy-loaded.
            if (!(injector instanceof EnvironmentInjector)) {
                // We're passing a node injector to the function
                // This is the DestroyRef of the component
                const destroyRef = injector.get(DestroyRef);
                // This is the parent injector of the environmentInjector we're creating
                const environmentInjector = injector.get(EnvironmentInjector);
                // Creating an environment injector to destroy it afterward
                const newInjector = createEnvironmentInjector([type], environmentInjector);
                // Destroy the injector to trigger DestroyRef.onDestroy on our service
                destroyRef.onDestroy(() => newInjector.destroy());
                // We want to create the new instance of our service with our new injector
                injector = newInjector;
            }
            return injector.get(type);
        }));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: InjectLazyImpl, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: InjectLazyImpl, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: InjectLazyImpl, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
/**
 * Helper function to mock the lazy-loaded module in `injectAsync`
 *
 * @usage
 * TestBed.configureTestingModule({
 *   providers: [
 *     mockLazyProvider(SandboxService, fakeSandboxService)
 *   ]
 * });
 */
export function mockLazyProvider(type, mock) {
    return [
        {
            provide: ENVIRONMENT_INITIALIZER,
            multi: true,
            useValue: () => {
                inject(InjectLazyImpl).override(type, mock);
            },
        },
    ];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5qZWN0LWxhenktaW1wbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvbmd4dGVuc2lvbi9pbmplY3QtbGF6eS9zcmMvaW5qZWN0LWxhenktaW1wbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sVUFBVSxFQUNWLHVCQUF1QixFQUN2QixtQkFBbUIsRUFDbkIsVUFBVSxFQUdWLHlCQUF5QixFQUN6QixNQUFNLEdBR04sTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQzs7QUFVN0IsTUFBTSxPQUFPLGNBQWM7SUFEM0I7UUFFUyxjQUFTLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQyxDQUFDLHNCQUFzQjtLQWlEekQ7SUFoREEsUUFBUSxDQUFJLElBQWEsRUFBRSxJQUFtQjtRQUM3QyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVELEdBQUcsQ0FBQyxRQUFrQixFQUFFLE1BQTZCO1FBQ3BELE9BQU8sS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUNqQixNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFO1lBQ2xDLE1BQU0sSUFBSSxHQUNULFNBQVMsSUFBSSxnQkFBZ0I7Z0JBQzVCLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPO2dCQUMxQixDQUFDLENBQUMsZ0JBQWdCLENBQUM7WUFFckIsaURBQWlEO1lBQ2pELElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDOUIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3hDLE9BQU8sSUFBSSxNQUFNLEVBQUUsQ0FBQztZQUNyQixDQUFDO1lBRUQsc0VBQXNFO1lBQ3RFLDZFQUE2RTtZQUM3RSw4RkFBOEY7WUFDOUYsc0dBQXNHO1lBQ3RHLElBQUksQ0FBQyxDQUFDLFFBQVEsWUFBWSxtQkFBbUIsQ0FBQyxFQUFFLENBQUM7Z0JBQ2hELGdEQUFnRDtnQkFFaEQsMENBQTBDO2dCQUMxQyxNQUFNLFVBQVUsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUU1Qyx3RUFBd0U7Z0JBQ3hFLE1BQU0sbUJBQW1CLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO2dCQUU5RCwyREFBMkQ7Z0JBQzNELE1BQU0sV0FBVyxHQUFHLHlCQUF5QixDQUM1QyxDQUFDLElBQWdCLENBQUMsRUFDbEIsbUJBQW1CLENBQ25CLENBQUM7Z0JBRUYsc0VBQXNFO2dCQUN0RSxVQUFVLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2dCQUVsRCwwRUFBMEU7Z0JBQzFFLFFBQVEsR0FBRyxXQUFXLENBQUM7WUFDeEIsQ0FBQztZQUVELE9BQU8sUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUUsQ0FBQztRQUM1QixDQUFDLENBQUMsQ0FDRixDQUFDO0lBQ0gsQ0FBQzs4R0FqRFcsY0FBYztrSEFBZCxjQUFjLGNBREQsTUFBTTs7MkZBQ25CLGNBQWM7a0JBRDFCLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFOztBQXFEbEM7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxVQUFVLGdCQUFnQixDQUFJLElBQWEsRUFBRSxJQUFtQjtJQUNyRSxPQUFPO1FBQ047WUFDQyxPQUFPLEVBQUUsdUJBQXVCO1lBQ2hDLEtBQUssRUFBRSxJQUFJO1lBQ1gsUUFBUSxFQUFFLEdBQUcsRUFBRTtnQkFDZCxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztZQUM3QyxDQUFDO1NBQ0Q7S0FDRCxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdERlc3Ryb3lSZWYsXG5cdEVOVklST05NRU5UX0lOSVRJQUxJWkVSLFxuXHRFbnZpcm9ubWVudEluamVjdG9yLFxuXHRJbmplY3RhYmxlLFxuXHRJbmplY3Rvcixcblx0VHlwZSxcblx0Y3JlYXRlRW52aXJvbm1lbnRJbmplY3Rvcixcblx0aW5qZWN0LFxuXHR0eXBlIFByb3ZpZGVyLFxuXHR0eXBlIFByb3ZpZGVyVG9rZW4sXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWZlciB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIExhenkgaW1wb3J0IHR5cGUgdGhhdCBpbmNsdWRlcyBkZWZhdWx0IGFuZCBub3JtYWwgaW1wb3J0c1xuICovXG5leHBvcnQgdHlwZSBMYXp5SW1wb3J0TG9hZGVyRm48VD4gPSAoKSA9PlxuXHR8IFByb21pc2U8UHJvdmlkZXJUb2tlbjxUPj5cblx0fCBQcm9taXNlPHsgZGVmYXVsdDogUHJvdmlkZXJUb2tlbjxUPiB9PjtcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBJbmplY3RMYXp5SW1wbDxUPiB7XG5cdHByaXZhdGUgb3ZlcnJpZGVzID0gbmV3IFdlYWtNYXAoKTsgLy8gbm8gbmVlZCB0byBjbGVhbiB1cFxuXHRvdmVycmlkZTxUPih0eXBlOiBUeXBlPFQ+LCBtb2NrOiBUeXBlPHVua25vd24+KSB7XG5cdFx0dGhpcy5vdmVycmlkZXMuc2V0KHR5cGUsIG1vY2spO1xuXHR9XG5cblx0Z2V0KGluamVjdG9yOiBJbmplY3RvciwgbG9hZGVyOiBMYXp5SW1wb3J0TG9hZGVyRm48VD4pOiBPYnNlcnZhYmxlPFQ+IHtcblx0XHRyZXR1cm4gZGVmZXIoKCkgPT5cblx0XHRcdGxvYWRlcigpLnRoZW4oKHNlcnZpY2VPckRlZmF1bHQpID0+IHtcblx0XHRcdFx0Y29uc3QgdHlwZSA9XG5cdFx0XHRcdFx0J2RlZmF1bHQnIGluIHNlcnZpY2VPckRlZmF1bHRcblx0XHRcdFx0XHRcdD8gc2VydmljZU9yRGVmYXVsdC5kZWZhdWx0XG5cdFx0XHRcdFx0XHQ6IHNlcnZpY2VPckRlZmF1bHQ7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgaGF2ZSBvdmVycmlkZXMsIE8oMSksIGxvdyBvdmVyaGVhZFxuXHRcdFx0XHRpZiAodGhpcy5vdmVycmlkZXMuaGFzKHR5cGUpKSB7XG5cdFx0XHRcdFx0Y29uc3QgbW9kdWxlID0gdGhpcy5vdmVycmlkZXMuZ2V0KHR5cGUpO1xuXHRcdFx0XHRcdHJldHVybiBuZXcgbW9kdWxlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgc2VydmljZSB1c2VzIERlc3Ryb3lSZWYub25EZXN0cm95KCkgaXQgd2lsbCBuZXZlciBiZSBjYWxsZWQuXG5cdFx0XHRcdC8vIEV2ZW4gaWYgaW5qZWN0b3IgaXMgYSBOb2RlSW5qZWN0b3IsIHRoaXMgd29ya3Mgb25seSB3aXRoIHByb3ZpZGVkSW46IHJvb3QuXG5cdFx0XHRcdC8vIFNvIGl0J3MgdGhlIHJvb3QgaW5qZWN0b3IgdGhhdCB3aWxsIHByb3ZpZGUgdGhlIERlc3Ryb3lSZWYgKGFuZCB0aHVzIG5ldmVyIGNhbGwgT25EZXN0cm95KS5cblx0XHRcdFx0Ly8gVGhlIHNvbHV0aW9uIHdvdWxkIGJlIHRvIGNyZWF0ZSBhbiBFbnZpcm9ubWVudEluamVjdG9yIHRoYXQgcHJvdmlkZXMgdGhlIGNsYXNzIHdlIGp1c3QgbGF6eS1sb2FkZWQuXG5cdFx0XHRcdGlmICghKGluamVjdG9yIGluc3RhbmNlb2YgRW52aXJvbm1lbnRJbmplY3RvcikpIHtcblx0XHRcdFx0XHQvLyBXZSdyZSBwYXNzaW5nIGEgbm9kZSBpbmplY3RvciB0byB0aGUgZnVuY3Rpb25cblxuXHRcdFx0XHRcdC8vIFRoaXMgaXMgdGhlIERlc3Ryb3lSZWYgb2YgdGhlIGNvbXBvbmVudFxuXHRcdFx0XHRcdGNvbnN0IGRlc3Ryb3lSZWYgPSBpbmplY3Rvci5nZXQoRGVzdHJveVJlZik7XG5cblx0XHRcdFx0XHQvLyBUaGlzIGlzIHRoZSBwYXJlbnQgaW5qZWN0b3Igb2YgdGhlIGVudmlyb25tZW50SW5qZWN0b3Igd2UncmUgY3JlYXRpbmdcblx0XHRcdFx0XHRjb25zdCBlbnZpcm9ubWVudEluamVjdG9yID0gaW5qZWN0b3IuZ2V0KEVudmlyb25tZW50SW5qZWN0b3IpO1xuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRpbmcgYW4gZW52aXJvbm1lbnQgaW5qZWN0b3IgdG8gZGVzdHJveSBpdCBhZnRlcndhcmRcblx0XHRcdFx0XHRjb25zdCBuZXdJbmplY3RvciA9IGNyZWF0ZUVudmlyb25tZW50SW5qZWN0b3IoXG5cdFx0XHRcdFx0XHRbdHlwZSBhcyBQcm92aWRlcl0sXG5cdFx0XHRcdFx0XHRlbnZpcm9ubWVudEluamVjdG9yLFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBEZXN0cm95IHRoZSBpbmplY3RvciB0byB0cmlnZ2VyIERlc3Ryb3lSZWYub25EZXN0cm95IG9uIG91ciBzZXJ2aWNlXG5cdFx0XHRcdFx0ZGVzdHJveVJlZi5vbkRlc3Ryb3koKCkgPT4gbmV3SW5qZWN0b3IuZGVzdHJveSgpKTtcblxuXHRcdFx0XHRcdC8vIFdlIHdhbnQgdG8gY3JlYXRlIHRoZSBuZXcgaW5zdGFuY2Ugb2Ygb3VyIHNlcnZpY2Ugd2l0aCBvdXIgbmV3IGluamVjdG9yXG5cdFx0XHRcdFx0aW5qZWN0b3IgPSBuZXdJbmplY3Rvcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBpbmplY3Rvci5nZXQodHlwZSkhO1xuXHRcdFx0fSksXG5cdFx0KTtcblx0fVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBtb2NrIHRoZSBsYXp5LWxvYWRlZCBtb2R1bGUgaW4gYGluamVjdEFzeW5jYFxuICpcbiAqIEB1c2FnZVxuICogVGVzdEJlZC5jb25maWd1cmVUZXN0aW5nTW9kdWxlKHtcbiAqICAgcHJvdmlkZXJzOiBbXG4gKiAgICAgbW9ja0xhenlQcm92aWRlcihTYW5kYm94U2VydmljZSwgZmFrZVNhbmRib3hTZXJ2aWNlKVxuICogICBdXG4gKiB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vY2tMYXp5UHJvdmlkZXI8VD4odHlwZTogVHlwZTxUPiwgbW9jazogVHlwZTx1bmtub3duPikge1xuXHRyZXR1cm4gW1xuXHRcdHtcblx0XHRcdHByb3ZpZGU6IEVOVklST05NRU5UX0lOSVRJQUxJWkVSLFxuXHRcdFx0bXVsdGk6IHRydWUsXG5cdFx0XHR1c2VWYWx1ZTogKCkgPT4ge1xuXHRcdFx0XHRpbmplY3QoSW5qZWN0TGF6eUltcGwpLm92ZXJyaWRlKHR5cGUsIG1vY2spO1xuXHRcdFx0fSxcblx0XHR9LFxuXHRdO1xufVxuIl19