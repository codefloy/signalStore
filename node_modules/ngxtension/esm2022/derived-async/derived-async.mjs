import { DestroyRef, computed, effect, inject, signal, untracked, } from '@angular/core';
import { assertInjector } from 'ngxtension/assert-injector';
import { Subject, concatAll, exhaustAll, isObservable, mergeAll, switchAll, } from 'rxjs';
export function derivedAsync(computation, options = {}) {
    return assertInjector(derivedAsync, options?.injector, () => {
        const destroyRef = inject(DestroyRef);
        // source$ is a Subject that will emit the new source value
        const sourceEvent$ = new Subject();
        // enhance the sourceEvent$ with the behavior
        const source$ = createFlattenObservable(sourceEvent$, options?.behavior ?? 'switch');
        const sourceResult = source$.subscribe({
            next: (value) => sourceValue.set({ kind: 1 /* StateKind.Value */, value }),
            // NOTE: Error should be handled by the user (using catchError or .catch())
            error: (error) => sourceValue.set({ kind: 2 /* StateKind.Error */, error }),
        });
        // we need to unsubscribe the sourceResult when the context gets destroyed
        destroyRef.onDestroy(() => sourceResult.unsubscribe());
        // sourceValue is a signal that will hold the current value and the state of the value
        let sourceValue;
        if (options?.requireSync && options?.initialValue === undefined) {
            const initialCmp = computation(undefined);
            // we don't support promises with requireSync and no initialValue also the typings don't allow this case
            if (isPromise(initialCmp)) {
                throw new Error(REQUIRE_SYNC_PROMISE_MESSAGE);
            }
            sourceValue = signal({ kind: 0 /* StateKind.NoValue */ });
            if (isObservable(initialCmp)) {
                sourceEvent$.next(initialCmp);
            }
            else {
                sourceValue.set({ kind: 1 /* StateKind.Value */, value: initialCmp });
            }
        }
        else {
            sourceValue = signal({
                kind: 1 /* StateKind.Value */,
                value: options?.initialValue,
            });
        }
        if (options?.requireSync && sourceValue().kind === 0 /* StateKind.NoValue */) {
            throw new Error(REQUIRE_SYNC_ERROR_MESSAGE);
        }
        let skipFirstComputation = options?.requireSync === true;
        // effect runs inside injection context, so it will be cleanup up when context gets destroyed
        effect(() => {
            // we need to have an untracked() here because we don't want to register the sourceValue as a dependency
            // otherwise, we would have an infinite loop.
            // this is needed for previousValue feature to work
            const currentValue = untracked(() => {
                const currentSourceValue = sourceValue();
                return currentSourceValue.kind === 1 /* StateKind.Value */
                    ? currentSourceValue.value
                    : undefined;
            });
            const newSource = computation(currentValue);
            // we need to skip the first computation if requireSync is true
            // because we already computed the value in the previous step
            if (skipFirstComputation) {
                skipFirstComputation = false;
                return;
            }
            if (isObservable(newSource) || isPromise(newSource)) {
                // we untrack the source$.next() so that we don't register other signals as dependencies
                untracked(() => sourceEvent$.next(newSource));
            }
            else {
                // if the new source is not an observable or a promise, we set the value immediately
                untracked(() => sourceValue.set({ kind: 1 /* StateKind.Value */, value: newSource }));
            }
        });
        // we return a computed value that will return the current value
        // in order to support the same API as computed()
        return computed(() => {
            const state = sourceValue();
            switch (state.kind) {
                case 1 /* StateKind.Value */:
                    return state.value;
                case 2 /* StateKind.Error */:
                    throw state.error;
                case 0 /* StateKind.NoValue */:
                    // we already throw an error if requireSync is true and there is no initialValue,
                    // so we don't need to throw an error here
                    return;
                default:
                    // we should never reach this case
                    throw new Error('Unknown state');
            }
        }, { equal: options?.equal });
    });
}
const REQUIRE_SYNC_PROMISE_MESSAGE = `Promises cannot be used with requireSync. Pass an initialValue or set requireSync to false.`;
const REQUIRE_SYNC_ERROR_MESSAGE = `The observable passed to derivedAsync() did not emit synchronously. Pass an initialValue or set requireSync to false.`;
function createFlattenObservable(source, behavior) {
    const KEY_OPERATOR_MAP = {
        merge: mergeAll,
        concat: concatAll,
        exhaust: exhaustAll,
        switch: switchAll,
    };
    return source.pipe(KEY_OPERATOR_MAP[behavior]());
}
function isPromise(value) {
    return value && typeof value.then === 'function';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVyaXZlZC1hc3luYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvbmd4dGVuc2lvbi9kZXJpdmVkLWFzeW5jL3NyYy9kZXJpdmVkLWFzeW5jLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTixVQUFVLEVBRVYsUUFBUSxFQUNSLE1BQU0sRUFDTixNQUFNLEVBQ04sTUFBTSxFQUNOLFNBQVMsR0FJVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDNUQsT0FBTyxFQUVOLE9BQU8sRUFDUCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixRQUFRLEVBQ1IsU0FBUyxHQUNULE1BQU0sTUFBTSxDQUFDO0FBd0tkLE1BQU0sVUFBVSxZQUFZLENBQzNCLFdBRStDLEVBQy9DLFVBQWUsRUFBRTtJQUVqQixPQUFPLGNBQWMsQ0FBQyxZQUFZLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUU7UUFDM0QsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRXRDLDJEQUEyRDtRQUMzRCxNQUFNLFlBQVksR0FBRyxJQUFJLE9BQU8sRUFBOEIsQ0FBQztRQUUvRCw2Q0FBNkM7UUFDN0MsTUFBTSxPQUFPLEdBQWtCLHVCQUF1QixDQUNyRCxZQUFZLEVBQ1osT0FBTyxFQUFFLFFBQVEsSUFBSSxRQUFRLENBQzdCLENBQUM7UUFFRixNQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDO1lBQ3RDLElBQUksRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUkseUJBQWlCLEVBQUUsS0FBSyxFQUFFLENBQUM7WUFDbEUsMkVBQTJFO1lBQzNFLEtBQUssRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxF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QUFJLEVBQUUsQ0FBQztnQkFDcEI7b0JBQ0MsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDO2dCQUNwQjtvQkFDQyxNQUFNLEtBQUssQ0FBQyxLQUFLLENBQUM7Z0JBQ25CO29CQUNDLGlGQUFpRjtvQkFDakYsMENBQTBDO29CQUMxQyxPQUFPO2dCQUNSO29CQUNDLGtDQUFrQztvQkFDbEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUNuQyxDQUFDO1FBQ0YsQ0FBQyxFQUNELEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FDekIsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVELE1BQU0sNEJBQTRCLEdBQUcsNkZBQTZGLENBQUM7QUFDbkksTUFBTSwwQkFBMEIsR0FBRyx1SEFBdUgsQ0FBQztBQUUzSixTQUFTLHVCQUF1QixDQUMvQixNQUEyQyxFQUMzQyxRQUE4QjtJQUU5QixNQUFNLGdCQUFnQixHQUFHO1FBQ3hCLEtBQUssRUFBRSxRQUFRO1FBQ2YsTUFBTSxFQUFFLFNBQVM7UUFDakIsT0FBTyxFQUFFLFVBQVU7UUFDbkIsTUFBTSxFQUFFLFNBQVM7S0FDakIsQ0FBQztJQUVGLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDbEQsQ0FBQztBQUVELFNBQVMsU0FBUyxDQUFJLEtBQVU7SUFDL0IsT0FBTyxLQUFLLElBQUksT0FBTyxLQUFLLENBQUMsSUFBSSxLQUFLLFVBQVUsQ0FBQztBQUNsRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0RGVzdHJveVJlZixcblx0SW5qZWN0b3IsXG5cdGNvbXB1dGVkLFxuXHRlZmZlY3QsXG5cdGluamVjdCxcblx0c2lnbmFsLFxuXHR1bnRyYWNrZWQsXG5cdHR5cGUgQ3JlYXRlQ29tcHV0ZWRPcHRpb25zLFxuXHR0eXBlIFNpZ25hbCxcblx0dHlwZSBXcml0YWJsZVNpZ25hbCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBhc3NlcnRJbmplY3RvciB9IGZyb20gJ25neHRlbnNpb24vYXNzZXJ0LWluamVjdG9yJztcbmltcG9ydCB7XG5cdE9ic2VydmFibGUsXG5cdFN1YmplY3QsXG5cdGNvbmNhdEFsbCxcblx0ZXhoYXVzdEFsbCxcblx0aXNPYnNlcnZhYmxlLFxuXHRtZXJnZUFsbCxcblx0c3dpdGNoQWxsLFxufSBmcm9tICdyeGpzJztcblxudHlwZSBkZXJpdmVkQXN5bmNCZWhhdmlvciA9ICdzd2l0Y2gnIHwgJ21lcmdlJyB8ICdjb25jYXQnIHwgJ2V4aGF1c3QnO1xuXG5pbnRlcmZhY2UgZGVyaXZlZEFzeW5jT3B0aW9uczxUPiBleHRlbmRzIENyZWF0ZUNvbXB1dGVkT3B0aW9uczxUPiB7XG5cdGluamVjdG9yPzogSW5qZWN0b3I7XG5cdGJlaGF2aW9yPzogZGVyaXZlZEFzeW5jQmVoYXZpb3I7XG59XG5cbnR5cGUgT3B0aW9uc1dpdGhJbml0aWFsVmFsdWU8VD4gPSB7IGluaXRpYWxWYWx1ZTogVCB9ICYgZGVyaXZlZEFzeW5jT3B0aW9uczxUPjtcbnR5cGUgT3B0aW9uc1dpdGhPcHRpb25hbEluaXRpYWxWYWx1ZTxUPiA9IHtcblx0aW5pdGlhbFZhbHVlPzogdW5kZWZpbmVkO1xufSAmIGRlcml2ZWRBc3luY09wdGlvbnM8VD47XG50eXBlIE9wdGlvbnNXaXRoUmVxdWlyZVN5bmM8VD4gPSB7XG5cdHJlcXVpcmVTeW5jOiB0cnVlO1xufSAmIGRlcml2ZWRBc3luY09wdGlvbnM8VD47XG5cbnR5cGUgT2JzZXJ2YWJsZUNvbXB1dGF0aW9uPFQ+ID0gKFxuXHRwcmV2aW91c1ZhbHVlPzogVCB8IHVuZGVmaW5lZCxcbikgPT4gT2JzZXJ2YWJsZTxUPiB8IFQ7XG5cbnR5cGUgUHJvbWlzZUNvbXB1dGF0aW9uPFQ+ID0gKHByZXZpb3VzVmFsdWU/OiBUIHwgdW5kZWZpbmVkKSA9PiBQcm9taXNlPFQ+IHwgVDtcblxuLyoqXG4gKiBBIGNvbXB1dGVkIHZhbHVlIHRoYXQgY2FuIGJlIGFzeW5jISBUaGlzIGlzIHVzZWZ1bCBmb3Igd2hlbiB5b3UgbmVlZCB0byBjb21wdXRlIGEgdmFsdWUgYmFzZWQgb24gYSBQcm9taXNlIG9yIE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCB2YWx1ZSA9IGRlcml2ZWRBc3luYygoKSA9PlxuICogICBmZXRjaChgaHR0cHM6Ly9sb2NhbGhvc3QvYXBpL3Blb3BsZS8ke3RoaXMudXNlcklkKCl9YCkudGhlbihyID0+IHIuanNvbigpKVxuICogKTtcbiAqIGBgYFxuICpcbiAqIFRoZSBjb21wdXRlZCB2YWx1ZSB3aWxsIGJlIGB1bmRlZmluZWRgIHVudGlsIHRoZSBwcm9taXNlIHJlc29sdmVzLlxuICogRXZlcnl0aW1lIHRoZSB1c2VySWQgY2hhbmdlcywgdGhlIGZldGNoIHdpbGwgYmUgY2FsbGVkIGFnYWluLCBhbmQgdGhlIHByZXZpb3VzIGZldGNoIHdpbGwgYmUgY2FuY2VsbGVkIChpdCB1c2VzIHN3aXRjaE1hcCBieSBkZWZhdWx0KS5cbiAqIElmIHRoZSBwcm9taXNlIHJlamVjdHMsIHRoZSBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBJdCBjYW4gYWxzbyBiZSB1c2VkIHdpdGggT2JzZXJ2YWJsZXM6XG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHZhbHVlID0gZGVyaXZlZEFzeW5jKCgpID0+XG4gKiAgdGhpcy5odHRwLmdldChgaHR0cHM6Ly9sb2NhbGhvc3QvYXBpL3Blb3BsZS8ke3RoaXMudXNlcklkKCl9YClcbiAqICk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBgaW5pdGlhbFZhbHVlYCBvcHRpb24gdG8gc2V0IHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBjb21wdXRlZCB2YWx1ZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgdXNlclRhc2tzID0gZGVyaXZlZEFzeW5jKCgpID0+XG4gKiAgIHRoaXMuaHR0cC5nZXQoYGh0dHBzOi8vbG9jYWxob3N0L2FwaS90YXNrcz91c2VySWQ9JHt0aGlzLnVzZXJJZCgpfWApLFxuICogICB7IGluaXRpYWxWYWx1ZTogW10gfVxuICogKTtcbiAqIGBgYFxuICpcbiAqIElmIHlvdSB3YW50IHRvIHJlcXVpcmUgdGhhdCB0aGUgb2JzZXJ2YWJsZSBlbWl0cyBzeW5jaHJvbm91c2x5IHdoZW4gYGRlcml2ZWRBc3luY2Agc3Vic2NyaWJlcywgeW91IGNhbiBzZXQgdGhlIGByZXF1aXJlU3luY2Agb3B0aW9uIHRvIGB0cnVlYC5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgdXNlclRhc2tzID0gZGVyaXZlZEFzeW5jKCgpID0+XG4gKiAgIHRoaXMuaHR0cC5nZXQoYGh0dHBzOi8vbG9jYWxob3N0L2FwaS90YXNrcz91c2VySWQ9JHt0aGlzLnVzZXJJZCgpfWApLnBpcGUoXG4gKiBcdCAgIHN0YXJ0V2l0aChbXSksXG4gKiAgICksXG4gKiAgIHsgcmVxdWlyZVN5bmM6IHRydWUgfVxuICogKTtcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhIGBiZWhhdmlvcmAgb3B0aW9uIHRvIGNoYW5nZSB0aGUgYmVoYXZpb3Igb2YgdGhlIGNvbXB1dGVkIHZhbHVlLlxuICogLSBgc3dpdGNoYCAoZGVmYXVsdCk6IHdpbGwgY2FuY2VsIHRoZSBwcmV2aW91cyBjb21wdXRhdGlvbiB3aGVuIGEgbmV3IG9uZSBpcyB0cmlnZ2VyZWRcbiAqIC0gYG1lcmdlYDogd2lsbCB1c2UgYG1lcmdlTWFwYCB0byBtZXJnZSB0aGUgbGFzdCBvYnNlcnZhYmxlIHdpdGggdGhlIG5ldyBvbmVcbiAqIC0gYGNvbmNhdGA6IHdpbGwgdXNlIGBjb25jYXRNYXBgIHRvIGNvbmNhdCB0aGUgbGFzdCBvYnNlcnZhYmxlIHdpdGggdGhlIG5ldyBvbmVcbiAqIC0gYGV4aGF1c3RgOiB3aWxsIHVzZSBgZXhoYXVzdE1hcGAgdG8gc2tpcCBhbGwgdGhlIG5ldyBlbWlzc2lvbnMgdW50aWwgdGhlIGxhc3Qgb2JzZXJ2YWJsZSBjb21wbGV0ZXNcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBgaW5qZWN0b3JgIG9wdGlvbiBpZiB5b3Ugd2FudCB0byB1c2UgaXQgb3V0c2lkZSBvZiB0aGUgaW5qZWN0aW9uIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIGNvbXB1dGF0aW9uXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5cbi8vIEJhc2UgQ2FzZSAtPiBJbml0aWFsIFZhbHVlOiB1bmRlZmluZWQgfCBSZXF1aXJlIFN5bmM6IHVuZGVmaW5lZCAgLT4gIFQgfCB1bmRlZmluZWRcbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkQXN5bmM8VD4oXG5cdGNvbXB1dGF0aW9uOiAoXG5cdFx0cHJldmlvdXNWYWx1ZT86IFQgfCB1bmRlZmluZWQsXG5cdCkgPT4gUHJvbWlzZTxUPiB8IE9ic2VydmFibGU8VD4gfCBUIHwgdW5kZWZpbmVkLFxuKTogU2lnbmFsPFQgfCB1bmRlZmluZWQ+O1xuXG4vKlxuICogUHJvbWlzZSBUeXBlc1xuICovXG5cbi8vIEluaXRpYWwgVmFsdWU6IHVuZGVmaW5lZCAgLT4gIFQgfCB1bmRlZmluZWRcbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkQXN5bmM8VD4oXG5cdGNvbXB1dGF0aW9uOiAoXG5cdFx0cHJldmlvdXNWYWx1ZT86IFQgfCB1bmRlZmluZWQsXG5cdCkgPT4gT2JzZXJ2YWJsZTxUPiB8IFByb21pc2U8VD4gfCBUIHwgdW5kZWZpbmVkLFxuXHRvcHRpb25zOiBPcHRpb25zV2l0aE9wdGlvbmFsSW5pdGlhbFZhbHVlPFQ+LFxuKTogU2lnbmFsPFQgfCB1bmRlZmluZWQ+O1xuXG4vLyBJbml0aWFsIFZhbHVlOiBUIHwgbnVsbCAgLT4gIFQgfCBudWxsXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZEFzeW5jPFQ+KFxuXHRjb21wdXRhdGlvbjogUHJvbWlzZUNvbXB1dGF0aW9uPFQ+LFxuXHRvcHRpb25zOiB7IGluaXRpYWxWYWx1ZT86IG51bGwgfSAmIGRlcml2ZWRBc3luY09wdGlvbnM8VD4sXG4pOiBTaWduYWw8VCB8IG51bGw+O1xuXG4vLyBJbml0aWFsIFZhbHVlOiBUICAtPiAgVFxuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWRBc3luYzxUPihcblx0Y29tcHV0YXRpb246IFByb21pc2VDb21wdXRhdGlvbjxUPixcblx0b3B0aW9uczogT3B0aW9uc1dpdGhJbml0aWFsVmFsdWU8VD4sXG4pOiBTaWduYWw8VD47XG5cbi8vIFJlcXVpcmUgU3luYzogdHJ1ZSAgLT4gIG5ldmVyXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZEFzeW5jPFQ+KFxuXHRjb21wdXRhdGlvbjogKHByZXZpb3VzVmFsdWU/OiBUIHwgdW5kZWZpbmVkKSA9PiBQcm9taXNlPFQ+LFxuXHRvcHRpb25zOiBPcHRpb25zV2l0aE9wdGlvbmFsSW5pdGlhbFZhbHVlPFQ+ICYge1xuXHRcdC8qKlxuXHRcdCAqIEB0aHJvd3MgQmVjYXVzZSB0aGUgcHJvbWlzZSB3aWxsIG5vdCByZXNvbHZlIHN5bmNocm9ub3VzbHkuXG5cdFx0ICovXG5cdFx0cmVxdWlyZVN5bmM6IHRydWU7XG5cdH0sXG4pOiBuZXZlcjtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWRBc3luYzxUPihcblx0Y29tcHV0YXRpb246IChwcmV2aW91c1ZhbHVlPzogVCB8IHVuZGVmaW5lZCkgPT4gUHJvbWlzZTxUPixcblx0b3B0aW9uczogT3B0aW9uc1dpdGhJbml0aWFsVmFsdWU8VD4gJiB7XG5cdFx0LyoqXG5cdFx0ICogQHRocm93cyBCZWNhdXNlIHRoZSBwcm9taXNlIHdpbGwgbm90IHJlc29sdmUgc3luY2hyb25vdXNseS5cblx0XHQgKi9cblx0XHRyZXF1aXJlU3luYzogdHJ1ZTtcblx0fSxcbik6IG5ldmVyO1xuXG4vKlxuICogT2JzZXJ2YWJsZSBUeXBlc1xuICovXG5cbi8vIEluaXRpYWwgVmFsdWU6IHVuZGVmaW5lZCB8IFJlcXVpcmUgU3luYzogZmFsc2UgIC0+ICBUIHwgdW5kZWZpbmVkXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZEFzeW5jPFQ+KFxuXHRjb21wdXRhdGlvbjogKHByZXZpb3VzVmFsdWU/OiBUIHwgdW5kZWZpbmVkKSA9PiBPYnNlcnZhYmxlPFQ+IHwgVCB8IHVuZGVmaW5lZCxcblx0b3B0aW9uczoge1xuXHRcdGluaXRpYWxWYWx1ZT86IHVuZGVmaW5lZDtcblx0XHRyZXF1aXJlU3luYz86IGZhbHNlO1xuXHR9ICYgZGVyaXZlZEFzeW5jT3B0aW9uczxUPixcbik6IFNpZ25hbDxUIHwgdW5kZWZpbmVkPjtcblxuLy8gSW5pdGlhbCBWYWx1ZTogbnVsbCB8IFJlcXVpcmUgU3luYzogZmFsc2UgIC0+ICBUIHwgbnVsbFxuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWRBc3luYzxUPihcblx0Y29tcHV0YXRpb246IE9ic2VydmFibGVDb21wdXRhdGlvbjxUPixcblx0b3B0aW9uczoge1xuXHRcdGluaXRpYWxWYWx1ZT86IG51bGw7XG5cdFx0cmVxdWlyZVN5bmM/OiBmYWxzZTtcblx0fSAmIGRlcml2ZWRBc3luY09wdGlvbnM8VD4sXG4pOiBTaWduYWw8VCB8IG51bGw+O1xuXG4vLyBJbml0aWFsIFZhbHVlOiB1bmRlZmluZWQgfCBSZXF1aXJlIFN5bmM6IHRydWUgIC0+ICBUXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZEFzeW5jPFQ+KFxuXHRjb21wdXRhdGlvbjogT2JzZXJ2YWJsZUNvbXB1dGF0aW9uPFQ+LFxuXHRvcHRpb25zOiBPcHRpb25zV2l0aFJlcXVpcmVTeW5jPFQ+ICYgeyBpbml0aWFsVmFsdWU/OiB1bmRlZmluZWQgfSxcbik6IFNpZ25hbDxUPjtcblxuLy8gSW5pdGlhbCBWYWx1ZTogVCB8IFJlcXVpcmUgU3luYzogdHJ1ZSAgLT4gIFRcbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkQXN5bmM8VD4oXG5cdGNvbXB1dGF0aW9uOiBPYnNlcnZhYmxlQ29tcHV0YXRpb248VD4sXG5cdG9wdGlvbnM6IE9wdGlvbnNXaXRoUmVxdWlyZVN5bmM8VD4gJiB7IGluaXRpYWxWYWx1ZTogVCB9LFxuKTogU2lnbmFsPFQ+O1xuXG4vLyBJbml0aWFsIFZhbHVlOiBUIHwgUmVxdWlyZSBTeW5jOiBmYWxzZSB8IHVuZGVmaW5lZCAgLT4gIFRcbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkQXN5bmM8VD4oXG5cdGNvbXB1dGF0aW9uOiBPYnNlcnZhYmxlQ29tcHV0YXRpb248VD4sXG5cdG9wdGlvbnM6IE9wdGlvbnNXaXRoSW5pdGlhbFZhbHVlPFQ+LFxuKTogU2lnbmFsPFQ+O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZEFzeW5jPFQ+KFxuXHRjb21wdXRhdGlvbjogKFxuXHRcdHByZXZpb3VzVmFsdWU/OiBUIHwgdW5kZWZpbmVkLFxuXHQpID0+IFByb21pc2U8VD4gfCBPYnNlcnZhYmxlPFQ+IHwgVCB8IHVuZGVmaW5lZCxcblx0b3B0aW9uczogYW55ID0ge30sXG4pOiBTaWduYWw8VCB8IHVuZGVmaW5lZD4ge1xuXHRyZXR1cm4gYXNzZXJ0SW5qZWN0b3IoZGVyaXZlZEFzeW5jLCBvcHRpb25zPy5pbmplY3RvciwgKCkgPT4ge1xuXHRcdGNvbnN0IGRlc3Ryb3lSZWYgPSBpbmplY3QoRGVzdHJveVJlZik7XG5cblx0XHQvLyBzb3VyY2UkIGlzIGEgU3ViamVjdCB0aGF0IHdpbGwgZW1pdCB0aGUgbmV3IHNvdXJjZSB2YWx1ZVxuXHRcdGNvbnN0IHNvdXJjZUV2ZW50JCA9IG5ldyBTdWJqZWN0PFByb21pc2U8VD4gfCBPYnNlcnZhYmxlPFQ+PigpO1xuXG5cdFx0Ly8gZW5oYW5jZSB0aGUgc291cmNlRXZlbnQkIHdpdGggdGhlIGJlaGF2aW9yXG5cdFx0Y29uc3Qgc291cmNlJDogT2JzZXJ2YWJsZTxUPiA9IGNyZWF0ZUZsYXR0ZW5PYnNlcnZhYmxlKFxuXHRcdFx0c291cmNlRXZlbnQkLFxuXHRcdFx0b3B0aW9ucz8uYmVoYXZpb3IgPz8gJ3N3aXRjaCcsXG5cdFx0KTtcblxuXHRcdGNvbnN0IHNvdXJjZVJlc3VsdCA9IHNvdXJjZSQuc3Vic2NyaWJlKHtcblx0XHRcdG5leHQ6ICh2YWx1ZSkgPT4gc291cmNlVmFsdWUuc2V0KHsga2luZDogU3RhdGVLaW5kLlZhbHVlLCB2YWx1ZSB9KSxcblx0XHRcdC8vIE5PVEU6IEVycm9yIHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSB1c2VyICh1c2luZyBjYXRjaEVycm9yIG9yIC5jYXRjaCgpKVxuXHRcdFx0ZXJyb3I6IChlcnJvcikgPT4gc291cmNlVmFsdWUuc2V0KHsga2luZDogU3RhdGVLaW5kLkVycm9yLCBlcnJvciB9KSxcblx0XHR9KTtcblxuXHRcdC8vIHdlIG5lZWQgdG8gdW5zdWJzY3JpYmUgdGhlIHNvdXJjZVJlc3VsdCB3aGVuIHRoZSBjb250ZXh0IGdldHMgZGVzdHJveWVkXG5cdFx0ZGVzdHJveVJlZi5vbkRlc3Ryb3koKCkgPT4gc291cmNlUmVzdWx0LnVuc3Vic2NyaWJlKCkpO1xuXG5cdFx0Ly8gc291cmNlVmFsdWUgaXMgYSBzaWduYWwgdGhhdCB3aWxsIGhvbGQgdGhlIGN1cnJlbnQgdmFsdWUgYW5kIHRoZSBzdGF0ZSBvZiB0aGUgdmFsdWVcblx0XHRsZXQgc291cmNlVmFsdWU6IFdyaXRhYmxlU2lnbmFsPFN0YXRlPFQ+PjtcblxuXHRcdGlmIChvcHRpb25zPy5yZXF1aXJlU3luYyAmJiBvcHRpb25zPy5pbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc3QgaW5pdGlhbENtcCA9IGNvbXB1dGF0aW9uKHVuZGVmaW5lZCk7XG5cblx0XHRcdC8vIHdlIGRvbid0IHN1cHBvcnQgcHJvbWlzZXMgd2l0aCByZXF1aXJlU3luYyBhbmQgbm8gaW5pdGlhbFZhbHVlIGFsc28gdGhlIHR5cGluZ3MgZG9uJ3QgYWxsb3cgdGhpcyBjYXNlXG5cdFx0XHRpZiAoaXNQcm9taXNlKGluaXRpYWxDbXApKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihSRVFVSVJFX1NZTkNfUFJPTUlTRV9NRVNTQUdFKTtcblx0XHRcdH1cblxuXHRcdFx0c291cmNlVmFsdWUgPSBzaWduYWw8U3RhdGU8VD4+KHsga2luZDogU3RhdGVLaW5kLk5vVmFsdWUgfSk7XG5cblx0XHRcdGlmIChpc09ic2VydmFibGUoaW5pdGlhbENtcCkpIHtcblx0XHRcdFx0c291cmNlRXZlbnQkLm5leHQoaW5pdGlhbENtcCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzb3VyY2VWYWx1ZS5zZXQoeyBraW5kOiBTdGF0ZUtpbmQuVmFsdWUsIHZhbHVlOiBpbml0aWFsQ21wIGFzIFQgfSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNvdXJjZVZhbHVlID0gc2lnbmFsPFN0YXRlPFQ+Pih7XG5cdFx0XHRcdGtpbmQ6IFN0YXRlS2luZC5WYWx1ZSxcblx0XHRcdFx0dmFsdWU6IG9wdGlvbnM/LmluaXRpYWxWYWx1ZSxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zPy5yZXF1aXJlU3luYyAmJiBzb3VyY2VWYWx1ZSgpLmtpbmQgPT09IFN0YXRlS2luZC5Ob1ZhbHVlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoUkVRVUlSRV9TWU5DX0VSUk9SX01FU1NBR0UpO1xuXHRcdH1cblxuXHRcdGxldCBza2lwRmlyc3RDb21wdXRhdGlvbiA9IG9wdGlvbnM/LnJlcXVpcmVTeW5jID09PSB0cnVlO1xuXG5cdFx0Ly8gZWZmZWN0IHJ1bnMgaW5zaWRlIGluamVjdGlvbiBjb250ZXh0LCBzbyBpdCB3aWxsIGJlIGNsZWFudXAgdXAgd2hlbiBjb250ZXh0IGdldHMgZGVzdHJveWVkXG5cdFx0ZWZmZWN0KCgpID0+IHtcblx0XHRcdC8vIHdlIG5lZWQgdG8gaGF2ZSBhbiB1bnRyYWNrZWQoKSBoZXJlIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byByZWdpc3RlciB0aGUgc291cmNlVmFsdWUgYXMgYSBkZXBlbmRlbmN5XG5cdFx0XHQvLyBvdGhlcndpc2UsIHdlIHdvdWxkIGhhdmUgYW4gaW5maW5pdGUgbG9vcC5cblx0XHRcdC8vIHRoaXMgaXMgbmVlZGVkIGZvciBwcmV2aW91c1ZhbHVlIGZlYXR1cmUgdG8gd29ya1xuXHRcdFx0Y29uc3QgY3VycmVudFZhbHVlID0gdW50cmFja2VkKCgpID0+IHtcblx0XHRcdFx0Y29uc3QgY3VycmVudFNvdXJjZVZhbHVlID0gc291cmNlVmFsdWUoKTtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRTb3VyY2VWYWx1ZS5raW5kID09PSBTdGF0ZUtpbmQuVmFsdWVcblx0XHRcdFx0XHQ/IGN1cnJlbnRTb3VyY2VWYWx1ZS52YWx1ZVxuXHRcdFx0XHRcdDogdW5kZWZpbmVkO1xuXHRcdFx0fSk7XG5cblx0XHRcdGNvbnN0IG5ld1NvdXJjZSA9IGNvbXB1dGF0aW9uKGN1cnJlbnRWYWx1ZSk7XG5cblx0XHRcdC8vIHdlIG5lZWQgdG8gc2tpcCB0aGUgZmlyc3QgY29tcHV0YXRpb24gaWYgcmVxdWlyZVN5bmMgaXMgdHJ1ZVxuXHRcdFx0Ly8gYmVjYXVzZSB3ZSBhbHJlYWR5IGNvbXB1dGVkIHRoZSB2YWx1ZSBpbiB0aGUgcHJldmlvdXMgc3RlcFxuXHRcdFx0aWYgKHNraXBGaXJzdENvbXB1dGF0aW9uKSB7XG5cdFx0XHRcdHNraXBGaXJzdENvbXB1dGF0aW9uID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT2JzZXJ2YWJsZShuZXdTb3VyY2UpIHx8IGlzUHJvbWlzZShuZXdTb3VyY2UpKSB7XG5cdFx0XHRcdC8vIHdlIHVudHJhY2sgdGhlIHNvdXJjZSQubmV4dCgpIHNvIHRoYXQgd2UgZG9uJ3QgcmVnaXN0ZXIgb3RoZXIgc2lnbmFscyBhcyBkZXBlbmRlbmNpZXNcblx0XHRcdFx0dW50cmFja2VkKCgpID0+IHNvdXJjZUV2ZW50JC5uZXh0KG5ld1NvdXJjZSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gaWYgdGhlIG5ldyBzb3VyY2UgaXMgbm90IGFuIG9ic2VydmFibGUgb3IgYSBwcm9taXNlLCB3ZSBzZXQgdGhlIHZhbHVlIGltbWVkaWF0ZWx5XG5cdFx0XHRcdHVudHJhY2tlZCgoKSA9PlxuXHRcdFx0XHRcdHNvdXJjZVZhbHVlLnNldCh7IGtpbmQ6IFN0YXRlS2luZC5WYWx1ZSwgdmFsdWU6IG5ld1NvdXJjZSBhcyBUIH0pLFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gd2UgcmV0dXJuIGEgY29tcHV0ZWQgdmFsdWUgdGhhdCB3aWxsIHJldHVybiB0aGUgY3VycmVudCB2YWx1ZVxuXHRcdC8vIGluIG9yZGVyIHRvIHN1cHBvcnQgdGhlIHNhbWUgQVBJIGFzIGNvbXB1dGVkKClcblx0XHRyZXR1cm4gY29tcHV0ZWQoXG5cdFx0XHQoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHN0YXRlID0gc291cmNlVmFsdWUoKTtcblx0XHRcdFx0c3dpdGNoIChzdGF0ZS5raW5kKSB7XG5cdFx0XHRcdFx0Y2FzZSBTdGF0ZUtpbmQuVmFsdWU6XG5cdFx0XHRcdFx0XHRyZXR1cm4gc3RhdGUudmFsdWU7XG5cdFx0XHRcdFx0Y2FzZSBTdGF0ZUtpbmQuRXJyb3I6XG5cdFx0XHRcdFx0XHR0aHJvdyBzdGF0ZS5lcnJvcjtcblx0XHRcdFx0XHRjYXNlIFN0YXRlS2luZC5Ob1ZhbHVlOlxuXHRcdFx0XHRcdFx0Ly8gd2UgYWxyZWFkeSB0aHJvdyBhbiBlcnJvciBpZiByZXF1aXJlU3luYyBpcyB0cnVlIGFuZCB0aGVyZSBpcyBubyBpbml0aWFsVmFsdWUsXG5cdFx0XHRcdFx0XHQvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIHRocm93IGFuIGVycm9yIGhlcmVcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Ly8gd2Ugc2hvdWxkIG5ldmVyIHJlYWNoIHRoaXMgY2FzZVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHN0YXRlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR7IGVxdWFsOiBvcHRpb25zPy5lcXVhbCB9LFxuXHRcdCk7XG5cdH0pO1xufVxuXG5jb25zdCBSRVFVSVJFX1NZTkNfUFJPTUlTRV9NRVNTQUdFID0gYFByb21pc2VzIGNhbm5vdCBiZSB1c2VkIHdpdGggcmVxdWlyZVN5bmMuIFBhc3MgYW4gaW5pdGlhbFZhbHVlIG9yIHNldCByZXF1aXJlU3luYyB0byBmYWxzZS5gO1xuY29uc3QgUkVRVUlSRV9TWU5DX0VSUk9SX01FU1NBR0UgPSBgVGhlIG9ic2VydmFibGUgcGFzc2VkIHRvIGRlcml2ZWRBc3luYygpIGRpZCBub3QgZW1pdCBzeW5jaHJvbm91c2x5LiBQYXNzIGFuIGluaXRpYWxWYWx1ZSBvciBzZXQgcmVxdWlyZVN5bmMgdG8gZmFsc2UuYDtcblxuZnVuY3Rpb24gY3JlYXRlRmxhdHRlbk9ic2VydmFibGU8VD4oXG5cdHNvdXJjZTogU3ViamVjdDxQcm9taXNlPFQ+IHwgT2JzZXJ2YWJsZTxUPj4sXG5cdGJlaGF2aW9yOiBkZXJpdmVkQXN5bmNCZWhhdmlvcixcbik6IE9ic2VydmFibGU8VD4ge1xuXHRjb25zdCBLRVlfT1BFUkFUT1JfTUFQID0ge1xuXHRcdG1lcmdlOiBtZXJnZUFsbCxcblx0XHRjb25jYXQ6IGNvbmNhdEFsbCxcblx0XHRleGhhdXN0OiBleGhhdXN0QWxsLFxuXHRcdHN3aXRjaDogc3dpdGNoQWxsLFxuXHR9O1xuXG5cdHJldHVybiBzb3VyY2UucGlwZShLRVlfT1BFUkFUT1JfTUFQW2JlaGF2aW9yXSgpKTtcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlPFQ+KHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBQcm9taXNlPFQ+IHtcblx0cmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG5jb25zdCBlbnVtIFN0YXRlS2luZCB7XG5cdE5vVmFsdWUsXG5cdFZhbHVlLFxuXHRFcnJvcixcbn1cblxuaW50ZXJmYWNlIE5vVmFsdWVTdGF0ZSB7XG5cdGtpbmQ6IFN0YXRlS2luZC5Ob1ZhbHVlO1xufVxuXG5pbnRlcmZhY2UgVmFsdWVTdGF0ZTxUPiB7XG5cdGtpbmQ6IFN0YXRlS2luZC5WYWx1ZTtcblx0dmFsdWU6IFQ7XG59XG5cbmludGVyZmFjZSBFcnJvclN0YXRlIHtcblx0a2luZDogU3RhdGVLaW5kLkVycm9yO1xuXHRlcnJvcjogdW5rbm93bjtcbn1cblxudHlwZSBTdGF0ZTxUPiA9IE5vVmFsdWVTdGF0ZSB8IFZhbHVlU3RhdGU8VD4gfCBFcnJvclN0YXRlO1xuIl19