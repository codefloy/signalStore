import { Pipe } from '@angular/core';
import * as i0 from "@angular/core";
export const lengthErrorMessageBuilder = (value) => `[Repeat] repeat requires an positive integer but "${value}" is passed in`;
export const startAtErrorMessageBuilder = (value) => `[Repeat] repeat startAt requires an integer but "${value}" is passed in`;
/**
 * Returns an array of numbers starting from a given startAt value up to a specified length.
 *
 * @param {number} length - The number of elements to include in the resulting array.
 * @param {number} [startAt=0] - The value at which to start the sequence. Defaults to 0 if not provided.
 * @returns {number[]} - An array of numbers starting from startAt and incremented by 1 up to the specified length.
 * @throws {Error} - If length is not a positive integer.
 *
 * @example
 * ```html
 * @for (i of 5 | repeat; track i) {
 * <p>Nr. {{i}}</p>
 * }
 *
 * <hr/>
 *
 * @for (i of 5 | repeat: 5; track i) {
 * <p>Nr. {{i}}</p>
 * }
 *
 * <!-- Output -->
 * Nr. 0
 * Nr. 1
 * Nr. 2
 * Nr. 3
 * Nr. 4
 * ----------------
 * Nr. 5
 * Nr. 6
 * Nr. 7
 * Nr. 8
 * Nr. 9
 * ```
 */
export class RepeatPipe {
    /**
     * Returns an array of numbers starting from a given startAt value up to a specified length.
     *
     * @param {number} length - The number of elements to include in the resulting array.
     * @param {number} [startAt=0] - The value at which to start the sequence. Defaults to 0 if not provided.
     * @returns {number[]} - An array of numbers starting from startAt and incremented by 1 up to the specified length.
     * @throws {Error} - If length is not a positive integer.
     *
     * @example
     * ```html
     * @for (i of 5 | repeat; track i) {
     * <p>Nr. {{i}}</p>
     * }
     *
     * <hr/>
     *
     * @for (i of 5 | repeat: 5; track i) {
     * <p>Nr. {{i}}</p>
     * }
     *
     * <!-- Output -->
     * Nr. 0
     * Nr. 1
     * Nr. 2
     * Nr. 3
     * Nr. 4
     * ----------------
     * Nr. 5
     * Nr. 6
     * Nr. 7
     * Nr. 8
     * Nr. 9
     * ```
     */
    transform(length, startAt = 0) {
        if (Number.isNaN(length) || !Number.isInteger(length) || length < 0) {
            throw new Error(lengthErrorMessageBuilder(length));
        }
        if (Number.isNaN(startAt) || !Number.isInteger(startAt)) {
            throw new Error(startAtErrorMessageBuilder(startAt));
        }
        return Array.from({ length }, (_, index) => index + startAt);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: RepeatPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.3", ngImport: i0, type: RepeatPipe, isStandalone: true, name: "repeat" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: RepeatPipe, decorators: [{
            type: Pipe,
            args: [{
                    standalone: true,
                    name: 'repeat',
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVwZWF0LXBpcGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9saWJzL25neHRlbnNpb24vcmVwZWF0LXBpcGUvc3JjL3JlcGVhdC1waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQXNCLE1BQU0sZUFBZSxDQUFDOztBQUV6RCxNQUFNLENBQUMsTUFBTSx5QkFBeUIsR0FBRyxDQUFDLEtBQWMsRUFBRSxFQUFFLENBQzNELHFEQUFxRCxLQUFLLGdCQUFnQixDQUFDO0FBRTVFLE1BQU0sQ0FBQyxNQUFNLDBCQUEwQixHQUFHLENBQUMsS0FBYyxFQUFFLEVBQUUsQ0FDNUQsb0RBQW9ELEtBQUssZ0JBQWdCLENBQUM7QUFFM0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWlDRztBQUtILE1BQU0sT0FBTyxVQUFVO0lBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQ0c7SUFDSCxTQUFTLENBQUMsTUFBYyxFQUFFLE9BQU8sR0FBRyxDQUFDO1FBQ3BDLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ3JFLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUNwRCxDQUFDO1FBQ0QsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQ3pELE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUN0RCxDQUFDO1FBQ0QsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLENBQUM7SUFDOUQsQ0FBQzs4R0EzQ1csVUFBVTs0R0FBVixVQUFVOzsyRkFBVixVQUFVO2tCQUp0QixJQUFJO21CQUFDO29CQUNMLFVBQVUsRUFBRSxJQUFJO29CQUNoQixJQUFJLEVBQUUsUUFBUTtpQkFDZCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBpcGUsIHR5cGUgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgY29uc3QgbGVuZ3RoRXJyb3JNZXNzYWdlQnVpbGRlciA9ICh2YWx1ZTogdW5rbm93bikgPT5cblx0YFtSZXBlYXRdIHJlcGVhdCByZXF1aXJlcyBhbiBwb3NpdGl2ZSBpbnRlZ2VyIGJ1dCBcIiR7dmFsdWV9XCIgaXMgcGFzc2VkIGluYDtcblxuZXhwb3J0IGNvbnN0IHN0YXJ0QXRFcnJvck1lc3NhZ2VCdWlsZGVyID0gKHZhbHVlOiB1bmtub3duKSA9PlxuXHRgW1JlcGVhdF0gcmVwZWF0IHN0YXJ0QXQgcmVxdWlyZXMgYW4gaW50ZWdlciBidXQgXCIke3ZhbHVlfVwiIGlzIHBhc3NlZCBpbmA7XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBudW1iZXJzIHN0YXJ0aW5nIGZyb20gYSBnaXZlbiBzdGFydEF0IHZhbHVlIHVwIHRvIGEgc3BlY2lmaWVkIGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIC0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHRpbmcgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0QXQ9MF0gLSBUaGUgdmFsdWUgYXQgd2hpY2ggdG8gc3RhcnQgdGhlIHNlcXVlbmNlLiBEZWZhdWx0cyB0byAwIGlmIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gLSBBbiBhcnJheSBvZiBudW1iZXJzIHN0YXJ0aW5nIGZyb20gc3RhcnRBdCBhbmQgaW5jcmVtZW50ZWQgYnkgMSB1cCB0byB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIGxlbmd0aCBpcyBub3QgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sXG4gKiBAZm9yIChpIG9mIDUgfCByZXBlYXQ7IHRyYWNrIGkpIHtcbiAqIDxwPk5yLiB7e2l9fTwvcD5cbiAqIH1cbiAqXG4gKiA8aHIvPlxuICpcbiAqIEBmb3IgKGkgb2YgNSB8IHJlcGVhdDogNTsgdHJhY2sgaSkge1xuICogPHA+TnIuIHt7aX19PC9wPlxuICogfVxuICpcbiAqIDwhLS0gT3V0cHV0IC0tPlxuICogTnIuIDBcbiAqIE5yLiAxXG4gKiBOci4gMlxuICogTnIuIDNcbiAqIE5yLiA0XG4gKiAtLS0tLS0tLS0tLS0tLS0tXG4gKiBOci4gNVxuICogTnIuIDZcbiAqIE5yLiA3XG4gKiBOci4gOFxuICogTnIuIDlcbiAqIGBgYFxuICovXG5AUGlwZSh7XG5cdHN0YW5kYWxvbmU6IHRydWUsXG5cdG5hbWU6ICdyZXBlYXQnLFxufSlcbmV4cG9ydCBjbGFzcyBSZXBlYXRQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIG51bWJlcnMgc3RhcnRpbmcgZnJvbSBhIGdpdmVuIHN0YXJ0QXQgdmFsdWUgdXAgdG8gYSBzcGVjaWZpZWQgbGVuZ3RoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIC0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHRpbmcgYXJyYXkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRBdD0wXSAtIFRoZSB2YWx1ZSBhdCB3aGljaCB0byBzdGFydCB0aGUgc2VxdWVuY2UuIERlZmF1bHRzIHRvIDAgaWYgbm90IHByb3ZpZGVkLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyW119IC0gQW4gYXJyYXkgb2YgbnVtYmVycyBzdGFydGluZyBmcm9tIHN0YXJ0QXQgYW5kIGluY3JlbWVudGVkIGJ5IDEgdXAgdG8gdGhlIHNwZWNpZmllZCBsZW5ndGguXG5cdCAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIGxlbmd0aCBpcyBub3QgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBgYGBodG1sXG5cdCAqIEBmb3IgKGkgb2YgNSB8IHJlcGVhdDsgdHJhY2sgaSkge1xuXHQgKiA8cD5Oci4ge3tpfX08L3A+XG5cdCAqIH1cblx0ICpcblx0ICogPGhyLz5cblx0ICpcblx0ICogQGZvciAoaSBvZiA1IHwgcmVwZWF0OiA1OyB0cmFjayBpKSB7XG5cdCAqIDxwPk5yLiB7e2l9fTwvcD5cblx0ICogfVxuXHQgKlxuXHQgKiA8IS0tIE91dHB1dCAtLT5cblx0ICogTnIuIDBcblx0ICogTnIuIDFcblx0ICogTnIuIDJcblx0ICogTnIuIDNcblx0ICogTnIuIDRcblx0ICogLS0tLS0tLS0tLS0tLS0tLVxuXHQgKiBOci4gNVxuXHQgKiBOci4gNlxuXHQgKiBOci4gN1xuXHQgKiBOci4gOFxuXHQgKiBOci4gOVxuXHQgKiBgYGBcblx0ICovXG5cdHRyYW5zZm9ybShsZW5ndGg6IG51bWJlciwgc3RhcnRBdCA9IDApOiBudW1iZXJbXSB7XG5cdFx0aWYgKE51bWJlci5pc05hTihsZW5ndGgpIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkgfHwgbGVuZ3RoIDwgMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGxlbmd0aEVycm9yTWVzc2FnZUJ1aWxkZXIobGVuZ3RoKSk7XG5cdFx0fVxuXHRcdGlmIChOdW1iZXIuaXNOYU4oc3RhcnRBdCkgfHwgIU51bWJlci5pc0ludGVnZXIoc3RhcnRBdCkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihzdGFydEF0RXJyb3JNZXNzYWdlQnVpbGRlcihzdGFydEF0KSk7XG5cdFx0fVxuXHRcdHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sIChfLCBpbmRleCkgPT4gaW5kZXggKyBzdGFydEF0KTtcblx0fVxufVxuIl19