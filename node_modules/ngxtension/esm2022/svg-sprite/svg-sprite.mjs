import { DOCUMENT } from '@angular/common';
import { Directive, ENVIRONMENT_INITIALIZER, ElementRef, Injectable, Input, NgZone, booleanAttribute, computed, inject, makeEnvironmentProviders, signal, } from '@angular/core';
import { injectAutoEffect } from 'ngxtension/auto-effect';
import { derivedFrom } from 'ngxtension/derived-from';
import { defer, map, of, pipe, shareReplay, switchMap, } from 'rxjs';
import { ajax } from 'rxjs/ajax';
import * as i0 from "@angular/core";
/**
 * This service registers {@link NgxSvgSprite svg sprites}, which can be rendered via {@link NgxSvgSpriteFragment}.
 */
export class NgxSvgSprites {
    constructor() {
        /**
         * @ignore
         */
        this.ngZone = inject(NgZone);
        /**
         * <{@link NgxSvgSprite.name}, {@link NgxSvgSprite}>
         */
        this.sprites = {};
        /**
         * Registers a sprite.
         *
         * @param sprite
         *
         * @see {@link NgxSvgSpriteFragment.sprite}
         */
        this.register = (sprite) => {
            this.sprites[sprite.name] = {
                ...sprite,
                svg$: defer(() => this.ngZone.runOutsideAngular(() => ajax({
                    url: sprite.baseUrl,
                    responseType: 'document',
                }))).pipe(map(({ response }) => {
                    const svg = response.querySelector('svg');
                    if (svg == null)
                        throw new Error(`[Svg Sprite] the url '${sprite.baseUrl}' does not seem to be a svg.`);
                    return svg;
                }), shareReplay(1)),
            };
        };
        /**
         *
         * @param name
         * @returns a registered sprite by its name or undefined if not registered.
         */
        this.get = (name) => this.sprites[name];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxSvgSprites, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxSvgSprites, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxSvgSprites, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
/**
 *
 * @param sprites
 * @returns an environment provider which registers svg sprites. The default `url` of a sprite will be `${baseUrl}#${fragment}`.
 */
export const provideSvgSprites = (...sprites) => makeEnvironmentProviders([
    {
        provide: ENVIRONMENT_INITIALIZER,
        multi: true,
        useFactory: () => {
            const service = inject(NgxSvgSprites);
            return () => sprites.forEach((sprite) => service.register(createSvgSprite(sprite)));
        },
    },
]);
/**
 * Creates a {@link NgxSvgSprite} with a default `url` builder of `${baseUrl}#${fragment}`.
 *
 * @param options
 * @returns
 */
const createSvgSprite = (options) => {
    if (options.url == null)
        options.url = (baseUrl, fragment) => `${baseUrl}#${fragment}`;
    return options;
};
/**
 * A directive for rendering _symbols_ of svg sprites. It is done with the [`use`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/use) element.
 *
 * ## Import
 *
 * ```typescript
 * import { NgxSvgSpriteFragment } from 'ngxtension/svg-sprite';
 * ```
 *
 * ## Usage
 *
 * In this example the symbol `github` of the [fontawesome](https://fontawesome.com/) svg sprite `fa-brands` is rendered. A symbol is identified by a `fragment`. Learn more about [URLs](https://svgwg.org/svg2-draft/linking.html#URLReference).
 *
 * ```html
 * <svg fragment="github" sprite="fa-brands"></svg>
 * ```
 *
 * Without `NgxSvgSpriteFragment`:
 *
 * ```html
 * <svg viewBox="0 0 496 512">
 * 	<use href="assets/fontawesome/sprites/brands.svg#github"></use>
 * </svg>
 * ```
 *
 * ### With Directive Composition Api
 *
 * In your project you can utilize the [Directive Composition Api](https://angular.io/guide/directive-composition-api) to create specific svg sprites.
 *
 * In this example a _fontawesome brands_ svg sprite is created.
 *
 * ```html
 * <svg faBrand="github"></svg>
 * ```
 *
 * ```ts
 * @Directive({
 * 	selector: 'svg[faBrand]',
 * 	standalone: true,
 * 	hostDirectives: [
 * 		{ directive: NgxSvgSpriteFragment, inputs: ['fragment:faBrand'] },
 * 	],
 * })
 * export class FaBrandSvg {
 * 	constructor() {
 * 		inject(NgxSvgSpriteFragment).sprite = 'fa-brands';
 * 	}
 * }
 * ```
 *
 * ## Configuration
 *
 * In order to render a symbol, sprites have to be provided.
 *
 * ```ts
 * provideSvgSprites({
 * 	name: 'fa-brands',
 * 	baseUrl: 'assets/fontawesome/sprites/brands.svg',
 * });
 * ```
 *
 * The `name` property can reference any arbitrary value, but should be unique, since you can register multiple different svg sprites.
 *
 * The `sprite` input of the `NgxSvgSpriteFragment` should reference the `name` property of a provided sprite.
 *
 * ### Auto View Box
 *
 * When a symbol of an svg sprite is rendered the `viewBox` attribute or `height` and `width` _should_ be set. The `svg` element does not copy/use the `viewBox` attribute of the symbol in the svg sprite, therefore the svg will have default dimensions of 300x150 px, which is probably not preferred.
 *
 * Per default when an svg sprite is registered, the svg sprite is fetched with js in addition. `NgxSvgSpriteFragment` will copy the `viewBox` attribute of the symbol to its host.
 *
 * This behavior can be disabled.
 *
 * #### Disable via DI
 *
 * Auto View Box is disabled for the svg sprite.
 *
 * ```ts
 * provideSvgSprites({
 * 	name: 'fa-brands',
 * 	baseUrl: 'assets/fontawesome/sprites/brands.svg',
 * 	autoViewBox: false,
 * });
 * ```
 *
 * #### Disable via `autoViewBoxDisabled` Input
 *
 * Auto View Box is disabled for a `svg` element, when the `autoViewBoxDisabled` input is set to `false`.
 *
 * ```html
 * <svg fragment="github" sprite="fa-brands" autoViewBoxDisabled></svg>
 * ```
 *
 * #### Disable via `viewBox` Attribute
 *
 * Auto View Box is disabled for a `svg` element, when the `viewBox` attribute already is defined.
 *
 * ```html
 * <svg fragment="github" sprite="fa-brands" viewBox="0 0 32 32"></svg>
 * ```
 *
 * ### Classes
 *
 * When the `classes` function is set, a list of classes will be added by the `NgxSvgSpriteFragment` to its host.
 *
 * ```ts
 * provideSvgSprites({
 * 	name: 'my-sprite',
 * 	baseUrl: 'path/to/my/sprite.svg',
 * 	classes: (fragment) => ['some-class', `some-other-class-${fragment}`],
 * });
 * ```
 *
 * ### Url
 *
 * Per default when providing a sprite, the `url` will return `'${baseUrl}#${fragment}'`. This can be overwritten:
 *
 * ```ts
 * provideSvgSprites({
 * 	name: 'my-sprite',
 * 	baseUrl: 'path/to/my/sprite.svg',
 * 	url: (baseUrl, fragment) => `${baseUrl}#some-prefix-${fragment}`,
 * });
 * ```
 */
export class NgxSvgSpriteFragment {
    constructor() {
        /**
         * @ignore
         */
        this.element = inject(ElementRef)
            .nativeElement;
        /**
         * @ignore
         */
        this.document = inject(DOCUMENT);
        /**
         * @ignore
         */
        this.autoEffect = injectAutoEffect();
        /**
         * @ignore
         */
        this.sprites = inject(NgxSvgSprites);
        /**
         * The `fragment` which identifies a `symbol` in this {@link NgxSvgSpriteFragment.sprite svg sprite}.
         */
        this.fragment$ = signal(undefined);
        /**
         * The `name` of the {@link NgxSvgSprite svg sprite} this {@link NgxSvgSpriteFragment.fragment fragment} is a part of.
         *
         * @see {@link NgxSvgSprite.name}
         */
        this.sprite$ = signal(undefined);
        /**
         * Whether `autoViewBox` is disabled.
         *
         * @see overrides {@link NgxSvgSprite.autoViewBox}
         */
        this.autoViewBoxDisabled$ = signal(false);
        /**
         * @ignore
         */
        this.spriteConfig$ = computed(() => {
            const sprite = this.sprite$();
            if (sprite != null)
                return this.sprites.get(sprite);
            return undefined;
        });
        /**
         * @ignore
         */
        this.svg$ = derivedFrom({ sprite: this.spriteConfig$ }, pipe(switchMap(({ sprite }) => sprite?.svg$ ?? of(undefined))));
        /**
         * @ignore
         */
        this.autoViewBox$ = computed(() => !this.autoViewBoxDisabled$() &&
            (this.spriteConfig$()?.autoViewBox ?? true));
    }
    /**
     * @ignore
     */
    ngOnInit() {
        // Copy the 'viewBox' from the 'symbol' element in the sprite to this svg.
        // Do not launch this effect when the svg already has a 'viewBox'.
        if (!this.element.hasAttribute('viewBox'))
            this.autoEffect(() => {
                const element = this.element;
                const autoViewBox = this.autoViewBox$();
                const svg = this.svg$();
                const fragment = this.fragment$();
                if (!autoViewBox || svg == null || fragment == null)
                    return;
                try {
                    const viewBox = svg
                        .querySelector(`#${fragment}`)
                        ?.getAttribute('viewBox');
                    if (viewBox == null)
                        return;
                    element.setAttribute('viewBox', viewBox);
                }
                catch {
                    // the querySelector could throw due to an invalid selector
                }
            });
        // Create a 'use' element which instantiates a 'symbol' element of the sprite.
        this.autoEffect(() => {
            const fragment = this.fragment$();
            const sprite = this.sprite$();
            const spriteConfig = this.spriteConfig$();
            const element = this.element;
            const document = this.document;
            let classes = [];
            if (fragment == null || sprite == null || spriteConfig == null)
                return;
            const useElement = document.createElementNS(element.namespaceURI, 'use');
            // Add classes when provided.
            if (spriteConfig.classes != null) {
                const _classes = spriteConfig.classes(fragment);
                classes =
                    typeof _classes === 'string'
                        ? _classes.split(' ').filter(Boolean)
                        : _classes;
                element.classList.add(...classes);
            }
            useElement.setAttribute('href', spriteConfig.url(spriteConfig.baseUrl, fragment));
            // Support old browsers. Modern browser will ignore this if they support 'href'.
            useElement.setAttribute('xlink:href', spriteConfig.url(spriteConfig.baseUrl, fragment));
            element.appendChild(useElement);
            // Cleanup: clear child nodes and remove old classes of this svg.
            return () => {
                element.replaceChildren();
                element.classList.remove(...classes);
            };
        });
    }
    /**
     * The `fragment` which identifies a `symbol` in this {@link NgxSvgSpriteFragment.sprite svg sprite}.
     */
    set fragment(fragment) {
        this.fragment$.set(fragment);
    }
    get fragment() {
        return this.fragment$();
    }
    /**
     * The `name` of the {@link NgxSvgSprite svg sprite} this {@link NgxSvgSpriteFragment.fragment fragment} is a part of.
     *
     * @see {@link NgxSvgSprite.name}
     */
    set sprite(sprite) {
        this.sprite$.set(sprite);
    }
    get sprite() {
        return this.sprite$();
    }
    /**
     * Whether `autoViewBox` is disabled.
     *
     * @see overrides {@link NgxSvgSprite.autoViewBox}
     */
    set autoViewBoxDisabled(autoViewBoxDisabled) {
        this.autoViewBoxDisabled$.set(autoViewBoxDisabled);
    }
    get autoViewBoxDisabled() {
        return this.autoViewBoxDisabled$();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxSvgSpriteFragment, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "18.0.3", type: NgxSvgSpriteFragment, isStandalone: true, selector: "svg[fragment]", inputs: { fragment: "fragment", sprite: "sprite", autoViewBoxDisabled: ["autoViewBoxDisabled", "autoViewBoxDisabled", booleanAttribute] }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxSvgSpriteFragment, decorators: [{
            type: Directive,
            args: [{
                    selector: 'svg[fragment]',
                    standalone: true,
                }]
        }], propDecorators: { fragment: [{
                type: Input
            }], sprite: [{
                type: Input
            }], autoViewBoxDisabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ZnLXNwcml0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvbmd4dGVuc2lvbi9zdmctc3ByaXRlL3NyYy9zdmctc3ByaXRlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQ04sU0FBUyxFQUNULHVCQUF1QixFQUN2QixVQUFVLEVBQ1YsVUFBVSxFQUNWLEtBQUssRUFDTCxNQUFNLEVBQ04sZ0JBQWdCLEVBQ2hCLFFBQVEsRUFDUixNQUFNLEVBQ04sd0JBQXdCLEVBQ3hCLE1BQU0sR0FFTixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMxRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDdEQsT0FBTyxFQUNOLEtBQUssRUFDTCxHQUFHLEVBQ0gsRUFBRSxFQUNGLElBQUksRUFDSixXQUFXLEVBQ1gsU0FBUyxHQUVULE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLFdBQVcsQ0FBQzs7QUEwQ2pDOztHQUVHO0FBRUgsTUFBTSxPQUFPLGFBQWE7SUFEMUI7UUFFQzs7V0FFRztRQUNjLFdBQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFekM7O1dBRUc7UUFDYyxZQUFPLEdBR3BCLEVBQUUsQ0FBQztRQUVQOzs7Ozs7V0FNRztRQUNhLGFBQVEsR0FBRyxDQUFDLE1BQW9CLEVBQUUsRUFBRTtZQUNuRCxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRztnQkFDM0IsR0FBRyxNQUFNO2dCQUNULElBQUksRUFBRSxLQUFLLENBQUMsR0FBRyxFQUFFLENBQ2hCLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFLENBQ2xDLElB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LG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRCxJQUFXLG1CQUFtQjtRQUM3QixPQUFPLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO0lBQ3BDLENBQUM7OEdBcExXLG9CQUFvQjtrR0FBcEIsb0JBQW9CLHVLQTZLWixnQkFBZ0I7OzJGQTdLeEIsb0JBQW9CO2tCQUpoQyxTQUFTO21CQUFDO29CQUNWLFFBQVEsRUFBRSxlQUFlO29CQUN6QixVQUFVLEVBQUUsSUFBSTtpQkFDaEI7OEJBbUpXLFFBQVE7c0JBRGxCLEtBQUs7Z0JBZUssTUFBTTtzQkFEaEIsS0FBSztnQkFlSyxtQkFBbUI7c0JBRDdCLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuXHREaXJlY3RpdmUsXG5cdEVOVklST05NRU5UX0lOSVRJQUxJWkVSLFxuXHRFbGVtZW50UmVmLFxuXHRJbmplY3RhYmxlLFxuXHRJbnB1dCxcblx0Tmdab25lLFxuXHRib29sZWFuQXR0cmlidXRlLFxuXHRjb21wdXRlZCxcblx0aW5qZWN0LFxuXHRtYWtlRW52aXJvbm1lbnRQcm92aWRlcnMsXG5cdHNpZ25hbCxcblx0dHlwZSBPbkluaXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaW5qZWN0QXV0b0VmZmVjdCB9IGZyb20gJ25neHRlbnNpb24vYXV0by1lZmZlY3QnO1xuaW1wb3J0IHsgZGVyaXZlZEZyb20gfSBmcm9tICduZ3h0ZW5zaW9uL2Rlcml2ZWQtZnJvbSc7XG5pbXBvcnQge1xuXHRkZWZlcixcblx0bWFwLFxuXHRvZixcblx0cGlwZSxcblx0c2hhcmVSZXBsYXksXG5cdHN3aXRjaE1hcCxcblx0dHlwZSBPYnNlcnZhYmxlLFxufSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGFqYXggfSBmcm9tICdyeGpzL2FqYXgnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdmcgc3ByaXRlLlxuICpcbiAqIEBzZWUge0BsaW5rIE5neFN2Z1Nwcml0ZUZyYWdtZW50LnNwcml0ZX1cbiAqIEBzZWUge0BsaW5rIE5neFN2Z1Nwcml0ZXMucmVnaXN0ZXJ9XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudC91c2UgYHVzZWAgRWxlbWVudH1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZ3hTdmdTcHJpdGUge1xuXHQvKipcblx0ICogQSB1bmlxdWUgbmFtZSBpZGVudGlmeWluZyB0aGlzIHNwcml0ZS5cblx0ICovXG5cdG5hbWU6IHN0cmluZztcblxuXHQvKipcblx0ICogRS5nLiBgcGF0aC90by9teS9zcHJpdGUuc3ZnYFxuXHQgKi9cblx0YmFzZVVybDogc3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gYmFzZVVybCByZWZlcmVuY2UgdG8gdGhpcyB7QGxpbmsgYmFzZVVybH1cblx0ICogQHBhcmFtIGZyYWdtZW50XG5cdCAqIEByZXR1cm5zIGEgdXJsIHBvaW50aW5nIHRvIGEgc3BlY2lmaWVkIHN2ZyBpbiB0aGlzIHNwcml0ZSBieSB1c2luZyBhIGBmcmFnbWVudGAgZS5nIGBwYXRoL3RvL215L3Nwcml0ZS5zdmcjJHtmcmFnbWVudH1gXG5cdCAqXG5cdCAqIEBzZWUge0BsaW5rIGh0dHBzOi8vc3Znd2cub3JnL3N2ZzItZHJhZnQvbGlua2luZy5odG1sI1VSTFJlZmVyZW5jZX1cblx0ICovXG5cdHVybDogKGJhc2VVcmw6IHN0cmluZywgZnJhZ21lbnQ6IHN0cmluZykgPT4gc3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIHRvIGNvcHkgdGhlIGB2aWV3Qm94YCBhdHRyaWJ1dGUgZnJvbSB0aGUgYHN5bWJvbGAgaW4gdGhlIHN2ZyBzcHJpdGUuXG5cdCAqL1xuXHRhdXRvVmlld0JveD86IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSBmcmFnbWVudFxuXHQgKiBAcmV0dXJucyBhIGxpc3Qgb2YgY2xhc3NlcyB0aGF0IGFyZSBhcHBsaWVkIHRvIHRoZSBzdmcgZWxlbWVudC5cblx0ICovXG5cdGNsYXNzZXM/OiAoZnJhZ21lbnQ6IHN0cmluZykgPT4gc3RyaW5nW10gfCBzdHJpbmc7XG59XG5cbi8qKlxuICogVGhpcyBzZXJ2aWNlIHJlZ2lzdGVycyB7QGxpbmsgTmd4U3ZnU3ByaXRlIHN2ZyBzcHJpdGVzfSwgd2hpY2ggY2FuIGJlIHJlbmRlcmVkIHZpYSB7QGxpbmsgTmd4U3ZnU3ByaXRlRnJhZ21lbnR9LlxuICovXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIE5neFN2Z1Nwcml0ZXMge1xuXHQvKipcblx0ICogQGlnbm9yZVxuXHQgKi9cblx0cHJpdmF0ZSByZWFkb25seSBuZ1pvbmUgPSBpbmplY3QoTmdab25lKTtcblxuXHQvKipcblx0ICogPHtAbGluayBOZ3hTdmdTcHJpdGUubmFtZX0sIHtAbGluayBOZ3hTdmdTcHJpdGV9PlxuXHQgKi9cblx0cHJpdmF0ZSByZWFkb25seSBzcHJpdGVzOiBSZWNvcmQ8XG5cdFx0c3RyaW5nLFxuXHRcdE5neFN2Z1Nwcml0ZSAmIHsgc3ZnJDogT2JzZXJ2YWJsZTxTVkdHcmFwaGljc0VsZW1lbnQ+IH1cblx0PiA9IHt9O1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBzcHJpdGUuXG5cdCAqXG5cdCAqIEBwYXJhbSBzcHJpdGVcblx0ICpcblx0ICogQHNlZSB7QGxpbmsgTmd4U3ZnU3ByaXRlRnJhZ21lbnQuc3ByaXRlfVxuXHQgKi9cblx0cHVibGljIHJlYWRvbmx5IHJlZ2lzdGVyID0gKHNwcml0ZTogTmd4U3ZnU3ByaXRlKSA9PiB7XG5cdFx0dGhpcy5zcHJpdGVzW3Nwcml0ZS5uYW1lXSA9IHtcblx0XHRcdC4uLnNwcml0ZSxcblx0XHRcdHN2ZyQ6IGRlZmVyKCgpID0+XG5cdFx0XHRcdHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG5cdFx0XHRcdFx0YWpheDxTVkdHcmFwaGljc0VsZW1lbnQ+KHtcblx0XHRcdFx0XHRcdHVybDogc3ByaXRlLmJhc2VVcmwsXG5cdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6ICdkb2N1bWVudCcsXG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdCksXG5cdFx0XHQpLnBpcGUoXG5cdFx0XHRcdG1hcCgoeyByZXNwb25zZSB9KSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgc3ZnID0gcmVzcG9uc2UucXVlcnlTZWxlY3Rvcignc3ZnJyk7XG5cblx0XHRcdFx0XHRpZiAoc3ZnID09IG51bGwpXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdGBbU3ZnIFNwcml0ZV0gdGhlIHVybCAnJHtzcHJpdGUuYmFzZVVybH0nIGRvZXMgbm90IHNlZW0gdG8gYmUgYSBzdmcuYCxcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gc3ZnO1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0c2hhcmVSZXBsYXkoMSksXG5cdFx0XHQpLFxuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSBuYW1lXG5cdCAqIEByZXR1cm5zIGEgcmVnaXN0ZXJlZCBzcHJpdGUgYnkgaXRzIG5hbWUgb3IgdW5kZWZpbmVkIGlmIG5vdCByZWdpc3RlcmVkLlxuXHQgKi9cblx0cHVibGljIHJlYWRvbmx5IGdldCA9IChuYW1lOiBzdHJpbmcpID0+IHRoaXMuc3ByaXRlc1tuYW1lXTtcbn1cblxuZXhwb3J0IHR5cGUgQ3JlYXRlTmd4U3ZnU3ByaXRlT3B0aW9ucyA9IE9taXQ8Tmd4U3ZnU3ByaXRlLCAndXJsJz4gJlxuXHRQYXJ0aWFsPFBpY2s8Tmd4U3ZnU3ByaXRlLCAndXJsJz4+O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gc3ByaXRlc1xuICogQHJldHVybnMgYW4gZW52aXJvbm1lbnQgcHJvdmlkZXIgd2hpY2ggcmVnaXN0ZXJzIHN2ZyBzcHJpdGVzLiBUaGUgZGVmYXVsdCBgdXJsYCBvZiBhIHNwcml0ZSB3aWxsIGJlIGAke2Jhc2VVcmx9IyR7ZnJhZ21lbnR9YC5cbiAqL1xuZXhwb3J0IGNvbnN0IHByb3ZpZGVTdmdTcHJpdGVzID0gKC4uLnNwcml0ZXM6IENyZWF0ZU5neFN2Z1Nwcml0ZU9wdGlvbnNbXSkgPT5cblx0bWFrZUVudmlyb25tZW50UHJvdmlkZXJzKFtcblx0XHR7XG5cdFx0XHRwcm92aWRlOiBFTlZJUk9OTUVOVF9JTklUSUFMSVpFUixcblx0XHRcdG11bHRpOiB0cnVlLFxuXHRcdFx0dXNlRmFjdG9yeTogKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBzZXJ2aWNlID0gaW5qZWN0KE5neFN2Z1Nwcml0ZXMpO1xuXHRcdFx0XHRyZXR1cm4gKCkgPT5cblx0XHRcdFx0XHRzcHJpdGVzLmZvckVhY2goKHNwcml0ZSkgPT5cblx0XHRcdFx0XHRcdHNlcnZpY2UucmVnaXN0ZXIoY3JlYXRlU3ZnU3ByaXRlKHNwcml0ZSkpLFxuXHRcdFx0XHRcdCk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdF0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgTmd4U3ZnU3ByaXRlfSB3aXRoIGEgZGVmYXVsdCBgdXJsYCBidWlsZGVyIG9mIGAke2Jhc2VVcmx9IyR7ZnJhZ21lbnR9YC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnNcbiAqL1xuY29uc3QgY3JlYXRlU3ZnU3ByaXRlID0gKG9wdGlvbnM6IENyZWF0ZU5neFN2Z1Nwcml0ZU9wdGlvbnMpID0+IHtcblx0aWYgKG9wdGlvbnMudXJsID09IG51bGwpXG5cdFx0b3B0aW9ucy51cmwgPSAoYmFzZVVybCwgZnJhZ21lbnQpID0+IGAke2Jhc2VVcmx9IyR7ZnJhZ21lbnR9YDtcblxuXHRyZXR1cm4gb3B0aW9ucyBhcyBOZ3hTdmdTcHJpdGU7XG59O1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIGZvciByZW5kZXJpbmcgX3N5bWJvbHNfIG9mIHN2ZyBzcHJpdGVzLiBJdCBpcyBkb25lIHdpdGggdGhlIFtgdXNlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvdXNlKSBlbGVtZW50LlxuICpcbiAqICMjIEltcG9ydFxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IE5neFN2Z1Nwcml0ZUZyYWdtZW50IH0gZnJvbSAnbmd4dGVuc2lvbi9zdmctc3ByaXRlJztcbiAqIGBgYFxuICpcbiAqICMjIFVzYWdlXG4gKlxuICogSW4gdGhpcyBleGFtcGxlIHRoZSBzeW1ib2wgYGdpdGh1YmAgb2YgdGhlIFtmb250YXdlc29tZV0oaHR0cHM6Ly9mb250YXdlc29tZS5jb20vKSBzdmcgc3ByaXRlIGBmYS1icmFuZHNgIGlzIHJlbmRlcmVkLiBBIHN5bWJvbCBpcyBpZGVudGlmaWVkIGJ5IGEgYGZyYWdtZW50YC4gTGVhcm4gbW9yZSBhYm91dCBbVVJMc10oaHR0cHM6Ly9zdmd3Zy5vcmcvc3ZnMi1kcmFmdC9saW5raW5nLmh0bWwjVVJMUmVmZXJlbmNlKS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8c3ZnIGZyYWdtZW50PVwiZ2l0aHViXCIgc3ByaXRlPVwiZmEtYnJhbmRzXCI+PC9zdmc+XG4gKiBgYGBcbiAqXG4gKiBXaXRob3V0IGBOZ3hTdmdTcHJpdGVGcmFnbWVudGA6XG4gKlxuICogYGBgaHRtbFxuICogPHN2ZyB2aWV3Qm94PVwiMCAwIDQ5NiA1MTJcIj5cbiAqIFx0PHVzZSBocmVmPVwiYXNzZXRzL2ZvbnRhd2Vzb21lL3Nwcml0ZXMvYnJhbmRzLnN2ZyNnaXRodWJcIj48L3VzZT5cbiAqIDwvc3ZnPlxuICogYGBgXG4gKlxuICogIyMjIFdpdGggRGlyZWN0aXZlIENvbXBvc2l0aW9uIEFwaVxuICpcbiAqIEluIHlvdXIgcHJvamVjdCB5b3UgY2FuIHV0aWxpemUgdGhlIFtEaXJlY3RpdmUgQ29tcG9zaXRpb24gQXBpXShodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvZGlyZWN0aXZlLWNvbXBvc2l0aW9uLWFwaSkgdG8gY3JlYXRlIHNwZWNpZmljIHN2ZyBzcHJpdGVzLlxuICpcbiAqIEluIHRoaXMgZXhhbXBsZSBhIF9mb250YXdlc29tZSBicmFuZHNfIHN2ZyBzcHJpdGUgaXMgY3JlYXRlZC5cbiAqXG4gKiBgYGBodG1sXG4gKiA8c3ZnIGZhQnJhbmQ9XCJnaXRodWJcIj48L3N2Zz5cbiAqIGBgYFxuICpcbiAqIGBgYHRzXG4gKiBARGlyZWN0aXZlKHtcbiAqIFx0c2VsZWN0b3I6ICdzdmdbZmFCcmFuZF0nLFxuICogXHRzdGFuZGFsb25lOiB0cnVlLFxuICogXHRob3N0RGlyZWN0aXZlczogW1xuICogXHRcdHsgZGlyZWN0aXZlOiBOZ3hTdmdTcHJpdGVGcmFnbWVudCwgaW5wdXRzOiBbJ2ZyYWdtZW50OmZhQnJhbmQnXSB9LFxuICogXHRdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBGYUJyYW5kU3ZnIHtcbiAqIFx0Y29uc3RydWN0b3IoKSB7XG4gKiBcdFx0aW5qZWN0KE5neFN2Z1Nwcml0ZUZyYWdtZW50KS5zcHJpdGUgPSAnZmEtYnJhbmRzJztcbiAqIFx0fVxuICogfVxuICogYGBgXG4gKlxuICogIyMgQ29uZmlndXJhdGlvblxuICpcbiAqIEluIG9yZGVyIHRvIHJlbmRlciBhIHN5bWJvbCwgc3ByaXRlcyBoYXZlIHRvIGJlIHByb3ZpZGVkLlxuICpcbiAqIGBgYHRzXG4gKiBwcm92aWRlU3ZnU3ByaXRlcyh7XG4gKiBcdG5hbWU6ICdmYS1icmFuZHMnLFxuICogXHRiYXNlVXJsOiAnYXNzZXRzL2ZvbnRhd2Vzb21lL3Nwcml0ZXMvYnJhbmRzLnN2ZycsXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFRoZSBgbmFtZWAgcHJvcGVydHkgY2FuIHJlZmVyZW5jZSBhbnkgYXJiaXRyYXJ5IHZhbHVlLCBidXQgc2hvdWxkIGJlIHVuaXF1ZSwgc2luY2UgeW91IGNhbiByZWdpc3RlciBtdWx0aXBsZSBkaWZmZXJlbnQgc3ZnIHNwcml0ZXMuXG4gKlxuICogVGhlIGBzcHJpdGVgIGlucHV0IG9mIHRoZSBgTmd4U3ZnU3ByaXRlRnJhZ21lbnRgIHNob3VsZCByZWZlcmVuY2UgdGhlIGBuYW1lYCBwcm9wZXJ0eSBvZiBhIHByb3ZpZGVkIHNwcml0ZS5cbiAqXG4gKiAjIyMgQXV0byBWaWV3IEJveFxuICpcbiAqIFdoZW4gYSBzeW1ib2wgb2YgYW4gc3ZnIHNwcml0ZSBpcyByZW5kZXJlZCB0aGUgYHZpZXdCb3hgIGF0dHJpYnV0ZSBvciBgaGVpZ2h0YCBhbmQgYHdpZHRoYCBfc2hvdWxkXyBiZSBzZXQuIFRoZSBgc3ZnYCBlbGVtZW50IGRvZXMgbm90IGNvcHkvdXNlIHRoZSBgdmlld0JveGAgYXR0cmlidXRlIG9mIHRoZSBzeW1ib2wgaW4gdGhlIHN2ZyBzcHJpdGUsIHRoZXJlZm9yZSB0aGUgc3ZnIHdpbGwgaGF2ZSBkZWZhdWx0IGRpbWVuc2lvbnMgb2YgMzAweDE1MCBweCwgd2hpY2ggaXMgcHJvYmFibHkgbm90IHByZWZlcnJlZC5cbiAqXG4gKiBQZXIgZGVmYXVsdCB3aGVuIGFuIHN2ZyBzcHJpdGUgaXMgcmVnaXN0ZXJlZCwgdGhlIHN2ZyBzcHJpdGUgaXMgZmV0Y2hlZCB3aXRoIGpzIGluIGFkZGl0aW9uLiBgTmd4U3ZnU3ByaXRlRnJhZ21lbnRgIHdpbGwgY29weSB0aGUgYHZpZXdCb3hgIGF0dHJpYnV0ZSBvZiB0aGUgc3ltYm9sIHRvIGl0cyBob3N0LlxuICpcbiAqIFRoaXMgYmVoYXZpb3IgY2FuIGJlIGRpc2FibGVkLlxuICpcbiAqICMjIyMgRGlzYWJsZSB2aWEgRElcbiAqXG4gKiBBdXRvIFZpZXcgQm94IGlzIGRpc2FibGVkIGZvciB0aGUgc3ZnIHNwcml0ZS5cbiAqXG4gKiBgYGB0c1xuICogcHJvdmlkZVN2Z1Nwcml0ZXMoe1xuICogXHRuYW1lOiAnZmEtYnJhbmRzJyxcbiAqIFx0YmFzZVVybDogJ2Fzc2V0cy9mb250YXdlc29tZS9zcHJpdGVzL2JyYW5kcy5zdmcnLFxuICogXHRhdXRvVmlld0JveDogZmFsc2UsXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyMgRGlzYWJsZSB2aWEgYGF1dG9WaWV3Qm94RGlzYWJsZWRgIElucHV0XG4gKlxuICogQXV0byBWaWV3IEJveCBpcyBkaXNhYmxlZCBmb3IgYSBgc3ZnYCBlbGVtZW50LCB3aGVuIHRoZSBgYXV0b1ZpZXdCb3hEaXNhYmxlZGAgaW5wdXQgaXMgc2V0IHRvIGBmYWxzZWAuXG4gKlxuICogYGBgaHRtbFxuICogPHN2ZyBmcmFnbWVudD1cImdpdGh1YlwiIHNwcml0ZT1cImZhLWJyYW5kc1wiIGF1dG9WaWV3Qm94RGlzYWJsZWQ+PC9zdmc+XG4gKiBgYGBcbiAqXG4gKiAjIyMjIERpc2FibGUgdmlhIGB2aWV3Qm94YCBBdHRyaWJ1dGVcbiAqXG4gKiBBdXRvIFZpZXcgQm94IGlzIGRpc2FibGVkIGZvciBhIGBzdmdgIGVsZW1lbnQsIHdoZW4gdGhlIGB2aWV3Qm94YCBhdHRyaWJ1dGUgYWxyZWFkeSBpcyBkZWZpbmVkLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxzdmcgZnJhZ21lbnQ9XCJnaXRodWJcIiBzcHJpdGU9XCJmYS1icmFuZHNcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCI+PC9zdmc+XG4gKiBgYGBcbiAqXG4gKiAjIyMgQ2xhc3Nlc1xuICpcbiAqIFdoZW4gdGhlIGBjbGFzc2VzYCBmdW5jdGlvbiBpcyBzZXQsIGEgbGlzdCBvZiBjbGFzc2VzIHdpbGwgYmUgYWRkZWQgYnkgdGhlIGBOZ3hTdmdTcHJpdGVGcmFnbWVudGAgdG8gaXRzIGhvc3QuXG4gKlxuICogYGBgdHNcbiAqIHByb3ZpZGVTdmdTcHJpdGVzKHtcbiAqIFx0bmFtZTogJ215LXNwcml0ZScsXG4gKiBcdGJhc2VVcmw6ICdwYXRoL3RvL215L3Nwcml0ZS5zdmcnLFxuICogXHRjbGFzc2VzOiAoZnJhZ21lbnQpID0+IFsnc29tZS1jbGFzcycsIGBzb21lLW90aGVyLWNsYXNzLSR7ZnJhZ21lbnR9YF0sXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyBVcmxcbiAqXG4gKiBQZXIgZGVmYXVsdCB3aGVuIHByb3ZpZGluZyBhIHNwcml0ZSwgdGhlIGB1cmxgIHdpbGwgcmV0dXJuIGAnJHtiYXNlVXJsfSMke2ZyYWdtZW50fSdgLiBUaGlzIGNhbiBiZSBvdmVyd3JpdHRlbjpcbiAqXG4gKiBgYGB0c1xuICogcHJvdmlkZVN2Z1Nwcml0ZXMoe1xuICogXHRuYW1lOiAnbXktc3ByaXRlJyxcbiAqIFx0YmFzZVVybDogJ3BhdGgvdG8vbXkvc3ByaXRlLnN2ZycsXG4gKiBcdHVybDogKGJhc2VVcmwsIGZyYWdtZW50KSA9PiBgJHtiYXNlVXJsfSNzb21lLXByZWZpeC0ke2ZyYWdtZW50fWAsXG4gKiB9KTtcbiAqIGBgYFxuICovXG5ARGlyZWN0aXZlKHtcblx0c2VsZWN0b3I6ICdzdmdbZnJhZ21lbnRdJyxcblx0c3RhbmRhbG9uZTogdHJ1ZSxcbn0pXG5leHBvcnQgY2xhc3MgTmd4U3ZnU3ByaXRlRnJhZ21lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXHQvKipcblx0ICogQGlnbm9yZVxuXHQgKi9cblx0cHJpdmF0ZSByZWFkb25seSBlbGVtZW50ID0gaW5qZWN0KEVsZW1lbnRSZWYpXG5cdFx0Lm5hdGl2ZUVsZW1lbnQgYXMgU1ZHR3JhcGhpY3NFbGVtZW50O1xuXG5cdC8qKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHRwcml2YXRlIHJlYWRvbmx5IGRvY3VtZW50ID0gaW5qZWN0KERPQ1VNRU5UKTtcblxuXHQvKipcblx0ICogQGlnbm9yZVxuXHQgKi9cblx0cHJpdmF0ZSByZWFkb25seSBhdXRvRWZmZWN0ID0gaW5qZWN0QXV0b0VmZmVjdCgpO1xuXG5cdC8qKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHRwcml2YXRlIHJlYWRvbmx5IHNwcml0ZXMgPSBpbmplY3QoTmd4U3ZnU3ByaXRlcyk7XG5cblx0LyoqXG5cdCAqIEBpZ25vcmVcblx0ICovXG5cdHB1YmxpYyBuZ09uSW5pdCgpIHtcblx0XHQvLyBDb3B5IHRoZSAndmlld0JveCcgZnJvbSB0aGUgJ3N5bWJvbCcgZWxlbWVudCBpbiB0aGUgc3ByaXRlIHRvIHRoaXMgc3ZnLlxuXHRcdC8vIERvIG5vdCBsYXVuY2ggdGhpcyBlZmZlY3Qgd2hlbiB0aGUgc3ZnIGFscmVhZHkgaGFzIGEgJ3ZpZXdCb3gnLlxuXHRcdGlmICghdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgndmlld0JveCcpKVxuXHRcdFx0dGhpcy5hdXRvRWZmZWN0KCgpID0+IHtcblx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblx0XHRcdFx0Y29uc3QgYXV0b1ZpZXdCb3ggPSB0aGlzLmF1dG9WaWV3Qm94JCgpO1xuXHRcdFx0XHRjb25zdCBzdmcgPSB0aGlzLnN2ZyQoKTtcblx0XHRcdFx0Y29uc3QgZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50JCgpO1xuXG5cdFx0XHRcdGlmICghYXV0b1ZpZXdCb3ggfHwgc3ZnID09IG51bGwgfHwgZnJhZ21lbnQgPT0gbnVsbCkgcmV0dXJuO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3Qgdmlld0JveCA9IHN2Z1xuXHRcdFx0XHRcdFx0LnF1ZXJ5U2VsZWN0b3IoYCMke2ZyYWdtZW50fWApXG5cdFx0XHRcdFx0XHQ/LmdldEF0dHJpYnV0ZSgndmlld0JveCcpO1xuXG5cdFx0XHRcdFx0aWYgKHZpZXdCb3ggPT0gbnVsbCkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB2aWV3Qm94KTtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0Ly8gdGhlIHF1ZXJ5U2VsZWN0b3IgY291bGQgdGhyb3cgZHVlIHRvIGFuIGludmFsaWQgc2VsZWN0b3Jcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHQvLyBDcmVhdGUgYSAndXNlJyBlbGVtZW50IHdoaWNoIGluc3RhbnRpYXRlcyBhICdzeW1ib2wnIGVsZW1lbnQgb2YgdGhlIHNwcml0ZS5cblx0XHR0aGlzLmF1dG9FZmZlY3QoKCkgPT4ge1xuXHRcdFx0Y29uc3QgZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50JCgpO1xuXHRcdFx0Y29uc3Qgc3ByaXRlID0gdGhpcy5zcHJpdGUkKCk7XG5cdFx0XHRjb25zdCBzcHJpdGVDb25maWcgPSB0aGlzLnNwcml0ZUNvbmZpZyQoKTtcblx0XHRcdGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRjb25zdCBkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnQ7XG5cblx0XHRcdGxldCBjbGFzc2VzOiBzdHJpbmdbXSA9IFtdO1xuXG5cdFx0XHRpZiAoZnJhZ21lbnQgPT0gbnVsbCB8fCBzcHJpdGUgPT0gbnVsbCB8fCBzcHJpdGVDb25maWcgPT0gbnVsbCkgcmV0dXJuO1xuXG5cdFx0XHRjb25zdCB1c2VFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGVsZW1lbnQubmFtZXNwYWNlVVJJLCAndXNlJyk7XG5cblx0XHRcdC8vIEFkZCBjbGFzc2VzIHdoZW4gcHJvdmlkZWQuXG5cdFx0XHRpZiAoc3ByaXRlQ29uZmlnLmNsYXNzZXMgIT0gbnVsbCkge1xuXHRcdFx0XHRjb25zdCBfY2xhc3NlcyA9IHNwcml0ZUNvbmZpZy5jbGFzc2VzKGZyYWdtZW50KTtcblx0XHRcdFx0Y2xhc3NlcyA9XG5cdFx0XHRcdFx0dHlwZW9mIF9jbGFzc2VzID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0PyBfY2xhc3Nlcy5zcGxpdCgnICcpLmZpbHRlcihCb29sZWFuKVxuXHRcdFx0XHRcdFx0OiBfY2xhc3Nlcztcblx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMpO1xuXHRcdFx0fVxuXG5cdFx0XHR1c2VFbGVtZW50LnNldEF0dHJpYnV0ZShcblx0XHRcdFx0J2hyZWYnLFxuXHRcdFx0XHRzcHJpdGVDb25maWcudXJsKHNwcml0ZUNvbmZpZy5iYXNlVXJsLCBmcmFnbWVudCksXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBTdXBwb3J0IG9sZCBicm93c2Vycy4gTW9kZXJuIGJyb3dzZXIgd2lsbCBpZ25vcmUgdGhpcyBpZiB0aGV5IHN1cHBvcnQgJ2hyZWYnLlxuXHRcdFx0dXNlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdCd4bGluazpocmVmJyxcblx0XHRcdFx0c3ByaXRlQ29uZmlnLnVybChzcHJpdGVDb25maWcuYmFzZVVybCwgZnJhZ21lbnQpLFxuXHRcdFx0KTtcblxuXHRcdFx0ZWxlbWVudC5hcHBlbmRDaGlsZCh1c2VFbGVtZW50KTtcblxuXHRcdFx0Ly8gQ2xlYW51cDogY2xlYXIgY2hpbGQgbm9kZXMgYW5kIHJlbW92ZSBvbGQgY2xhc3NlcyBvZiB0aGlzIHN2Zy5cblx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdGVsZW1lbnQucmVwbGFjZUNoaWxkcmVuKCk7XG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBmcmFnbWVudGAgd2hpY2ggaWRlbnRpZmllcyBhIGBzeW1ib2xgIGluIHRoaXMge0BsaW5rIE5neFN2Z1Nwcml0ZUZyYWdtZW50LnNwcml0ZSBzdmcgc3ByaXRlfS5cblx0ICovXG5cdHB1YmxpYyByZWFkb25seSBmcmFnbWVudCQgPSBzaWduYWw8c3RyaW5nIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG5cdC8qKlxuXHQgKiBUaGUgYG5hbWVgIG9mIHRoZSB7QGxpbmsgTmd4U3ZnU3ByaXRlIHN2ZyBzcHJpdGV9IHRoaXMge0BsaW5rIE5neFN2Z1Nwcml0ZUZyYWdtZW50LmZyYWdtZW50IGZyYWdtZW50fSBpcyBhIHBhcnQgb2YuXG5cdCAqXG5cdCAqIEBzZWUge0BsaW5rIE5neFN2Z1Nwcml0ZS5uYW1lfVxuXHQgKi9cblx0cHVibGljIHJlYWRvbmx5IHNwcml0ZSQgPSBzaWduYWw8c3RyaW5nIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIGBhdXRvVmlld0JveGAgaXMgZGlzYWJsZWQuXG5cdCAqXG5cdCAqIEBzZWUgb3ZlcnJpZGVzIHtAbGluayBOZ3hTdmdTcHJpdGUuYXV0b1ZpZXdCb3h9XG5cdCAqL1xuXHRwdWJsaWMgcmVhZG9ubHkgYXV0b1ZpZXdCb3hEaXNhYmxlZCQgPSBzaWduYWwoZmFsc2UpO1xuXG5cdC8qKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHRwcml2YXRlIHJlYWRvbmx5IHNwcml0ZUNvbmZpZyQgPSBjb21wdXRlZCgoKSA9PiB7XG5cdFx0Y29uc3Qgc3ByaXRlID0gdGhpcy5zcHJpdGUkKCk7XG5cblx0XHRpZiAoc3ByaXRlICE9IG51bGwpIHJldHVybiB0aGlzLnNwcml0ZXMuZ2V0KHNwcml0ZSk7XG5cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9KTtcblxuXHQvKipcblx0ICogQGlnbm9yZVxuXHQgKi9cblx0cHJpdmF0ZSByZWFkb25seSBzdmckID0gZGVyaXZlZEZyb20oXG5cdFx0eyBzcHJpdGU6IHRoaXMuc3ByaXRlQ29uZmlnJCB9LFxuXHRcdHBpcGUoc3dpdGNoTWFwKCh7IHNwcml0ZSB9KSA9PiBzcHJpdGU/LnN2ZyQgPz8gb2YodW5kZWZpbmVkKSkpLFxuXHQpO1xuXG5cdC8qKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHRwcml2YXRlIHJlYWRvbmx5IGF1dG9WaWV3Qm94JCA9IGNvbXB1dGVkKFxuXHRcdCgpID0+XG5cdFx0XHQhdGhpcy5hdXRvVmlld0JveERpc2FibGVkJCgpICYmXG5cdFx0XHQodGhpcy5zcHJpdGVDb25maWckKCk/LmF1dG9WaWV3Qm94ID8/IHRydWUpLFxuXHQpO1xuXG5cdC8qKlxuXHQgKiBUaGUgYGZyYWdtZW50YCB3aGljaCBpZGVudGlmaWVzIGEgYHN5bWJvbGAgaW4gdGhpcyB7QGxpbmsgTmd4U3ZnU3ByaXRlRnJhZ21lbnQuc3ByaXRlIHN2ZyBzcHJpdGV9LlxuXHQgKi9cblx0QElucHV0KClcblx0cHVibGljIHNldCBmcmFnbWVudChmcmFnbWVudCkge1xuXHRcdHRoaXMuZnJhZ21lbnQkLnNldChmcmFnbWVudCk7XG5cdH1cblxuXHRwdWJsaWMgZ2V0IGZyYWdtZW50KCkge1xuXHRcdHJldHVybiB0aGlzLmZyYWdtZW50JCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgbmFtZWAgb2YgdGhlIHtAbGluayBOZ3hTdmdTcHJpdGUgc3ZnIHNwcml0ZX0gdGhpcyB7QGxpbmsgTmd4U3ZnU3ByaXRlRnJhZ21lbnQuZnJhZ21lbnQgZnJhZ21lbnR9IGlzIGEgcGFydCBvZi5cblx0ICpcblx0ICogQHNlZSB7QGxpbmsgTmd4U3ZnU3ByaXRlLm5hbWV9XG5cdCAqL1xuXHRASW5wdXQoKVxuXHRwdWJsaWMgc2V0IHNwcml0ZShzcHJpdGUpIHtcblx0XHR0aGlzLnNwcml0ZSQuc2V0KHNwcml0ZSk7XG5cdH1cblxuXHRwdWJsaWMgZ2V0IHNwcml0ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5zcHJpdGUkKCk7XG5cdH1cblxuXHQvKipcblx0ICogV2hldGhlciBgYXV0b1ZpZXdCb3hgIGlzIGRpc2FibGVkLlxuXHQgKlxuXHQgKiBAc2VlIG92ZXJyaWRlcyB7QGxpbmsgTmd4U3ZnU3ByaXRlLmF1dG9WaWV3Qm94fVxuXHQgKi9cblx0QElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG5cdHB1YmxpYyBzZXQgYXV0b1ZpZXdCb3hEaXNhYmxlZChhdXRvVmlld0JveERpc2FibGVkKSB7XG5cdFx0dGhpcy5hdXRvVmlld0JveERpc2FibGVkJC5zZXQoYXV0b1ZpZXdCb3hEaXNhYmxlZCk7XG5cdH1cblxuXHRwdWJsaWMgZ2V0IGF1dG9WaWV3Qm94RGlzYWJsZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXV0b1ZpZXdCb3hEaXNhYmxlZCQoKTtcblx0fVxufVxuIl19