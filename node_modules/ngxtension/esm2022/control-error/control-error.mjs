import { Directive, InjectionToken, Input, TemplateRef, ViewContainerRef, inject, signal, } from '@angular/core';
import { takeUntilDestroyed, toObservable, toSignal, } from '@angular/core/rxjs-interop';
import { FormGroupDirective, NgForm, } from '@angular/forms';
import { filterNil } from 'ngxtension/filter-nil';
import { BehaviorSubject, combineLatest, distinctUntilChanged, map, of, shareReplay, startWith, switchMap, } from 'rxjs';
import * as i0 from "@angular/core";
export const dirty$ = (control) => {
    const dirty$ = new BehaviorSubject(control.dirty);
    const markAsPristine = control.markAsPristine.bind(control);
    const markAsDirty = control.markAsDirty.bind(control);
    control.markAsPristine = (...args) => {
        markAsPristine(...args);
        dirty$.next(false);
    };
    control.markAsDirty = (...args) => {
        markAsDirty(...args);
        dirty$.next(true);
    };
    return dirty$.pipe(distinctUntilChanged());
};
export const touched$ = (control) => {
    const touched$ = new BehaviorSubject(control.touched);
    const markAsTouched = control.markAsTouched.bind(control);
    const markAsUntouched = control.markAsUntouched.bind(control);
    control.markAsTouched = (...args) => {
        markAsTouched(...args);
        touched$.next(true);
    };
    control.markAsUntouched = (...args) => {
        markAsUntouched(...args);
        touched$.next(false);
    };
    return touched$.pipe(distinctUntilChanged());
};
/**
 * Emits whenever the value, status, touched/untouched state of the control changes or the parent submits.
 *
 * Evaluates to `true` when the control status is `INVALID` and it is `touched` or the parent is `submitted`.
 */
export const NGX_DEFAULT_CONTROL_ERROR_STATE_MATCHER = (control, parent) => combineLatest([
    control.valueChanges.pipe(startWith(control.value)),
    control.statusChanges.pipe(startWith(control.status), distinctUntilChanged()),
    touched$(control),
    parent?.ngSubmit.pipe(map(() => true), startWith(parent.submitted), distinctUntilChanged()) ?? of(false),
], (value, status, touched, submitted) => status === 'INVALID' && (touched || submitted));
export const NGX_CONTROL_ERROR_STATE_MATCHER = new InjectionToken('NGX_CONTROL_ERROR_STATE_MATCHER', { factory: () => NGX_DEFAULT_CONTROL_ERROR_STATE_MATCHER });
export const NGX_CONTROL_ERROR_PARENT = new InjectionToken('NGX_CONTROL_ERROR_PARENT');
/**
 * Configures {@link NgxControlError}.
 */
export const provideNgxControlError = (options) => {
    const provider = [];
    if (options?.errorStateMatcher)
        provider.push({
            provide: NGX_CONTROL_ERROR_STATE_MATCHER,
            useFactory: options.errorStateMatcher,
        });
    if (options?.parent)
        provider.push({
            provide: NGX_CONTROL_ERROR_PARENT,
            useFactory: options.parent,
        });
    return provider;
};
/**
 * Structural directive for displaying form control errors consistently and reduce boilerplate.
 *
 * ## Usage
 *
 * ```html
 * <label>
 * 	<b>Name</b>
 * 	<input type="text" [formControl]="name" />
 * 	<strong *ngxControlError="name; track: 'required'">Name is required.</strong>
 * </label>
 * ```
 *
 * The template will be rendered, when the control is in an [_error state_](#configuration) and its errors include the tracked error(s).
 *
 * without `NgxControlError`:
 *
 * ```html
 * <label>
 * 	<b>Name</b>
 * 	<input type="text" [formControl]="name" />
 * 	@if (name.hasError('required') && (name.touched || form.submitted)) {
 * 	<strong>Name is required.</strong>
 * 	}
 * </label>
 * ```
 *
 * ## Configuration
 *
 * A `StateMatcher` defines when the provided control is in an _error state_.
 * A `StateMatcher` is a function which returns an observable. Every time the `StateMatcher` emits a value, the directive checks whether it should render or hide its template:
 * The directive renders its template when the `StateMatcher` emits `true` and the errors of the control include at least 1 tracked error, else its template will be hidden.
 *
 * ```ts
 * export type StateMatcher = (
 * control: AbstractControl,
 * parent?: FormGroupDirective | NgForm,
 * ) => Observable<boolean>;
 * ```
 *
 * Per default the control is considered in an _error state_ when 1. its status is `INVALID` and 2. it is `touched` or its form has been `submitted`.
 *
 * You can override this behavior:
 *
 * ```ts
 * //
 * // A control is in an error state when its status is invalid.
 * // Emits whenever statusChanges emits.
 * // You may want to add more sources, such as valueChanges.
 * //
 * export const customErrorStateMatcher: StateMatcher = (control) =>
 * control.statusChanges.pipe(
 * startWith(control.status),
 * map((status) => status === 'INVALID'),
 * );
 * ```
 *
 * ### Via DI
 *
 * ```ts
 * provideNgxControlError({ errorStateMatcher: customErrorStateMatcher });
 * ```
 *
 * ### Via Input
 *
 * ```html
 * <label>
 * 	<b>Name</b>
 * 	<input type="text" [formControl]="name" />
 * 	<strong *ngxControlError="name; track: 'required'; errorStateMatcher: customErrorStateMatcher">Name is required.</strong>
 * </label>
 * ```
 *
 * ## Integration
 *
 * ### [NGX Translate](https://github.com/ngx-translate/core)
 *
 * You can iterate over all possible errors and pass the `errors` to the translate pipe:
 *
 * ```html
 * <label>
 * 	<b>Mail</b>
 * 	<input type="email" [formControl]="mail" />
 * 	@for (error of ['required', 'email', 'myCustomError']; track error) {
 * 	<strong *ngxControlError="mail; track: error">{{ "PATH.TO.MAIL_CONTROL.ERRORS." + error | translate: mail.errors }}</strong>
 * 	}
 * </label>
 * ```
 *
 * ### [Angular Material](https://github.com/angular/components)
 *
 * ```html
 * <mat-form-field>
 * 	<mat-label>Name</mat-label>
 * 	<input matInput [formControl]="name" />
 * 	<mat-error *ngxControlError="name; track: 'required'">Name is required.</mat-error>
 * </mat-form-field>
 * ```
 */
export class NgxControlError {
    constructor() {
        /** @ignore */
        this.templateRef = inject(TemplateRef);
        /** @ignore */
        this.viewContainerRef = inject(ViewContainerRef);
        /**
         * The errors this directive tracks, when a {@link control$ control} is provided.
         */
        this.track$ = signal(undefined);
        /**
         * The parent of this {@link control$ control}.
         *
         * NOTE: Might not be the control referenced by {@link AbstractControl.parent parent} of this {@link control$ control}.
         */
        this.parent$ = signal(inject(NGX_CONTROL_ERROR_PARENT, { optional: true }) ??
            inject(FormGroupDirective, { optional: true }) ??
            inject(NgForm, { optional: true }) ??
            undefined);
        /**
         * The control which `errors` are tracked.
         *
         * @see {@link AbstractControl.errors}
         */
        this.control$ = signal(undefined);
        /**
         *  A `StateMatcher` which defines when this {@link control$ control} is in an *error state*.
         *  This directive **ONLY** renders this template when the `StateMatcher` evaluates to `true`.
         *
         *  Defaults to {@link NGX_CONTROL_ERROR_STATE_MATCHER}.
         */
        this.errorStateMatcher$ = signal(inject(NGX_CONTROL_ERROR_STATE_MATCHER));
        /**
         * Whether this {@link control$ control's} errors include one of the {@link track$ tracked errors} and whether it is in an *{@link errorState$ error state}*.
         */
        this._hasError$ = combineLatest([
            toObservable(this.track$),
            toObservable(this.errorStateMatcher$),
            toObservable(this.control$).pipe(filterNil()),
            toObservable(this.parent$),
        ]).pipe(switchMap(([track, errorStateMatcher, control, parent]) => errorStateMatcher(control, parent).pipe(map((errorState) => errorState &&
            track != null &&
            control != null &&
            (typeof track === 'string'
                ? control.hasError(track)
                : track.some((x) => control.hasError(x)))))), shareReplay(1));
        /**
         * Whether this {@link control$ control's} errors include one of the {@link track$ tracked errors} and whether it is in an *{@link errorState$ error state}*.
         */
        this.hasError$ = toSignal(this._hasError$, {
            initialValue: false,
        });
        // Whenever one of the tracked errors are included in the controls errors and the control is in an error state, render this template.
        combineLatest([toObservable(this.track$), toObservable(this.control$), this._hasError$], (track, control, hasError) => {
            this.viewContainerRef.clear();
            if (hasError && control != null && track != null)
                this.viewContainerRef.createEmbeddedView(this.templateRef, {
                    $implicit: control.errors ?? {},
                    track,
                    control,
                });
        })
            .pipe(takeUntilDestroyed())
            .subscribe();
    }
    /**
     * The errors this directive tracks, when a {@link control$ control} is provided.
     */
    set track(track) {
        this.track$.set(track);
    }
    get track() {
        return this.track$();
    }
    /**
     * The control which `errors` are tracked.
     *
     * @see {@link AbstractControl.errors}
     */
    set control(control) {
        this.control$.set(control);
    }
    get control() {
        return this.control$();
    }
    /**
     *  A `StateMatcher` which defines when this {@link control$ control} is in an *error state*.
     *  This directive **ONLY** renders this template when the `StateMatcher` evaluates to `true`.
     *
     *  Defaults to {@link NGX_CONTROL_ERROR_STATE_MATCHER}.
     */
    set errorStateMatcher(errorStateMatcher) {
        this.errorStateMatcher$.set(errorStateMatcher);
    }
    get errorStateMatcher() {
        return this.errorStateMatcher$();
    }
    /**
     * The parent of this {@link control$ control}.
     *
     * NOTE: Might not be the control referenced by {@link AbstractControl.parent parent} of this {@link control$ control}.
     */
    set parent(parent) {
        this.parent$.set(parent);
    }
    get parent() {
        return this.parent$();
    }
    /**
     * The context of this template.
     */
    get context() {
        return this.viewContainerRef.get(0)?.context;
    }
    /** @ignore */
    static { this.ngTemplateContextGuard = (directive, context) => true; }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxControlError, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.3", type: NgxControlError, isStandalone: true, selector: "[ngxControlError]", inputs: { track: ["ngxControlErrorTrack", "track"], control: ["ngxControlError", "control"], errorStateMatcher: ["ngxControlErrorErrorStateMatcher", "errorStateMatcher"], parent: ["ngxControlErrorParent", "parent"] }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: NgxControlError, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngxControlError]',
                    standalone: true,
                }]
        }], ctorParameters: () => [], propDecorators: { track: [{
                type: Input,
                args: [{ alias: 'ngxControlErrorTrack', required: true }]
            }], control: [{
                type: Input,
                args: [{ alias: 'ngxControlError', required: true }]
            }], errorStateMatcher: [{
                type: Input,
                args: [{ alias: 'ngxControlErrorErrorStateMatcher' }]
            }], parent: [{
                type: Input,
                args: [{ alias: 'ngxControlErrorParent' }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbC1lcnJvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvbmd4dGVuc2lvbi9jb250cm9sLWVycm9yL3NyYy9jb250cm9sLWVycm9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTixTQUFTLEVBRVQsY0FBYyxFQUNkLEtBQUssRUFDTCxXQUFXLEVBQ1gsZ0JBQWdCLEVBQ2hCLE1BQU0sRUFDTixNQUFNLEdBRU4sTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNOLGtCQUFrQixFQUNsQixZQUFZLEVBQ1osUUFBUSxHQUNSLE1BQU0sNEJBQTRCLENBQUM7QUFDcEMsT0FBTyxFQUVOLGtCQUFrQixFQUNsQixNQUFNLEdBRU4sTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDbEQsT0FBTyxFQUNOLGVBQWUsRUFFZixhQUFhLEVBQ2Isb0JBQW9CLEVBQ3BCLEdBQUcsRUFDSCxFQUFFLEVBQ0YsV0FBVyxFQUNYLFNBQVMsRUFDVCxTQUFTLEdBQ1QsTUFBTSxNQUFNLENBQUM7O0FBRWQsTUFBTSxDQUFDLE1BQU0sTUFBTSxHQUFHLENBQUMsT0FBd0IsRUFBRSxFQUFFO0lBQ2xELE1BQU0sTUFBTSxHQUFHLElBQUksZUFBZSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUVsRCxNQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUU1RCxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUV0RCxPQUFPLENBQUMsY0FBYyxHQUFHLENBQ3hCLEdBQUcsSUFBbUQsRUFDckQsRUFBRTtRQUNILGNBQWMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO1FBQ3hCLE1BQU0sQ0FBQyxJQUFJLENBQUMs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LE9BQU8sRUFBRSxDQUFDO0lBQ3ZCLENBQUM7SUFvQ0Q7O09BRUc7SUFDSCxJQUFXLE9BQU87UUFDakIsT0FDQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FDM0IsRUFBRSxPQUFPLENBQUM7SUFDWixDQUFDO0lBa0NELGNBQWM7YUFDQSwyQkFBc0IsR0FBRyxDQUN0QyxTQUEwQixFQUMxQixPQUFnQixFQUNvQixFQUFFLENBQUMsSUFBSSxBQUhSLENBR1M7OEdBaEtqQyxlQUFlO2tHQUFmLGVBQWU7OzJGQUFmLGVBQWU7a0JBSjNCLFNBQVM7bUJBQUM7b0JBQ1YsUUFBUSxFQUFFLG1CQUFtQjtvQkFDN0IsVUFBVSxFQUFFLElBQUk7aUJBQ2hCO3dEQStCVyxLQUFLO3NCQURmLEtBQUs7dUJBQUMsRUFBRSxLQUFLLEVBQUUsc0JBQXNCLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRTtnQkFlN0MsT0FBTztzQkFEakIsS0FBSzt1QkFBQyxFQUFFLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFO2dCQWdCeEMsaUJBQWlCO3NCQUQzQixLQUFLO3VCQUFDLEVBQUUsS0FBSyxFQUFFLGtDQUFrQyxFQUFFO2dCQWV6QyxNQUFNO3NCQURoQixLQUFLO3VCQUFDLEVBQUUsS0FBSyxFQUFFLHVCQUF1QixFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0RGlyZWN0aXZlLFxuXHRFbWJlZGRlZFZpZXdSZWYsXG5cdEluamVjdGlvblRva2VuLFxuXHRJbnB1dCxcblx0VGVtcGxhdGVSZWYsXG5cdFZpZXdDb250YWluZXJSZWYsXG5cdGluamVjdCxcblx0c2lnbmFsLFxuXHR0eXBlIFByb3ZpZGVyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG5cdHRha2VVbnRpbERlc3Ryb3llZCxcblx0dG9PYnNlcnZhYmxlLFxuXHR0b1NpZ25hbCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZS9yeGpzLWludGVyb3AnO1xuaW1wb3J0IHtcblx0QWJzdHJhY3RDb250cm9sLFxuXHRGb3JtR3JvdXBEaXJlY3RpdmUsXG5cdE5nRm9ybSxcblx0dHlwZSBWYWxpZGF0aW9uRXJyb3JzLFxufSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBmaWx0ZXJOaWwgfSBmcm9tICduZ3h0ZW5zaW9uL2ZpbHRlci1uaWwnO1xuaW1wb3J0IHtcblx0QmVoYXZpb3JTdWJqZWN0LFxuXHRPYnNlcnZhYmxlLFxuXHRjb21iaW5lTGF0ZXN0LFxuXHRkaXN0aW5jdFVudGlsQ2hhbmdlZCxcblx0bWFwLFxuXHRvZixcblx0c2hhcmVSZXBsYXksXG5cdHN0YXJ0V2l0aCxcblx0c3dpdGNoTWFwLFxufSBmcm9tICdyeGpzJztcblxuZXhwb3J0IGNvbnN0IGRpcnR5JCA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpID0+IHtcblx0Y29uc3QgZGlydHkkID0gbmV3IEJlaGF2aW9yU3ViamVjdChjb250cm9sLmRpcnR5KTtcblxuXHRjb25zdCBtYXJrQXNQcmlzdGluZSA9IGNvbnRyb2wubWFya0FzUHJpc3RpbmUuYmluZChjb250cm9sKTtcblxuXHRjb25zdCBtYXJrQXNEaXJ0eSA9IGNvbnRyb2wubWFya0FzRGlydHkuYmluZChjb250cm9sKTtcblxuXHRjb250cm9sLm1hcmtBc1ByaXN0aW5lID0gKFxuXHRcdC4uLmFyZ3M6IFBhcmFtZXRlcnM8QWJzdHJhY3RDb250cm9sWydtYXJrQXNQcmlzdGluZSddPlxuXHQpID0+IHtcblx0XHRtYXJrQXNQcmlzdGluZSguLi5hcmdzKTtcblx0XHRkaXJ0eSQubmV4dChmYWxzZSk7XG5cdH07XG5cblx0Y29udHJvbC5tYXJrQXNEaXJ0eSA9IChcblx0XHQuLi5hcmdzOiBQYXJhbWV0ZXJzPEFic3RyYWN0Q29udHJvbFsnbWFya0FzRGlydHknXT5cblx0KSA9PiB7XG5cdFx0bWFya0FzRGlydHkoLi4uYXJncyk7XG5cdFx0ZGlydHkkLm5leHQodHJ1ZSk7XG5cdH07XG5cblx0cmV0dXJuIGRpcnR5JC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRvdWNoZWQkID0gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCkgPT4ge1xuXHRjb25zdCB0b3VjaGVkJCA9IG5ldyBCZWhhdmlvclN1YmplY3QoY29udHJvbC50b3VjaGVkKTtcblxuXHRjb25zdCBtYXJrQXNUb3VjaGVkID0gY29udHJvbC5tYXJrQXNUb3VjaGVkLmJpbmQoY29udHJvbCk7XG5cblx0Y29uc3QgbWFya0FzVW50b3VjaGVkID0gY29udHJvbC5tYXJrQXNVbnRvdWNoZWQuYmluZChjb250cm9sKTtcblxuXHRjb250cm9sLm1hcmtBc1RvdWNoZWQgPSAoXG5cdFx0Li4uYXJnczogUGFyYW1ldGVyczxBYnN0cmFjdENvbnRyb2xbJ21hcmtBc1RvdWNoZWQnXT5cblx0KSA9PiB7XG5cdFx0bWFya0FzVG91Y2hlZCguLi5hcmdzKTtcblx0XHR0b3VjaGVkJC5uZXh0KHRydWUpO1xuXHR9O1xuXG5cdGNvbnRyb2wubWFya0FzVW50b3VjaGVkID0gKFxuXHRcdC4uLmFyZ3M6IFBhcmFtZXRlcnM8QWJzdHJhY3RDb250cm9sWydtYXJrQXNVbnRvdWNoZWQnXT5cblx0KSA9PiB7XG5cdFx0bWFya0FzVW50b3VjaGVkKC4uLmFyZ3MpO1xuXHRcdHRvdWNoZWQkLm5leHQoZmFsc2UpO1xuXHR9O1xuXG5cdHJldHVybiB0b3VjaGVkJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xufTtcblxuLyoqXG4gKiAgRGVmaW5lcyB3aGVuIGEge0BsaW5rIEFic3RyYWN0Q29udHJvbCBjb250cm9sfSBpcyBpbiBhbiAqc3RhdGUqLlxuICovXG5leHBvcnQgdHlwZSBTdGF0ZU1hdGNoZXIgPSAoXG5cdGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCxcblx0cGFyZW50PzogRm9ybUdyb3VwRGlyZWN0aXZlIHwgTmdGb3JtLFxuKSA9PiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xuXG4vKipcbiAqIEVtaXRzIHdoZW5ldmVyIHRoZSB2YWx1ZSwgc3RhdHVzLCB0b3VjaGVkL3VudG91Y2hlZCBzdGF0ZSBvZiB0aGUgY29udHJvbCBjaGFuZ2VzIG9yIHRoZSBwYXJlbnQgc3VibWl0cy5cbiAqXG4gKiBFdmFsdWF0ZXMgdG8gYHRydWVgIHdoZW4gdGhlIGNvbnRyb2wgc3RhdHVzIGlzIGBJTlZBTElEYCBhbmQgaXQgaXMgYHRvdWNoZWRgIG9yIHRoZSBwYXJlbnQgaXMgYHN1Ym1pdHRlZGAuXG4gKi9cbmV4cG9ydCBjb25zdCBOR1hfREVGQVVMVF9DT05UUk9MX0VSUk9SX1NUQVRFX01BVENIRVI6IFN0YXRlTWF0Y2hlciA9IChcblx0Y29udHJvbCxcblx0cGFyZW50LFxuKSA9PlxuXHRjb21iaW5lTGF0ZXN0KFxuXHRcdFtcblx0XHRcdGNvbnRyb2wudmFsdWVDaGFuZ2VzLnBpcGUoc3RhcnRXaXRoKGNvbnRyb2wudmFsdWUpKSxcblx0XHRcdGNvbnRyb2wuc3RhdHVzQ2hhbmdlcy5waXBlKFxuXHRcdFx0XHRzdGFydFdpdGgoY29udHJvbC5zdGF0dXMpLFxuXHRcdFx0XHRkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuXHRcdFx0KSxcblx0XHRcdHRvdWNoZWQkKGNvbnRyb2wpLFxuXHRcdFx0cGFyZW50Py5uZ1N1Ym1pdC5waXBlKFxuXHRcdFx0XHRtYXAoKCkgPT4gdHJ1ZSksXG5cdFx0XHRcdHN0YXJ0V2l0aChwYXJlbnQuc3VibWl0dGVkKSxcblx0XHRcdFx0ZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcblx0XHRcdCkgPz8gb2YoZmFsc2UpLFxuXHRcdF0sXG5cdFx0KHZhbHVlLCBzdGF0dXMsIHRvdWNoZWQsIHN1Ym1pdHRlZCkgPT5cblx0XHRcdHN0YXR1cyA9PT0gJ0lOVkFMSUQnICYmICh0b3VjaGVkIHx8IHN1Ym1pdHRlZCksXG5cdCk7XG5cbmV4cG9ydCBjb25zdCBOR1hfQ09OVFJPTF9FUlJPUl9TVEFURV9NQVRDSEVSID0gbmV3IEluamVjdGlvblRva2VuPFN0YXRlTWF0Y2hlcj4oXG5cdCdOR1hfQ09OVFJPTF9FUlJPUl9TVEFURV9NQVRDSEVSJyxcblx0eyBmYWN0b3J5OiAoKSA9PiBOR1hfREVGQVVMVF9DT05UUk9MX0VSUk9SX1NUQVRFX01BVENIRVIgfSxcbik7XG5cbmV4cG9ydCBjb25zdCBOR1hfQ09OVFJPTF9FUlJPUl9QQVJFTlQgPSBuZXcgSW5qZWN0aW9uVG9rZW48XG5cdEZvcm1Hcm91cERpcmVjdGl2ZSB8IE5nRm9ybVxuPignTkdYX0NPTlRST0xfRVJST1JfUEFSRU5UJyk7XG5cbi8qKlxuICogQ29uZmlndXJlcyB7QGxpbmsgTmd4Q29udHJvbEVycm9yfS5cbiAqL1xuZXhwb3J0IGNvbnN0IHByb3ZpZGVOZ3hDb250cm9sRXJyb3IgPSAob3B0aW9ucz86IHtcblx0ZXJyb3JTdGF0ZU1hdGNoZXI/OiAoKSA9PiBTdGF0ZU1hdGNoZXI7XG5cdHBhcmVudD86ICgpID0+IE5nRm9ybSB8IEZvcm1Hcm91cERpcmVjdGl2ZTtcbn0pOiBQcm92aWRlcltdID0+IHtcblx0Y29uc3QgcHJvdmlkZXIgPSBbXTtcblxuXHRpZiAob3B0aW9ucz8uZXJyb3JTdGF0ZU1hdGNoZXIpXG5cdFx0cHJvdmlkZXIucHVzaCh7XG5cdFx0XHRwcm92aWRlOiBOR1hfQ09OVFJPTF9FUlJPUl9TVEFURV9NQVRDSEVSLFxuXHRcdFx0dXNlRmFjdG9yeTogb3B0aW9ucy5lcnJvclN0YXRlTWF0Y2hlcixcblx0XHR9KTtcblxuXHRpZiAob3B0aW9ucz8ucGFyZW50KVxuXHRcdHByb3ZpZGVyLnB1c2goe1xuXHRcdFx0cHJvdmlkZTogTkdYX0NPTlRST0xfRVJST1JfUEFSRU5ULFxuXHRcdFx0dXNlRmFjdG9yeTogb3B0aW9ucy5wYXJlbnQsXG5cdFx0fSk7XG5cblx0cmV0dXJuIHByb3ZpZGVyO1xufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb250ZXh0IG9mIHRoZSB0ZW1wbGF0ZSB0aGUge0BsaW5rIE5neENvbnRyb2xFcnJvcn0gc2l0cyBvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZ3hDb250cm9sRXJyb3JDb250ZXh0IHtcblx0LyoqXG5cdCAqIFJlZmVyZW5jZSB0byB0aGUgYGVycm9yc2Agb2Yge0BsaW5rIE5neENvbnRyb2xFcnJvci5jb250cm9sfVxuXHQgKi9cblx0JGltcGxpY2l0OiBWYWxpZGF0aW9uRXJyb3JzO1xuXG5cdC8qKlxuXHQgKiBSZWZlcmVuY2UgdG8ge0BsaW5rIE5neENvbnRyb2xFcnJvci5jb250cm9sfVxuXHQgKi9cblx0Y29udHJvbDogQWJzdHJhY3RDb250cm9sO1xuXG5cdC8qKlxuXHQgKiBSZWZlcmVuY2UgdG8ge0BsaW5rIE5neENvbnRyb2xFcnJvci50cmFja31cblx0ICovXG5cdHRyYWNrOiBzdHJpbmcgfCBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBTdHJ1Y3R1cmFsIGRpcmVjdGl2ZSBmb3IgZGlzcGxheWluZyBmb3JtIGNvbnRyb2wgZXJyb3JzIGNvbnNpc3RlbnRseSBhbmQgcmVkdWNlIGJvaWxlcnBsYXRlLlxuICpcbiAqICMjIFVzYWdlXG4gKlxuICogYGBgaHRtbFxuICogPGxhYmVsPlxuICogXHQ8Yj5OYW1lPC9iPlxuICogXHQ8aW5wdXQgdHlwZT1cInRleHRcIiBbZm9ybUNvbnRyb2xdPVwibmFtZVwiIC8+XG4gKiBcdDxzdHJvbmcgKm5neENvbnRyb2xFcnJvcj1cIm5hbWU7IHRyYWNrOiAncmVxdWlyZWQnXCI+TmFtZSBpcyByZXF1aXJlZC48L3N0cm9uZz5cbiAqIDwvbGFiZWw+XG4gKiBgYGBcbiAqXG4gKiBUaGUgdGVtcGxhdGUgd2lsbCBiZSByZW5kZXJlZCwgd2hlbiB0aGUgY29udHJvbCBpcyBpbiBhbiBbX2Vycm9yIHN0YXRlX10oI2NvbmZpZ3VyYXRpb24pIGFuZCBpdHMgZXJyb3JzIGluY2x1ZGUgdGhlIHRyYWNrZWQgZXJyb3IocykuXG4gKlxuICogd2l0aG91dCBgTmd4Q29udHJvbEVycm9yYDpcbiAqXG4gKiBgYGBodG1sXG4gKiA8bGFiZWw+XG4gKiBcdDxiPk5hbWU8L2I+XG4gKiBcdDxpbnB1dCB0eXBlPVwidGV4dFwiIFtmb3JtQ29udHJvbF09XCJuYW1lXCIgLz5cbiAqIFx0QGlmIChuYW1lLmhhc0Vycm9yKCdyZXF1aXJlZCcpICYmIChuYW1lLnRvdWNoZWQgfHwgZm9ybS5zdWJtaXR0ZWQpKSB7XG4gKiBcdDxzdHJvbmc+TmFtZSBpcyByZXF1aXJlZC48L3N0cm9uZz5cbiAqIFx0fVxuICogPC9sYWJlbD5cbiAqIGBgYFxuICpcbiAqICMjIENvbmZpZ3VyYXRpb25cbiAqXG4gKiBBIGBTdGF0ZU1hdGNoZXJgIGRlZmluZXMgd2hlbiB0aGUgcHJvdmlkZWQgY29udHJvbCBpcyBpbiBhbiBfZXJyb3Igc3RhdGVfLlxuICogQSBgU3RhdGVNYXRjaGVyYCBpcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JzZXJ2YWJsZS4gRXZlcnkgdGltZSB0aGUgYFN0YXRlTWF0Y2hlcmAgZW1pdHMgYSB2YWx1ZSwgdGhlIGRpcmVjdGl2ZSBjaGVja3Mgd2hldGhlciBpdCBzaG91bGQgcmVuZGVyIG9yIGhpZGUgaXRzIHRlbXBsYXRlOlxuICogVGhlIGRpcmVjdGl2ZSByZW5kZXJzIGl0cyB0ZW1wbGF0ZSB3aGVuIHRoZSBgU3RhdGVNYXRjaGVyYCBlbWl0cyBgdHJ1ZWAgYW5kIHRoZSBlcnJvcnMgb2YgdGhlIGNvbnRyb2wgaW5jbHVkZSBhdCBsZWFzdCAxIHRyYWNrZWQgZXJyb3IsIGVsc2UgaXRzIHRlbXBsYXRlIHdpbGwgYmUgaGlkZGVuLlxuICpcbiAqIGBgYHRzXG4gKiBleHBvcnQgdHlwZSBTdGF0ZU1hdGNoZXIgPSAoXG4gKiBjb250cm9sOiBBYnN0cmFjdENvbnRyb2wsXG4gKiBwYXJlbnQ/OiBGb3JtR3JvdXBEaXJlY3RpdmUgfCBOZ0Zvcm0sXG4gKiApID0+IE9ic2VydmFibGU8Ym9vbGVhbj47XG4gKiBgYGBcbiAqXG4gKiBQZXIgZGVmYXVsdCB0aGUgY29udHJvbCBpcyBjb25zaWRlcmVkIGluIGFuIF9lcnJvciBzdGF0ZV8gd2hlbiAxLiBpdHMgc3RhdHVzIGlzIGBJTlZBTElEYCBhbmQgMi4gaXQgaXMgYHRvdWNoZWRgIG9yIGl0cyBmb3JtIGhhcyBiZWVuIGBzdWJtaXR0ZWRgLlxuICpcbiAqIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvcjpcbiAqXG4gKiBgYGB0c1xuICogLy9cbiAqIC8vIEEgY29udHJvbCBpcyBpbiBhbiBlcnJvciBzdGF0ZSB3aGVuIGl0cyBzdGF0dXMgaXMgaW52YWxpZC5cbiAqIC8vIEVtaXRzIHdoZW5ldmVyIHN0YXR1c0NoYW5nZXMgZW1pdHMuXG4gKiAvLyBZb3UgbWF5IHdhbnQgdG8gYWRkIG1vcmUgc291cmNlcywgc3VjaCBhcyB2YWx1ZUNoYW5nZXMuXG4gKiAvL1xuICogZXhwb3J0IGNvbnN0IGN1c3RvbUVycm9yU3RhdGVNYXRjaGVyOiBTdGF0ZU1hdGNoZXIgPSAoY29udHJvbCkgPT5cbiAqIGNvbnRyb2wuc3RhdHVzQ2hhbmdlcy5waXBlKFxuICogc3RhcnRXaXRoKGNvbnRyb2wuc3RhdHVzKSxcbiAqIG1hcCgoc3RhdHVzKSA9PiBzdGF0dXMgPT09ICdJTlZBTElEJyksXG4gKiApO1xuICogYGBgXG4gKlxuICogIyMjIFZpYSBESVxuICpcbiAqIGBgYHRzXG4gKiBwcm92aWRlTmd4Q29udHJvbEVycm9yKHsgZXJyb3JTdGF0ZU1hdGNoZXI6IGN1c3RvbUVycm9yU3RhdGVNYXRjaGVyIH0pO1xuICogYGBgXG4gKlxuICogIyMjIFZpYSBJbnB1dFxuICpcbiAqIGBgYGh0bWxcbiAqIDxsYWJlbD5cbiAqIFx0PGI+TmFtZTwvYj5cbiAqIFx0PGlucHV0IHR5cGU9XCJ0ZXh0XCIgW2Zvcm1Db250cm9sXT1cIm5hbWVcIiAvPlxuICogXHQ8c3Ryb25nICpuZ3hDb250cm9sRXJyb3I9XCJuYW1lOyB0cmFjazogJ3JlcXVpcmVkJzsgZXJyb3JTdGF0ZU1hdGNoZXI6IGN1c3RvbUVycm9yU3RhdGVNYXRjaGVyXCI+TmFtZSBpcyByZXF1aXJlZC48L3N0cm9uZz5cbiAqIDwvbGFiZWw+XG4gKiBgYGBcbiAqXG4gKiAjIyBJbnRlZ3JhdGlvblxuICpcbiAqICMjIyBbTkdYIFRyYW5zbGF0ZV0oaHR0cHM6Ly9naXRodWIuY29tL25neC10cmFuc2xhdGUvY29yZSlcbiAqXG4gKiBZb3UgY2FuIGl0ZXJhdGUgb3ZlciBhbGwgcG9zc2libGUgZXJyb3JzIGFuZCBwYXNzIHRoZSBgZXJyb3JzYCB0byB0aGUgdHJhbnNsYXRlIHBpcGU6XG4gKlxuICogYGBgaHRtbFxuICogPGxhYmVsPlxuICogXHQ8Yj5NYWlsPC9iPlxuICogXHQ8aW5wdXQgdHlwZT1cImVtYWlsXCIgW2Zvcm1Db250cm9sXT1cIm1haWxcIiAvPlxuICogXHRAZm9yIChlcnJvciBvZiBbJ3JlcXVpcmVkJywgJ2VtYWlsJywgJ215Q3VzdG9tRXJyb3InXTsgdHJhY2sgZXJyb3IpIHtcbiAqIFx0PHN0cm9uZyAqbmd4Q29udHJvbEVycm9yPVwibWFpbDsgdHJhY2s6IGVycm9yXCI+e3sgXCJQQVRILlRPLk1BSUxfQ09OVFJPTC5FUlJPUlMuXCIgKyBlcnJvciB8IHRyYW5zbGF0ZTogbWFpbC5lcnJvcnMgfX08L3N0cm9uZz5cbiAqIFx0fVxuICogPC9sYWJlbD5cbiAqIGBgYFxuICpcbiAqICMjIyBbQW5ndWxhciBNYXRlcmlhbF0oaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvY29tcG9uZW50cylcbiAqXG4gKiBgYGBodG1sXG4gKiA8bWF0LWZvcm0tZmllbGQ+XG4gKiBcdDxtYXQtbGFiZWw+TmFtZTwvbWF0LWxhYmVsPlxuICogXHQ8aW5wdXQgbWF0SW5wdXQgW2Zvcm1Db250cm9sXT1cIm5hbWVcIiAvPlxuICogXHQ8bWF0LWVycm9yICpuZ3hDb250cm9sRXJyb3I9XCJuYW1lOyB0cmFjazogJ3JlcXVpcmVkJ1wiPk5hbWUgaXMgcmVxdWlyZWQuPC9tYXQtZXJyb3I+XG4gKiA8L21hdC1mb3JtLWZpZWxkPlxuICogYGBgXG4gKi9cbkBEaXJlY3RpdmUoe1xuXHRzZWxlY3RvcjogJ1tuZ3hDb250cm9sRXJyb3JdJyxcblx0c3RhbmRhbG9uZTogdHJ1ZSxcbn0pXG5leHBvcnQgY2xhc3MgTmd4Q29udHJvbEVycm9yIHtcblx0LyoqIEBpZ25vcmUgKi9cblx0cHJpdmF0ZSByZWFkb25seSB0ZW1wbGF0ZVJlZiA9IGluamVjdChUZW1wbGF0ZVJlZik7XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0cHJpdmF0ZSByZWFkb25seSB2aWV3Q29udGFpbmVyUmVmID0gaW5qZWN0KFZpZXdDb250YWluZXJSZWYpO1xuXG5cdHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcblx0XHQvLyBXaGVuZXZlciBvbmUgb2YgdGhlIHRyYWNrZWQgZXJyb3JzIGFyZSBpbmNsdWRlZCBpbiB0aGUgY29udHJvbHMgZXJyb3JzIGFuZCB0aGUgY29udHJvbCBpcyBpbiBhbiBlcnJvciBzdGF0ZSwgcmVuZGVyIHRoaXMgdGVtcGxhdGUuXG5cdFx0Y29tYmluZUxhdGVzdChcblx0XHRcdFt0b09ic2VydmFibGUodGhpcy50cmFjayQpLCB0b09ic2VydmFibGUodGhpcy5jb250cm9sJCksIHRoaXMuX2hhc0Vycm9yJF0sXG5cdFx0XHQodHJhY2ssIGNvbnRyb2wsIGhhc0Vycm9yKSA9PiB7XG5cdFx0XHRcdHRoaXMudmlld0NvbnRhaW5lclJlZi5jbGVhcigpO1xuXG5cdFx0XHRcdGlmIChoYXNFcnJvciAmJiBjb250cm9sICE9IG51bGwgJiYgdHJhY2sgIT0gbnVsbClcblx0XHRcdFx0XHR0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGVSZWYsIHtcblx0XHRcdFx0XHRcdCRpbXBsaWNpdDogY29udHJvbC5lcnJvcnMgPz8ge30sXG5cdFx0XHRcdFx0XHR0cmFjayxcblx0XHRcdFx0XHRcdGNvbnRyb2wsXG5cdFx0XHRcdFx0fSBzYXRpc2ZpZXMgTmd4Q29udHJvbEVycm9yQ29udGV4dCk7XG5cdFx0XHR9LFxuXHRcdClcblx0XHRcdC5waXBlKHRha2VVbnRpbERlc3Ryb3llZCgpKVxuXHRcdFx0LnN1YnNjcmliZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBlcnJvcnMgdGhpcyBkaXJlY3RpdmUgdHJhY2tzLCB3aGVuIGEge0BsaW5rIGNvbnRyb2wkIGNvbnRyb2x9IGlzIHByb3ZpZGVkLlxuXHQgKi9cblx0QElucHV0KHsgYWxpYXM6ICduZ3hDb250cm9sRXJyb3JUcmFjaycsIHJlcXVpcmVkOiB0cnVlIH0pXG5cdHB1YmxpYyBzZXQgdHJhY2sodHJhY2spIHtcblx0XHR0aGlzLnRyYWNrJC5zZXQodHJhY2spO1xuXHR9XG5cblx0cHVibGljIGdldCB0cmFjaygpIHtcblx0XHRyZXR1cm4gdGhpcy50cmFjayQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgY29udHJvbCB3aGljaCBgZXJyb3JzYCBhcmUgdHJhY2tlZC5cblx0ICpcblx0ICogQHNlZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLmVycm9yc31cblx0ICovXG5cdEBJbnB1dCh7IGFsaWFzOiAnbmd4Q29udHJvbEVycm9yJywgcmVxdWlyZWQ6IHRydWUgfSlcblx0cHVibGljIHNldCBjb250cm9sKGNvbnRyb2wpIHtcblx0XHR0aGlzLmNvbnRyb2wkLnNldChjb250cm9sKTtcblx0fVxuXG5cdHB1YmxpYyBnZXQgY29udHJvbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250cm9sJCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqICBBIGBTdGF0ZU1hdGNoZXJgIHdoaWNoIGRlZmluZXMgd2hlbiB0aGlzIHtAbGluayBjb250cm9sJCBjb250cm9sfSBpcyBpbiBhbiAqZXJyb3Igc3RhdGUqLlxuXHQgKiAgVGhpcyBkaXJlY3RpdmUgKipPTkxZKiogcmVuZGVycyB0aGlzIHRlbXBsYXRlIHdoZW4gdGhlIGBTdGF0ZU1hdGNoZXJgIGV2YWx1YXRlcyB0byBgdHJ1ZWAuXG5cdCAqXG5cdCAqICBEZWZhdWx0cyB0byB7QGxpbmsgTkdYX0NPTlRST0xfRVJST1JfU1RBVEVfTUFUQ0hFUn0uXG5cdCAqL1xuXHRASW5wdXQoeyBhbGlhczogJ25neENvbnRyb2xFcnJvckVycm9yU3RhdGVNYXRjaGVyJyB9KVxuXHRwdWJsaWMgc2V0IGVycm9yU3RhdGVNYXRjaGVyKGVycm9yU3RhdGVNYXRjaGVyOiBTdGF0ZU1hdGNoZXIpIHtcblx0XHR0aGlzLmVycm9yU3RhdGVNYXRjaGVyJC5zZXQoZXJyb3JTdGF0ZU1hdGNoZXIpO1xuXHR9XG5cblx0cHVibGljIGdldCBlcnJvclN0YXRlTWF0Y2hlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcnJvclN0YXRlTWF0Y2hlciQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgcGFyZW50IG9mIHRoaXMge0BsaW5rIGNvbnRyb2wkIGNvbnRyb2x9LlxuXHQgKlxuXHQgKiBOT1RFOiBNaWdodCBub3QgYmUgdGhlIGNvbnRyb2wgcmVmZXJlbmNlZCBieSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnBhcmVudCBwYXJlbnR9IG9mIHRoaXMge0BsaW5rIGNvbnRyb2wkIGNvbnRyb2x9LlxuXHQgKi9cblx0QElucHV0KHsgYWxpYXM6ICduZ3hDb250cm9sRXJyb3JQYXJlbnQnIH0pXG5cdHB1YmxpYyBzZXQgcGFyZW50KHBhcmVudCkge1xuXHRcdHRoaXMucGFyZW50JC5zZXQocGFyZW50KTtcblx0fVxuXG5cdHB1YmxpYyBnZXQgcGFyZW50KCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudCQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgZXJyb3JzIHRoaXMgZGlyZWN0aXZlIHRyYWNrcywgd2hlbiBhIHtAbGluayBjb250cm9sJCBjb250cm9sfSBpcyBwcm92aWRlZC5cblx0ICovXG5cdHB1YmxpYyByZWFkb25seSB0cmFjayQgPSBzaWduYWw8dW5kZWZpbmVkIHwgc3RyaW5nIHwgc3RyaW5nW10+KHVuZGVmaW5lZCk7XG5cblx0LyoqXG5cdCAqIFRoZSBwYXJlbnQgb2YgdGhpcyB7QGxpbmsgY29udHJvbCQgY29udHJvbH0uXG5cdCAqXG5cdCAqIE5PVEU6IE1pZ2h0IG5vdCBiZSB0aGUgY29udHJvbCByZWZlcmVuY2VkIGJ5IHtAbGluayBBYnN0cmFjdENvbnRyb2wucGFyZW50IHBhcmVudH0gb2YgdGhpcyB7QGxpbmsgY29udHJvbCQgY29udHJvbH0uXG5cdCAqL1xuXHRwdWJsaWMgcmVhZG9ubHkgcGFyZW50JCA9IHNpZ25hbChcblx0XHRpbmplY3QoTkdYX0NPTlRST0xfRVJST1JfUEFSRU5ULCB7IG9wdGlvbmFsOiB0cnVlIH0pID8/XG5cdFx0XHRpbmplY3QoRm9ybUdyb3VwRGlyZWN0aXZlLCB7IG9wdGlvbmFsOiB0cnVlIH0pID8/XG5cdFx0XHRpbmplY3QoTmdGb3JtLCB7IG9wdGlvbmFsOiB0cnVlIH0pID8/XG5cdFx0XHR1bmRlZmluZWQsXG5cdCk7XG5cblx0LyoqXG5cdCAqIFRoZSBjb250cm9sIHdoaWNoIGBlcnJvcnNgIGFyZSB0cmFja2VkLlxuXHQgKlxuXHQgKiBAc2VlIHtAbGluayBBYnN0cmFjdENvbnRyb2wuZXJyb3JzfVxuXHQgKi9cblx0cHVibGljIHJlYWRvbmx5IGNvbnRyb2wkID0gc2lnbmFsPEFic3RyYWN0Q29udHJvbCB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuXHQvKipcblx0ICogIEEgYFN0YXRlTWF0Y2hlcmAgd2hpY2ggZGVmaW5lcyB3aGVuIHRoaXMge0BsaW5rIGNvbnRyb2wkIGNvbnRyb2x9IGlzIGluIGFuICplcnJvciBzdGF0ZSouXG5cdCAqICBUaGlzIGRpcmVjdGl2ZSAqKk9OTFkqKiByZW5kZXJzIHRoaXMgdGVtcGxhdGUgd2hlbiB0aGUgYFN0YXRlTWF0Y2hlcmAgZXZhbHVhdGVzIHRvIGB0cnVlYC5cblx0ICpcblx0ICogIERlZmF1bHRzIHRvIHtAbGluayBOR1hfQ09OVFJPTF9FUlJPUl9TVEFURV9NQVRDSEVSfS5cblx0ICovXG5cdHB1YmxpYyByZWFkb25seSBlcnJvclN0YXRlTWF0Y2hlciQgPSBzaWduYWwoXG5cdFx0aW5qZWN0KE5HWF9DT05UUk9MX0VSUk9SX1NUQVRFX01BVENIRVIpLFxuXHQpO1xuXG5cdC8qKlxuXHQgKiBUaGUgY29udGV4dCBvZiB0aGlzIHRlbXBsYXRlLlxuXHQgKi9cblx0cHVibGljIGdldCBjb250ZXh0KCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnZpZXdDb250YWluZXJSZWYuZ2V0KDApIGFzIEVtYmVkZGVkVmlld1JlZjxOZ3hDb250cm9sRXJyb3JDb250ZXh0PlxuXHRcdCk/LmNvbnRleHQ7XG5cdH1cblxuXHQvKipcblx0ICogV2hldGhlciB0aGlzIHtAbGluayBjb250cm9sJCBjb250cm9sJ3N9IGVycm9ycyBpbmNsdWRlIG9uZSBvZiB0aGUge0BsaW5rIHRyYWNrJCB0cmFja2VkIGVycm9yc30gYW5kIHdoZXRoZXIgaXQgaXMgaW4gYW4gKntAbGluayBlcnJvclN0YXRlJCBlcnJvciBzdGF0ZX0qLlxuXHQgKi9cblx0cHJpdmF0ZSByZWFkb25seSBfaGFzRXJyb3IkID0gY29tYmluZUxhdGVzdChbXG5cdFx0dG9PYnNlcnZhYmxlKHRoaXMudHJhY2skKSxcblx0XHR0b09ic2VydmFibGUodGhpcy5lcnJvclN0YXRlTWF0Y2hlciQpLFxuXHRcdHRvT2JzZXJ2YWJsZSh0aGlzLmNvbnRyb2wkKS5waXBlKGZpbHRlck5pbCgpKSxcblx0XHR0b09ic2VydmFibGUodGhpcy5wYXJlbnQkKSxcblx0XSkucGlwZShcblx0XHRzd2l0Y2hNYXAoKFt0cmFjaywgZXJyb3JTdGF0ZU1hdGNoZXIsIGNvbnRyb2wsIHBhcmVudF0pID0+XG5cdFx0XHRlcnJvclN0YXRlTWF0Y2hlcihjb250cm9sLCBwYXJlbnQpLnBpcGUoXG5cdFx0XHRcdG1hcChcblx0XHRcdFx0XHQoZXJyb3JTdGF0ZSkgPT5cblx0XHRcdFx0XHRcdGVycm9yU3RhdGUgJiZcblx0XHRcdFx0XHRcdHRyYWNrICE9IG51bGwgJiZcblx0XHRcdFx0XHRcdGNvbnRyb2wgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0KHR5cGVvZiB0cmFjayA9PT0gJ3N0cmluZydcblx0XHRcdFx0XHRcdFx0PyBjb250cm9sLmhhc0Vycm9yKHRyYWNrKVxuXHRcdFx0XHRcdFx0XHQ6IHRyYWNrLnNvbWUoKHgpID0+IGNvbnRyb2wuaGFzRXJyb3IoeCkpKSxcblx0XHRcdFx0KSxcblx0XHRcdCksXG5cdFx0KSxcblx0XHRzaGFyZVJlcGxheSgxKSwgLy8gY2FjaGUgdGhlIGxhdGVzdCBlcnJvclN0YXRlTWF0Y2hlciBjb21wdXRhdGlvblxuXHQpO1xuXG5cdC8qKlxuXHQgKiBXaGV0aGVyIHRoaXMge0BsaW5rIGNvbnRyb2wkIGNvbnRyb2wnc30gZXJyb3JzIGluY2x1ZGUgb25lIG9mIHRoZSB7QGxpbmsgdHJhY2skIHRyYWNrZWQgZXJyb3JzfSBhbmQgd2hldGhlciBpdCBpcyBpbiBhbiAqe0BsaW5rIGVycm9yU3RhdGUkIGVycm9yIHN0YXRlfSouXG5cdCAqL1xuXHRwdWJsaWMgcmVhZG9ubHkgaGFzRXJyb3IkID0gdG9TaWduYWwodGhpcy5faGFzRXJyb3IkLCB7XG5cdFx0aW5pdGlhbFZhbHVlOiBmYWxzZSxcblx0fSk7XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0cHVibGljIHN0YXRpYyBuZ1RlbXBsYXRlQ29udGV4dEd1YXJkID0gKFxuXHRcdGRpcmVjdGl2ZTogTmd4Q29udHJvbEVycm9yLFxuXHRcdGNvbnRleHQ6IHVua25vd24sXG5cdCk6IGNvbnRleHQgaXMgTmd4Q29udHJvbEVycm9yQ29udGV4dCA9PiB0cnVlO1xufVxuIl19