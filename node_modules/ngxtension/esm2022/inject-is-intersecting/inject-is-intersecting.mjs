import { DestroyRef, ElementRef, inject } from '@angular/core';
import { assertInjector } from 'ngxtension/assert-injector';
import { injectDestroy } from 'ngxtension/inject-destroy';
import { IsInViewportService } from './is-in-viewport.service';
/**
 * Injects an observable that emits whenever the element is intersecting the viewport.
 * The observable will complete when the element is destroyed.
 * @param options
 *
 * @example
 * export class MyComponent {
 *   private destroyRef = inject(DestroyRef);
 *
 *   isIntersecting$ = injectIsIntersecting();
 *   isInViewport$ = this.isIntersecting$.pipe(
 *     filter(x => x.intersectionRatio > 0),
 *     take(1),
 *   );
 *
 *   ngOnInit() {
 *     this.getData().subscribe();
 *   }
 *
 *   getData() {
 *     // Only fetch data when the element is in the viewport
 *     return this.isInViewport$.pipe(
 *       switchMap(() => this.service.getData()),
 *       takeUntil(this.destroy$)
 *     );
 *   }
 * }
 */
export const injectIsIntersecting = ({ injector, element, } = {}) => {
    return assertInjector(injectDestroy, injector, () => {
        const el = element ?? inject(ElementRef).nativeElement;
        const inInViewportService = inject(IsInViewportService);
        const destroyRef = inject(DestroyRef);
        const sub = inInViewportService.observe(el);
        destroyRef.onDestroy(() => {
            inInViewportService.unobserve(el);
        });
        return sub;
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5qZWN0LWlzLWludGVyc2VjdGluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvbmd4dGVuc2lvbi9pbmplY3QtaXMtaW50ZXJzZWN0aW5nL3NyYy9pbmplY3QtaXMtaW50ZXJzZWN0aW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBWSxNQUFNLGVBQWUsQ0FBQztBQUN6RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDNUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzFELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBTy9EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EyQkc7QUFDSCxNQUFNLENBQUMsTUFBTSxvQkFBb0IsR0FBRyxDQUFDLEVBQ3BDLFFBQVEsRUFDUixPQUFPLE1BQ3lCLEVBQUUsRUFBRSxFQUFFO0lBQ3RDLE9BQU8sY0FBYyxDQUFDLGFBQWEsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFO1FBQ25ELE1BQU0sRUFBRSxHQUFHLE9BQU8sSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsYUFBYSxDQUFDO1FBQ3ZELE1BQU0sbUJBQW1CLEdBQUcsTUFBTSxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDeEQsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRXRDLE1BQU0sR0FBRyxHQUFHLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUU1QyxVQUFVLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUN6QixtQkFBbUIsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbkMsQ0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPLEdBQUcsQ0FBQztJQUNaLENBQUMsQ0FBQyxDQUFDO0FBQ0osQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVzdHJveVJlZiwgRWxlbWVudFJlZiwgaW5qZWN0LCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgYXNzZXJ0SW5qZWN0b3IgfSBmcm9tICduZ3h0ZW5zaW9uL2Fzc2VydC1pbmplY3Rvcic7XG5pbXBvcnQgeyBpbmplY3REZXN0cm95IH0gZnJvbSAnbmd4dGVuc2lvbi9pbmplY3QtZGVzdHJveSc7XG5pbXBvcnQgeyBJc0luVmlld3BvcnRTZXJ2aWNlIH0gZnJvbSAnLi9pcy1pbi12aWV3cG9ydC5zZXJ2aWNlJztcblxuZXhwb3J0IGludGVyZmFjZSBJbmplY3RJc0ludGVyc2VjdGluZ09wdGlvbnMge1xuXHRpbmplY3Rvcj86IEluamVjdG9yO1xuXHRlbGVtZW50PzogRWxlbWVudDtcbn1cblxuLyoqXG4gKiBJbmplY3RzIGFuIG9ic2VydmFibGUgdGhhdCBlbWl0cyB3aGVuZXZlciB0aGUgZWxlbWVudCBpcyBpbnRlcnNlY3RpbmcgdGhlIHZpZXdwb3J0LlxuICogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSB3aGVuIHRoZSBlbGVtZW50IGlzIGRlc3Ryb3llZC5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKlxuICogQGV4YW1wbGVcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCB7XG4gKiAgIHByaXZhdGUgZGVzdHJveVJlZiA9IGluamVjdChEZXN0cm95UmVmKTtcbiAqXG4gKiAgIGlzSW50ZXJzZWN0aW5nJCA9IGluamVjdElzSW50ZXJzZWN0aW5nKCk7XG4gKiAgIGlzSW5WaWV3cG9ydCQgPSB0aGlzLmlzSW50ZXJzZWN0aW5nJC5waXBlKFxuICogICAgIGZpbHRlcih4ID0+IHguaW50ZXJzZWN0aW9uUmF0aW8gPiAwKSxcbiAqICAgICB0YWtlKDEpLFxuICogICApO1xuICpcbiAqICAgbmdPbkluaXQoKSB7XG4gKiAgICAgdGhpcy5nZXREYXRhKCkuc3Vic2NyaWJlKCk7XG4gKiAgIH1cbiAqXG4gKiAgIGdldERhdGEoKSB7XG4gKiAgICAgLy8gT25seSBmZXRjaCBkYXRhIHdoZW4gdGhlIGVsZW1lbnQgaXMgaW4gdGhlIHZpZXdwb3J0XG4gKiAgICAgcmV0dXJuIHRoaXMuaXNJblZpZXdwb3J0JC5waXBlKFxuICogICAgICAgc3dpdGNoTWFwKCgpID0+IHRoaXMuc2VydmljZS5nZXREYXRhKCkpLFxuICogICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpXG4gKiAgICAgKTtcbiAqICAgfVxuICogfVxuICovXG5leHBvcnQgY29uc3QgaW5qZWN0SXNJbnRlcnNlY3RpbmcgPSAoe1xuXHRpbmplY3Rvcixcblx0ZWxlbWVudCxcbn06IEluamVjdElzSW50ZXJzZWN0aW5nT3B0aW9ucyA9IHt9KSA9PiB7XG5cdHJldHVybiBhc3NlcnRJbmplY3RvcihpbmplY3REZXN0cm95LCBpbmplY3RvciwgKCkgPT4ge1xuXHRcdGNvbnN0IGVsID0gZWxlbWVudCA/PyBpbmplY3QoRWxlbWVudFJlZikubmF0aXZlRWxlbWVudDtcblx0XHRjb25zdCBpbkluVmlld3BvcnRTZXJ2aWNlID0gaW5qZWN0KElzSW5WaWV3cG9ydFNlcnZpY2UpO1xuXHRcdGNvbnN0IGRlc3Ryb3lSZWYgPSBpbmplY3QoRGVzdHJveVJlZik7XG5cblx0XHRjb25zdCBzdWIgPSBpbkluVmlld3BvcnRTZXJ2aWNlLm9ic2VydmUoZWwpO1xuXG5cdFx0ZGVzdHJveVJlZi5vbkRlc3Ryb3koKCkgPT4ge1xuXHRcdFx0aW5JblZpZXdwb3J0U2VydmljZS51bm9ic2VydmUoZWwpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHN1Yjtcblx0fSk7XG59O1xuIl19