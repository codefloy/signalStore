"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertQueriesGenerator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const node_fs_1 = require("node:fs");
const node_process_1 = require("node:process");
const ts_morph_1 = require("ts-morph");
const contents_store_1 = require("../shared-utils/contents-store");
const import_utils_1 = require("../shared-utils/import-utils");
const migrate_signals_in_ts_1 = require("../shared-utils/migrate-signals-in-ts");
const CONTENT_QUERIES = [
    'ContentChild',
    'ContentChildren',
    'ViewChild',
    'ViewChildren',
];
const SIGNAL_CONTENT_QUERIES = [
    'contentChild',
    'contentChildren',
    'viewChild',
    'viewChildren',
];
function trackContents(tree, contentsStore, fullPath) {
    if (fullPath.endsWith('.ts')) {
        const fileContent = tree.read(fullPath, 'utf8') || (0, node_fs_1.readFileSync)(fullPath, 'utf8');
        const decoratorUsage = CONTENT_QUERIES.map((d) => `@${d}`);
        if (!decoratorUsage.some((d) => fileContent.includes(d))) {
            return;
        }
        contentsStore.track(fullPath, fileContent);
    }
}
function getQueryInitializer(propertyName, type, decorator) {
    const [selector, options] = decorator.getArguments();
    const selectorText = selector.getFullText();
    const decoratorToSignalMap = {
        ContentChild: 'contentChild',
        ViewChild: 'viewChild',
        ViewChildren: 'viewChildren',
        ContentChildren: 'contentChildren',
    };
    return {
        writerFn: (writer) => {
            const queryFn = decoratorToSignalMap[decorator.getFullName()];
            writer.write(queryFn);
            if (typeof type === 'string') {
                // add type if exists
                if (type.includes('QueryList')) {
                    // for example: QueryList<PrimeTemplate> => PrimeTemplate
                    // ex: Nullable<QueryList<PrimeTemplate>> => Nullable<PrimeTemplate>
                    // Regular expression pattern to match QueryList<T>
                    const pattern = /QueryList<([^>]+)>/g;
                    // Replace QueryList<T> with T
                    type = type.replace(pattern, '$1');
                }
                let addGeneric = true;
                if (type === selectorText) {
                    // don't write the type if it's the same as the selector
                    addGeneric = false;
                }
                if (queryFn === 'viewChildren' || queryFn === 'contentChildren') {
                    // don't write the type in viewChildren and contentChildren if it has a pattern like this:
                    // headerElements = viewChildren<HeaderElement[]>(HeaderElement);
                    if (type.replace('[]', '') === selectorText) {
                        addGeneric = false;
                    }
                }
                if (addGeneric) {
                    writer.write(`<${type}>`);
                }
            }
            writer.write('(');
            writer.write(selectorText);
            if (options) {
                // { read: ElementRef, descendants: true, static: true }
                if (ts_morph_1.Node.isObjectLiteralExpression(options)) {
                    const decoratorOptions = options
                        .getProperties()
                        .filter(ts_morph_1.Node.isPropertyAssignment)
                        .reduce((acc, propertyAssignment) => {
                        if (propertyAssignment.getName() === 'static') {
                            return acc;
                        }
                        acc.push(propertyAssignment.getText());
                        return acc;
                    }, []);
                    if (decoratorOptions.length > 0) {
                        writer.write(`, { ${decoratorOptions.join(', ')} }`);
                    }
                }
            }
            writer.write(')');
        },
    };
}
function stringIsUsedMoreThanOnce(key, fileFullText) {
    const regExp = new RegExp(key, 'g');
    const matches = fileFullText.match(regExp);
    return matches && matches.length > 1;
}
function convertQueriesGenerator(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const contentsStore = new contents_store_1.ContentsStore();
        const packageJson = (0, devkit_1.readJson)(tree, 'package.json');
        const angularCorePackage = packageJson['dependencies']['@angular/core'];
        if (!angularCorePackage) {
            devkit_1.logger.error(`[ngxtension] No @angular/core detected`);
            return (0, node_process_1.exit)(1);
        }
        const [major, minor] = angularCorePackage
            .split('.')
            .slice(0, 2)
            .map((part) => {
            if (part.startsWith('^') || part.startsWith('~')) {
                return Number(part.slice(1));
            }
            return Number(part);
        });
        if ([major, minor] < [17, 3]) {
            devkit_1.logger.error(`[ngxtension] queries is only available in v17.3 and later`);
            return (0, node_process_1.exit)(1);
        }
        const { path, project } = options;
        if (path && project) {
            devkit_1.logger.error(`[ngxtension] Cannot pass both "path" and "project" to convertOutputsGenerator`);
            return (0, node_process_1.exit)(1);
        }
        if (path) {
            if (!tree.exists(path)) {
                devkit_1.logger.error(`[ngxtension] "${path}" does not exist`);
                return (0, node_process_1.exit)(1);
            }
            trackContents(tree, contentsStore, path);
        }
        else if (project) {
            try {
                const projectConfiguration = (0, devkit_1.readProjectConfiguration)(tree, project);
                if (!projectConfiguration) {
                    throw `"${project}" project not found`;
                }
                (0, devkit_1.visitNotIgnoredFiles)(tree, projectConfiguration.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
            catch (err) {
                devkit_1.logger.error(`[ngxtension] ${err}`);
                return;
            }
        }
        else {
            const projects = (0, devkit_1.getProjects)(tree);
            for (const project of projects.values()) {
                (0, devkit_1.visitNotIgnoredFiles)(tree, project.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
        }
        for (const { path: sourcePath } of contentsStore.collection) {
            const sourceFile = contentsStore.project.getSourceFile(sourcePath);
            const classes = sourceFile.getClasses();
            let shouldImportToObservable = false;
            for (const targetClass of classes) {
                const applicableDecorator = targetClass.getDecorator((decoratorDecl) => {
                    return ['Component', 'Directive'].includes(decoratorDecl.getName());
                });
                if (!applicableDecorator)
                    continue;
                const convertedQueries = new Set();
                targetClass.forEachChild((node) => {
                    if (ts_morph_1.Node.isPropertyDeclaration(node)) {
                        for (const query of CONTENT_QUERIES) {
                            const queryDecorator = node.getDecorator(query);
                            if (queryDecorator) {
                                const { name, isReadonly, docs, scope, type, hasOverrideKeyword, } = node.getStructure();
                                const { writerFn } = getQueryInitializer(name, type, queryDecorator);
                                const newProperty = targetClass.addProperty({
                                    name,
                                    isReadonly,
                                    docs,
                                    scope,
                                    hasOverrideKeyword,
                                    initializer: writerFn,
                                });
                                node.replaceWithText(newProperty.print());
                                newProperty.remove();
                                if (name) {
                                    convertedQueries.add({ name, type: query });
                                }
                                // After the first query is converted, break the loop to avoid checking the same node again
                                break;
                            }
                        }
                    }
                });
                const convertedVariables = new Map();
                convertedQueries.forEach((query) => convertedVariables.set(query.name, query.name));
                if (convertedVariables.size > 0) {
                    (0, migrate_signals_in_ts_1.migrateSignalsInClassOrDecorator)(tree, sourcePath, targetClass, applicableDecorator, convertedVariables);
                    const variablesToAddChangesProperty = new Set();
                    // replace the .changes with the new property
                    convertedVariables.forEach((value, key) => {
                        const changesPatterns = [
                            `this.${key}().changes`,
                            `this.${key}()?.changes`,
                            `this.${key}()!.changes`,
                        ];
                        // find the pattern in the source text
                        targetClass.forEachDescendant((node) => {
                            if (ts_morph_1.Node.isPropertyAccessExpression(node)) {
                                const propertyAccess = node;
                                for (const pattern of changesPatterns) {
                                    if (propertyAccess.getExpression().getText() === pattern) {
                                        propertyAccess.forEachChild((x) => {
                                            if (x.getText() === pattern) {
                                                x.replaceWithText(`this.${key}Changes`);
                                                variablesToAddChangesProperty.add(key);
                                            }
                                        });
                                        break;
                                    }
                                }
                            }
                        });
                    });
                    for (const key of variablesToAddChangesProperty) {
                        const shouldAddChangesProperty = !targetClass.getProperty(`${key}Changes`);
                        if (shouldAddChangesProperty) {
                            targetClass.addProperty({
                                name: `${key}Changes`,
                                isReadonly: true,
                                scope: ts_morph_1.Scope.Protected,
                                initializer: `toObservable(this.${key})`,
                            });
                            shouldImportToObservable = true;
                        }
                    }
                }
            }
            SIGNAL_CONTENT_QUERIES.forEach((query) => {
                const sourceText = sourceFile.getFullText();
                if (sourceText.includes(`${query}<`) ||
                    sourceText.includes(`${query}(`)) {
                    // usages as: contentChild<Test>, contentChild(), viewChild<Test>, viewChild()
                    (0, import_utils_1.importFrom)(query, '@angular/core', sourceFile);
                }
            });
            if (shouldImportToObservable) {
                (0, import_utils_1.importFrom)('toObservable', '@angular/core/rxjs-interop', sourceFile);
            }
            // remove the import if the decorator is not used
            CONTENT_QUERIES.forEach((query) => {
                const hasDecoratorUsage = sourceFile.getFullText().includes(`@${query}`);
                if (!hasDecoratorUsage) {
                    const queryImport = sourceFile.getImportDeclaration((importDecl) => importDecl.getModuleSpecifierValue() === '@angular/core' &&
                        importDecl
                            .getNamedImports()
                            .some((namedImport) => namedImport.getName() === query));
                    if (queryImport) {
                        const classToRemove = queryImport
                            .getNamedImports()
                            .find((namedImport) => namedImport.getName() === query);
                        classToRemove.remove();
                    }
                }
            });
            // remove QueryList import if it's not used anymore
            const queryListIsUsedMoreThanOnce = stringIsUsedMoreThanOnce('QueryList', sourceFile.getFullText());
            if (!queryListIsUsedMoreThanOnce) {
                (0, import_utils_1.removeImport)('QueryList', '@angular/core', sourceFile);
            }
            tree.write(sourcePath, sourceFile.getFullText());
        }
        yield (0, devkit_1.formatFiles)(tree);
        devkit_1.logger.info(`
[ngxtension] Conversion completed. Please check the content and run your formatter as needed.
`);
    });
}
exports.convertQueriesGenerator = convertQueriesGenerator;
exports.default = convertQueriesGenerator;
//# sourceMappingURL=generator.js.map