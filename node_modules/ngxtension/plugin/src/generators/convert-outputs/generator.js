"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertOutputsGenerator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const node_fs_1 = require("node:fs");
const node_process_1 = require("node:process");
const ts_morph_1 = require("ts-morph");
const contents_store_1 = require("../shared-utils/contents-store");
function trackContents(tree, contentsStore, fullPath) {
    if (fullPath.endsWith('.ts')) {
        const fileContent = tree.read(fullPath, 'utf8') || (0, node_fs_1.readFileSync)(fullPath, 'utf8');
        if (!fileContent.includes('@Component') &&
            !fileContent.includes('@Directive')) {
            devkit_1.logger.log(`[ngxtension] "${fullPath}" is not a Component nor a Directive`);
            return;
        }
        if (fileContent.includes('@Output')) {
            contentsStore.track(fullPath, fileContent);
        }
    }
}
function getOutputInitializer(propertyName, currentType, decorator, initializer) {
    const decoratorArg = decorator.getArguments()[0];
    // get alias if there is any from the decorator
    let alias = undefined;
    if (ts_morph_1.Node.isStringLiteral(decoratorArg)) {
        alias = decoratorArg.getText();
    }
    // check if the initializer is not an EventEmitter -> means its an observable
    if (!initializer.includes('EventEmitter')) {
        // if the initializer is a Subject or BehaviorSubject
        if (initializer.includes('Subject') ||
            initializer.includes('BehaviorSubject')) {
            // Before: @Output() outputFromSubject = new Subject();
            // After: _outputFromSubject = outputFromObservable(this.outputFromSubject, { alias: 'outputFromSubject' });
            return {
                writerFn: (writer) => {
                    writer.write(`outputFromObservable`);
                    writer.write(`(this.${propertyName}`);
                    writer.write(`, { alias: ${alias !== null && alias !== void 0 ? alias : `'${propertyName}'`} }`);
                    writer.write(`)`);
                },
                outputName: `_${propertyName}`,
                removeOnlyDecorator: true,
                needsOutputFromObservableImport: true,
            };
        }
        else {
            return {
                writerFn: (writer) => {
                    writer.write(`outputFromObservable`);
                    writer.write(`(${initializer}`);
                    writer.write(`${alias ? `, { alias: ${alias} }` : ''}`);
                    writer.write(`)`);
                },
                needsOutputFromObservableImport: true,
            };
        }
    }
    else {
        let type = '';
        if (initializer.includes('EventEmitter()')) {
            // there is no type
        }
        else {
            const genericTypeOnEmitter = initializer.match(/EventEmitter<(.+)>/);
            if (genericTypeOnEmitter === null || genericTypeOnEmitter === void 0 ? void 0 : genericTypeOnEmitter.length) {
                type = genericTypeOnEmitter[1];
            }
        }
        if (typeof currentType === 'string') {
            const genericTypeOnType = currentType.match(/EventEmitter<(.+)>/);
            if (genericTypeOnType === null || genericTypeOnType === void 0 ? void 0 : genericTypeOnType.length) {
                type = genericTypeOnType[1];
            }
        }
        return {
            writerFn: (writer) => {
                writer.write(`output`);
                writer.write(`${type ? `<${type}>` : ''}(`);
                writer.write(`${alias ? `, { alias: ${alias} }` : ''}`);
                writer.write(`)`);
            },
            needsOutputFromObservableImport: false,
        };
    }
}
function stringIsUsedMoreThanOnce(key, fileFullText) {
    const regExp = new RegExp(key, 'g');
    const matches = fileFullText.match(regExp);
    return matches && matches.length > 1;
}
function convertOutputsGenerator(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const contentsStore = new contents_store_1.ContentsStore();
        const packageJson = (0, devkit_1.readJson)(tree, 'package.json');
        const angularCorePackage = packageJson['dependencies']['@angular/core'];
        if (!angularCorePackage) {
            devkit_1.logger.error(`[ngxtension] No @angular/core detected`);
            return (0, node_process_1.exit)(1);
        }
        const [major, minor] = angularCorePackage
            .split('.')
            .slice(0, 2)
            .map((part) => {
            if (part.startsWith('^') || part.startsWith('~')) {
                return Number(part.slice(1));
            }
            return Number(part);
        });
        if ([major, minor] < [17, 3]) {
            devkit_1.logger.error(`[ngxtension] output() is only available in v17.3 and later`);
            return (0, node_process_1.exit)(1);
        }
        const { path, project } = options;
        if (path && project) {
            devkit_1.logger.error(`[ngxtension] Cannot pass both "path" and "project" to convertOutputsGenerator`);
            return (0, node_process_1.exit)(1);
        }
        if (path) {
            if (!tree.exists(path)) {
                devkit_1.logger.error(`[ngxtension] "${path}" does not exist`);
                return (0, node_process_1.exit)(1);
            }
            trackContents(tree, contentsStore, path);
        }
        else if (project) {
            try {
                const projectConfiguration = (0, devkit_1.readProjectConfiguration)(tree, project);
                if (!projectConfiguration) {
                    throw `"${project}" project not found`;
                }
                (0, devkit_1.visitNotIgnoredFiles)(tree, projectConfiguration.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
            catch (err) {
                devkit_1.logger.error(`[ngxtension] ${err}`);
                return;
            }
        }
        else {
            const projects = (0, devkit_1.getProjects)(tree);
            for (const project of projects.values()) {
                (0, devkit_1.visitNotIgnoredFiles)(tree, project.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
        }
        for (const { path: sourcePath } of contentsStore.collection) {
            const sourceFile = contentsStore.project.getSourceFile(sourcePath);
            const hasOutputImport = sourceFile.getImportDeclaration((importDecl) => importDecl.getModuleSpecifierValue() === '@angular/core' &&
                importDecl
                    .getNamedImports()
                    .some((namedImport) => namedImport.getName() === 'output'));
            // NOTE: only add hasOutputImport import if we don't have it and we find the first Output decorator
            if (!hasOutputImport) {
                const angularCoreImports = sourceFile.getImportDeclaration((importDecl) => {
                    return importDecl.getModuleSpecifierValue() === '@angular/core';
                });
                if (angularCoreImports) {
                    angularCoreImports.addNamedImport('output');
                }
                else {
                    sourceFile.addImportDeclaration({
                        namedImports: ['output'],
                        moduleSpecifier: '@angular/core',
                    });
                }
            }
            const classes = sourceFile.getClasses();
            for (const targetClass of classes) {
                const applicableDecorator = targetClass.getDecorator((decoratorDecl) => {
                    return ['Component', 'Directive'].includes(decoratorDecl.getName());
                });
                if (!applicableDecorator)
                    continue;
                const convertedOutputs = new Set();
                let outputFromObservableImportAdded = false;
                targetClass.forEachChild((node) => {
                    if (ts_morph_1.Node.isPropertyDeclaration(node)) {
                        const outputDecorator = node.getDecorator('Output');
                        if (outputDecorator) {
                            const { name, isReadonly, docs, scope, type, hasOverrideKeyword, initializer, } = node.getStructure();
                            const { needsOutputFromObservableImport, removeOnlyDecorator, outputName, writerFn, } = getOutputInitializer(name, type, outputDecorator, initializer);
                            if (needsOutputFromObservableImport &&
                                !outputFromObservableImportAdded) {
                                const angularRxjsInteropImports = sourceFile.getImportDeclaration((importDecl) => {
                                    return (importDecl.getModuleSpecifierValue() ===
                                        '@angular/core/rxjs-interop');
                                });
                                if (angularRxjsInteropImports) {
                                    angularRxjsInteropImports.addNamedImport('outputFromObservable');
                                }
                                else {
                                    sourceFile.addImportDeclaration({
                                        namedImports: ['outputFromObservable'],
                                        moduleSpecifier: '@angular/core/rxjs-interop',
                                    });
                                }
                                outputFromObservableImportAdded = true;
                            }
                            const newProperty = targetClass.addProperty({
                                name: outputName !== null && outputName !== void 0 ? outputName : name,
                                isReadonly,
                                docs,
                                // we want to keep the scope as protected if it was private in order to avoid breaking changes
                                scope: scope === ts_morph_1.Scope.Private ? ts_morph_1.Scope.Protected : scope,
                                hasOverrideKeyword,
                                initializer: writerFn,
                            });
                            if (removeOnlyDecorator) {
                                outputDecorator.remove();
                                newProperty.setHasExclamationToken(false);
                                newProperty.addJsDoc('TODO(migration): you may want to convert this to a normal output');
                            }
                            else {
                                node.replaceWithText(newProperty.print());
                                // remove old class property Output
                                newProperty.remove();
                            }
                            // track converted outputs
                            convertedOutputs.add(name);
                        }
                    }
                });
            }
            // if @Output is not used anymore, remove the import
            const hasOutputDecoratorUsage = sourceFile
                .getFullText()
                .includes('@Output');
            if (!hasOutputDecoratorUsage) {
                const outputImport = sourceFile.getImportDeclaration((importDecl) => importDecl.getModuleSpecifierValue() === '@angular/core' &&
                    importDecl
                        .getNamedImports()
                        .some((namedImport) => namedImport.getName() === 'Output'));
                if (outputImport) {
                    const classToRemove = outputImport
                        .getNamedImports()
                        .find((namedImport) => namedImport.getName() === 'Output');
                    classToRemove.remove();
                }
            }
            // // if EventEmitter is not used anymore, remove the import
            const eventEmitterIsUsedMoreThanOnce = stringIsUsedMoreThanOnce('EventEmitter', sourceFile.getFullText());
            if (!eventEmitterIsUsedMoreThanOnce) {
                const eventEmitterImport = sourceFile.getImportDeclaration((importDecl) => importDecl.getModuleSpecifierValue() === '@angular/core' &&
                    importDecl
                        .getNamedImports()
                        .some((namedImport) => namedImport.getName() === 'EventEmitter'));
                if (eventEmitterImport) {
                    const classToRemove = eventEmitterImport
                        .getNamedImports()
                        .find((namedImport) => namedImport.getName() === 'EventEmitter');
                    classToRemove.remove();
                }
            }
            tree.write(sourcePath, sourceFile.getFullText());
        }
        yield (0, devkit_1.formatFiles)(tree);
        devkit_1.logger.info(`
[ngxtension] Conversion completed. Please check the content and run your formatter as needed.
`);
    });
}
exports.convertOutputsGenerator = convertOutputsGenerator;
exports.default = convertOutputsGenerator;
//# sourceMappingURL=generator.js.map