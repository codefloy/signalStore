"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertSignalInputsGenerator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const node_process_1 = require("node:process");
const ts_morph_1 = require("ts-morph");
const contents_store_1 = require("../shared-utils/contents-store");
const migrate_signals_in_template_1 = require("../shared-utils/migrate-signals-in-template");
const migrate_signals_in_ts_1 = require("../shared-utils/migrate-signals-in-ts");
function trackContents(tree, contentsStore, fullPath) {
    if (fullPath.endsWith('.ts')) {
        const fileContent = tree.read(fullPath, 'utf8') || (0, node_fs_1.readFileSync)(fullPath, 'utf8');
        if (!fileContent.includes('@Component') &&
            !fileContent.includes('@Directive')) {
            return;
        }
        if (fileContent.includes('@Input')) {
            contentsStore.track(fullPath, fileContent);
        }
    }
}
function getSignalInputInitializer(contentsStore, className, decorator, property) {
    const propertyInitializer = property.getInitializer();
    const propertyTypeNode = property.getTypeNode();
    const decoratorArg = decorator.getArguments()[0];
    const writeTypeNodeAndInitializer = (writer, isRequired = false, transformType = '', defaultToUndefined = false) => {
        var _a;
        if (transformType) {
            contentsStore.withTransforms.add(className);
        }
        if (propertyTypeNode) {
            const typeNode = propertyTypeNode.getText();
            const types = ['<'];
            if (transformType) {
                types.push(transformType, ',');
            }
            if ((propertyInitializer === null || propertyInitializer === void 0 ? void 0 : propertyInitializer.getType()) === undefined &&
                ts_morph_1.Node.isObjectLiteralExpression(decoratorArg) &&
                property.hasQuestionToken()) {
                types.push(typeNode);
                types.push('| undefined');
            }
            else {
                if ((_a = property.getInitializer()) === null || _a === void 0 ? void 0 : _a.getText().includes('undefined')) {
                    types.push(typeNode);
                }
                else {
                    types.push(typeNode.replace('| undefined', ''));
                }
            }
            if (transformType) {
                types.push('| string');
            }
            writer.write(types.concat('>').join(''));
        }
        writer.write('(');
        if (!isRequired) {
            let defaultValue = propertyInitializer
                ? propertyInitializer.getText()
                : defaultToUndefined
                    ? 'undefined'
                    : '';
            if (defaultValue) {
                if (['boolean', 'number'].includes(transformType)) {
                    defaultValue = `${transformType}Attribute(${defaultValue})`;
                }
                writer.write(defaultValue);
            }
        }
    };
    return (writer) => {
        // write input
        writer.write('input');
        if (ts_morph_1.Node.isObjectLiteralExpression(decoratorArg)) {
            let required = false;
            const inputOptions = decoratorArg
                .getProperties()
                .filter(ts_morph_1.Node.isPropertyAssignment)
                .reduce((acc, propertyAssignment) => {
                if (propertyAssignment.getName() === 'required') {
                    required = true;
                    return acc;
                }
                acc.push(propertyAssignment.getText());
                return acc;
            }, []);
            let optionsAsText = '';
            if (inputOptions.length) {
                optionsAsText += `{${inputOptions.join(', ')}}`;
            }
            if (required) {
                writer.write('.required');
            }
            let transformType = '';
            if (optionsAsText.includes('booleanAttribute')) {
                transformType = 'boolean';
            }
            else if (optionsAsText.includes('numberAttribute')) {
                transformType = 'number';
            }
            else if (optionsAsText.includes('transform:')) {
                transformType = 'any';
            }
            writeTypeNodeAndInitializer(writer, required, transformType, true);
            if (required) {
                writer.write(optionsAsText ? `${optionsAsText})` : ')');
            }
            else {
                writer.write(optionsAsText ? `, ${optionsAsText})` : ')');
            }
        }
        else if (ts_morph_1.Node.isStringLiteral(decoratorArg)) {
            writeTypeNodeAndInitializer(writer, false, '', true);
            writer.write(`, { alias: ${decoratorArg.getText()} })`);
        }
        else {
            writeTypeNodeAndInitializer(writer, false, '', false);
        }
    };
}
function convertSignalInputsGenerator(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const contentsStore = new contents_store_1.ContentsStore();
        const packageJson = (0, devkit_1.readJson)(tree, 'package.json');
        const angularCorePackage = packageJson['dependencies']['@angular/core'];
        if (!angularCorePackage) {
            devkit_1.logger.error(`[ngxtension] No @angular/core detected`);
            return (0, node_process_1.exit)(1);
        }
        const [major, minor] = angularCorePackage
            .split('.')
            .slice(0, 2)
            .map((part) => {
            if (part.startsWith('^') || part.startsWith('~')) {
                return Number(part.slice(1));
            }
            return Number(part);
        });
        if ([major, minor] < [17, 1]) {
            devkit_1.logger.error(`[ngxtension] Signal Input is only available in v17.1 and later`);
            return (0, node_process_1.exit)(1);
        }
        const { path, project } = options;
        if (path && project) {
            devkit_1.logger.error(`[ngxtension] Cannot pass both "path" and "project" to convertSignalInputsGenerator`);
            return (0, node_process_1.exit)(1);
        }
        if (path) {
            if (!tree.exists(path)) {
                devkit_1.logger.error(`[ngxtension] "${path}" does not exist`);
                return (0, node_process_1.exit)(1);
            }
            trackContents(tree, contentsStore, path);
        }
        else if (project) {
            try {
                const projectConfiguration = (0, devkit_1.readProjectConfiguration)(tree, project);
                if (!projectConfiguration) {
                    throw `"${project}" project not found`;
                }
                (0, devkit_1.visitNotIgnoredFiles)(tree, projectConfiguration.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
            catch (err) {
                devkit_1.logger.error(`[ngxtension] ${err}`);
                return;
            }
        }
        else {
            const projects = (0, devkit_1.getProjects)(tree);
            for (const project of projects.values()) {
                (0, devkit_1.visitNotIgnoredFiles)(tree, project.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
        }
        for (const { path: sourcePath } of contentsStore.collection) {
            const sourceFile = contentsStore.project.getSourceFile(sourcePath);
            const hasSignalInputImport = sourceFile.getImportDeclaration((importDecl) => importDecl.getModuleSpecifierValue() === '@angular/core' &&
                importDecl
                    .getNamedImports()
                    .some((namedImport) => namedImport.getName() === 'input'));
            const angularCoreImports = (0, migrate_signals_in_ts_1.getAngularCoreImports)(sourceFile);
            // NOTE: only add input import if we don't have it and we find the first Input decorator
            if (!hasSignalInputImport) {
                if (angularCoreImports) {
                    angularCoreImports.addNamedImport('input');
                }
                else {
                    sourceFile.addImportDeclaration({
                        namedImports: ['input'],
                        moduleSpecifier: '@angular/core',
                    });
                }
            }
            const classes = sourceFile.getClasses();
            for (const targetClass of classes) {
                const applicableDecorator = targetClass.getDecorator((decoratorDecl) => {
                    return ['Component', 'Directive'].includes(decoratorDecl.getName());
                });
                if (!applicableDecorator)
                    continue;
                const convertedInputs = new Set();
                targetClass.forEachChild((node) => {
                    if (ts_morph_1.Node.isPropertyDeclaration(node)) {
                        const inputDecorator = node.getDecorator('Input');
                        if (inputDecorator) {
                            const { name, isReadonly, docs, scope, hasOverrideKeyword } = node.getStructure();
                            const newProperty = targetClass.addProperty({
                                name,
                                isReadonly,
                                docs,
                                scope,
                                hasOverrideKeyword,
                                initializer: getSignalInputInitializer(contentsStore, targetClass.getName(), inputDecorator, node),
                            });
                            node.replaceWithText(newProperty.print());
                            // fail gracefully for nodes not terminated with a semi-colon
                            try {
                                // remove old class property Input
                                newProperty.remove();
                            }
                            catch (err) {
                                devkit_1.logger.warn(`[ngxtension] "${path}" Failed to parse node, check that declarations are terminated with a semicolon and try again`);
                                throw err;
                            }
                            // track converted inputs
                            convertedInputs.add(name);
                        }
                    }
                });
                if (convertedInputs.size) {
                    // process decorator metadata references
                    const decoratorArg = applicableDecorator.getArguments()[0];
                    if (ts_morph_1.Node.isObjectLiteralExpression(decoratorArg)) {
                        decoratorArg
                            .getChildrenOfKind(ts_morph_1.SyntaxKind.PropertyAssignment)
                            .forEach((property) => {
                            const decoratorPropertyName = property.getName();
                            if (decoratorPropertyName === 'template') {
                                // const templateAst = parseTemplate(
                                // 	property.getFullText(),
                                // 	`${path}.html`,
                                // );
                            }
                            if (decoratorPropertyName === 'host' ||
                                decoratorPropertyName === 'template') {
                                let originalText = property.getFullText();
                                originalText = (0, migrate_signals_in_template_1.migrateTemplateVariablesToSignals)(originalText, convertedInputs);
                                if (originalText !== property.getFullText()) {
                                    property.replaceWithText(originalText);
                                }
                            }
                            else if (decoratorPropertyName === 'templateUrl') {
                                const dir = (0, node_path_1.dirname)(sourcePath);
                                const templatePath = (0, devkit_1.joinPathFragments)(dir, property
                                    .getInitializer()
                                    .getText()
                                    .slice(1, property.getInitializer().getText().length - 1));
                                let templateText = tree.exists(templatePath)
                                    ? tree.read(templatePath, 'utf8')
                                    : '';
                                if (templateText) {
                                    templateText = (0, migrate_signals_in_template_1.migrateTemplateVariablesToSignals)(templateText, convertedInputs);
                                    tree.write(templatePath, templateText);
                                }
                            }
                        });
                    }
                    // process ts class references
                    const nonNullifyProperties = new Map();
                    for (const propertyAccessExpression of targetClass.getDescendantsOfKind(ts_morph_1.SyntaxKind.PropertyAccessExpression)) {
                        const propertyExpression = propertyAccessExpression.getExpression();
                        if (!ts_morph_1.Node.isThisExpression(propertyExpression))
                            continue;
                        const propertyName = propertyAccessExpression.getName();
                        if (!convertedInputs.has(propertyName))
                            continue;
                        const startLineInfo = (0, migrate_signals_in_ts_1.getStartLineInfo)(propertyAccessExpression);
                        const ifParent = propertyAccessExpression.getFirstAncestorByKind(ts_morph_1.SyntaxKind.IfStatement);
                        const ternaryParent = propertyAccessExpression.getFirstAncestorByKind(ts_morph_1.SyntaxKind.ConditionalExpression);
                        if ((ifParent &&
                            (0, migrate_signals_in_ts_1.getStartLineInfo)(ifParent.getExpression()) === startLineInfo) ||
                            (ternaryParent &&
                                (0, migrate_signals_in_ts_1.getStartLineInfo)(ternaryParent.getCondition()) === startLineInfo)) {
                            nonNullifyProperties.set(propertyName, startLineInfo);
                        }
                        const callExpression = propertyAccessExpression.replaceWithText(`${propertyAccessExpression.getText()}()`);
                        // this means that this property has been used in an if/ternary condition above
                        if (nonNullifyProperties.has(propertyName) &&
                            nonNullifyProperties.get(propertyName) !== startLineInfo) {
                            callExpression.replaceWithText(`${callExpression.getText()}!`);
                        }
                    }
                }
            }
            // if @Input is not used anymore, remove the import
            const hasInputDecoratorUsage = sourceFile.getFullText().includes('@Input');
            if (!hasInputDecoratorUsage) {
                const inputImport = sourceFile.getImportDeclaration((importDecl) => importDecl.getModuleSpecifierValue() === '@angular/core' &&
                    importDecl
                        .getNamedImports()
                        .some((namedImport) => namedImport.getName() === 'Input'));
                if (inputImport) {
                    const classToRemove = inputImport
                        .getNamedImports()
                        .find((namedImport) => namedImport.getName() === 'Input');
                    classToRemove.remove();
                }
            }
            tree.write(sourcePath, sourceFile.getFullText());
        }
        if (contentsStore.withTransforms.size) {
            devkit_1.logger.info(`
[ngxtension] The following classes have had some Inputs with "transform" converted. Please double check the type arguments on the "transform" Inputs
`);
            contentsStore.withTransforms.forEach((className) => {
                devkit_1.logger.info(`- ${className}`);
            });
        }
        yield (0, devkit_1.formatFiles)(tree);
        devkit_1.logger.info(`
[ngxtension] Conversion completed. Please check the content and run your formatter as needed.
`);
    });
}
exports.convertSignalInputsGenerator = convertSignalInputsGenerator;
exports.default = convertSignalInputsGenerator;
//# sourceMappingURL=generator.js.map