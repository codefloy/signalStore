"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToSFCGenerator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const node_process_1 = require("node:process");
const ts_morph_1 = require("ts-morph");
const contents_store_1 = require("../shared-utils/contents-store");
function trackContents(tree, contentsStore, fullPath) {
    if (fullPath.endsWith('.ts')) {
        const fileContent = tree.read(fullPath, 'utf8') || (0, node_fs_1.readFileSync)(fullPath, 'utf8');
        if (!fileContent.includes('@Component'))
            return;
        if (fileContent.includes('templateUrl')) {
            contentsStore.track(fullPath, fileContent);
        }
    }
}
function convertToSFCGenerator(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const contentsStore = new contents_store_1.ContentsStore();
        const packageJson = (0, devkit_1.readJson)(tree, 'package.json');
        const angularCorePackage = packageJson['dependencies']['@angular/core'] ||
            packageJson['devDependencies']['@angular/core'];
        if (!angularCorePackage) {
            devkit_1.logger.error(`[ngxtension] No @angular/core detected`);
            return (0, node_process_1.exit)(1);
        }
        const { path, project, moveStyles } = options;
        let { maxInlineTemplateLines, maxInlineStyleLines } = options;
        maxInlineStyleLines = maxInlineStyleLines || 200;
        maxInlineTemplateLines = maxInlineTemplateLines || 200;
        if (path && project) {
            devkit_1.logger.error(`[ngxtension] Cannot pass both "path" and "project" to convertToSFCGenerator`);
            return (0, node_process_1.exit)(1);
        }
        if (path) {
            if (!tree.exists(path)) {
                devkit_1.logger.error(`[ngxtension] "${path}" does not exist`);
                return (0, node_process_1.exit)(1);
            }
            trackContents(tree, contentsStore, path);
        }
        else if (project) {
            try {
                const projectConfiguration = (0, devkit_1.readProjectConfiguration)(tree, project);
                if (!projectConfiguration) {
                    throw `"${project}" project not found`;
                }
                (0, devkit_1.visitNotIgnoredFiles)(tree, projectConfiguration.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
            catch (err) {
                devkit_1.logger.error(`[ngxtension] ${err}`);
                return;
            }
        }
        else {
            const projects = (0, devkit_1.getProjects)(tree);
            for (const project of projects.values()) {
                (0, devkit_1.visitNotIgnoredFiles)(tree, project.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
        }
        for (const { path: sourcePath } of contentsStore.collection) {
            if (!sourcePath.endsWith('.ts'))
                continue;
            const sourceFile = contentsStore.project.getSourceFile(sourcePath);
            const classes = sourceFile.getClasses();
            for (const targetClass of classes) {
                const applicableDecorator = targetClass.getDecorator((decoratorDecl) => {
                    return ['Component'].includes(decoratorDecl.getName());
                });
                if (!applicableDecorator)
                    continue;
                const decoratorArg = applicableDecorator.getArguments()[0];
                if (ts_morph_1.Node.isObjectLiteralExpression(decoratorArg)) {
                    decoratorArg
                        .getChildrenOfKind(ts_morph_1.SyntaxKind.PropertyAssignment)
                        .forEach((property) => {
                        const decoratorPropertyName = property.getName();
                        if (decoratorPropertyName === 'templateUrl') {
                            const dir = (0, node_path_1.dirname)(sourcePath);
                            const templatePath = (0, devkit_1.joinPathFragments)(dir, property
                                .getInitializer()
                                .getText()
                                .slice(1, property.getInitializer().getText().length - 1));
                            const templateText = tree.exists(templatePath)
                                ? tree.read(templatePath, 'utf8')
                                : '';
                            const templateTextLines = templateText.split('\n').length;
                            // if the template is not too long and does not contain any js interpolation
                            if (!templateText.includes('${') &&
                                templateTextLines <= maxInlineTemplateLines) {
                                try {
                                    // replace the templateUrl with the template
                                    property.replaceWithText(`template: \`\n${templateText}\n\``);
                                    contentsStore.track(templatePath, templateText);
                                    // remove the templateUrl file
                                    tree.delete(templatePath);
                                }
                                catch (err) {
                                    devkit_1.logger.error(`[ngxtension] Skipping ${sourcePath} due to error: ${err}`);
                                }
                            }
                        }
                        if (decoratorPropertyName === 'styleUrl' ||
                            decoratorPropertyName === 'styleUrls') {
                            if (moveStyles) {
                                let styleUrl = decoratorPropertyName === 'styleUrl'
                                    ? property
                                        .getInitializer()
                                        .getText()
                                        .slice(1, property.getInitializer().getText().length - 1)
                                    : '';
                                if (decoratorPropertyName === 'styleUrls') {
                                    styleUrl = property
                                        .getInitializer()
                                        .getChildren()[1]
                                        .getText();
                                }
                                const dir = (0, node_path_1.dirname)(sourcePath);
                                const stylePath = (0, devkit_1.joinPathFragments)(dir, removeQuotes(styleUrl));
                                const styleText = tree.exists(stylePath)
                                    ? tree.read(stylePath, 'utf8')
                                    : '';
                                const styleTextLines = styleText.split('\n').length;
                                if (styleTextLines <= maxInlineStyleLines) {
                                    try {
                                        // replace the styleUrl with the style
                                        property.replaceWithText(`styles: \`\n${styleText}\n\``);
                                        contentsStore.track(stylePath, styleText);
                                        // remove the styleUrl file
                                        tree.delete(stylePath);
                                    }
                                    catch (err) {
                                        devkit_1.logger.error(`[ngxtension] Skipping ${sourcePath} due to error: ${err}`);
                                    }
                                }
                            }
                        }
                    });
                }
            }
            tree.write(sourcePath, sourceFile.getFullText());
        }
        yield (0, devkit_1.formatFiles)(tree);
        devkit_1.logger.info(`
[ngxtension] Conversion completed. Please check the content and run your formatter as needed.
`);
    });
}
exports.convertToSFCGenerator = convertToSFCGenerator;
function removeQuotes(str) {
    return str.replace(/['"]/g, '');
}
exports.default = convertToSFCGenerator;
//# sourceMappingURL=generator.js.map