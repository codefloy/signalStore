"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateComponentToSelfClosingTags = exports.convertToSelfClosingTagGenerator = void 0;
const tslib_1 = require("tslib");
const bundled_angular_compiler_1 = require("@angular-eslint/bundled-angular-compiler");
const devkit_1 = require("@nx/devkit");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const node_process_1 = require("node:process");
const ts_morph_1 = require("ts-morph");
const contents_store_1 = require("../shared-utils/contents-store");
function trackContents(tree, contentsStore, fullPath) {
    if (fullPath.endsWith('.ts')) {
        const fileContent = tree.read(fullPath, 'utf8') || (0, node_fs_1.readFileSync)(fullPath, 'utf8');
        if (!fileContent.includes('@Component'))
            return;
        if (fileContent.includes('template') ||
            fileContent.includes('templateUrl')) {
            contentsStore.track(fullPath, fileContent);
        }
    }
}
function convertToSelfClosingTagGenerator(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const contentsStore = new contents_store_1.ContentsStore();
        const packageJson = (0, devkit_1.readJson)(tree, 'package.json');
        const angularCorePackage = packageJson['dependencies']['@angular/core'] ||
            packageJson['devDependencies']['@angular/core'];
        if (!angularCorePackage) {
            devkit_1.logger.error(`[ngxtension] No @angular/core detected`);
            return (0, node_process_1.exit)(1);
        }
        const { path, project } = options;
        if (path && project) {
            devkit_1.logger.error(`[ngxtension] Cannot pass both "path" and "project" to convertToSelfClosingTagGenerator`);
            return (0, node_process_1.exit)(1);
        }
        if (path) {
            if (!tree.exists(path)) {
                devkit_1.logger.error(`[ngxtension] "${path}" does not exist`);
                return (0, node_process_1.exit)(1);
            }
            trackContents(tree, contentsStore, path);
        }
        else if (project) {
            try {
                const projectConfiguration = (0, devkit_1.readProjectConfiguration)(tree, project);
                if (!projectConfiguration) {
                    throw `"${project}" project not found`;
                }
                (0, devkit_1.visitNotIgnoredFiles)(tree, projectConfiguration.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
            catch (err) {
                devkit_1.logger.error(`[ngxtension] ${err}`);
                return;
            }
        }
        else {
            const projects = (0, devkit_1.getProjects)(tree);
            for (const project of projects.values()) {
                (0, devkit_1.visitNotIgnoredFiles)(tree, project.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
        }
        for (const { path: sourcePath } of contentsStore.collection) {
            const sourceFile = contentsStore.project.getSourceFile(sourcePath);
            const classes = sourceFile.getClasses();
            for (const targetClass of classes) {
                const applicableDecorator = targetClass.getDecorator((decoratorDecl) => {
                    return ['Component'].includes(decoratorDecl.getName());
                });
                if (!applicableDecorator)
                    continue;
                // process decorator metadata references
                const decoratorArg = applicableDecorator.getArguments()[0];
                if (ts_morph_1.Node.isObjectLiteralExpression(decoratorArg)) {
                    decoratorArg
                        .getChildrenOfKind(ts_morph_1.SyntaxKind.PropertyAssignment)
                        .forEach((property) => {
                        const decoratorPropertyName = property.getName();
                        if (decoratorPropertyName === 'template') {
                            let originalText = property.getFullText();
                            originalText = migrateComponentToSelfClosingTags(originalText);
                            if (originalText !== property.getFullText()) {
                                property.replaceWithText(originalText.trimStart());
                            }
                        }
                        else if (decoratorPropertyName === 'templateUrl') {
                            const dir = (0, node_path_1.dirname)(sourcePath);
                            const templatePath = (0, devkit_1.joinPathFragments)(dir, property
                                .getInitializer()
                                .getText()
                                .slice(1, property.getInitializer().getText().length - 1));
                            let templateText = tree.exists(templatePath)
                                ? tree.read(templatePath, 'utf8')
                                : '';
                            if (templateText) {
                                templateText = migrateComponentToSelfClosingTags(templateText);
                                tree.write(templatePath, templateText);
                            }
                        }
                    });
                }
            }
            tree.write(sourcePath, sourceFile.getFullText());
        }
        if (contentsStore.withTransforms.size) {
            devkit_1.logger.info(`
[ngxtension] The following classes have had some Inputs with "transform" converted. Please double check the type arguments on the "transform" Inputs
`);
            contentsStore.withTransforms.forEach((className) => {
                devkit_1.logger.info(`- ${className}`);
            });
        }
        yield (0, devkit_1.formatFiles)(tree);
        devkit_1.logger.info(`
[ngxtension] Conversion completed. Please check the content and run your formatter as needed.
`);
    });
}
exports.convertToSelfClosingTagGenerator = convertToSelfClosingTagGenerator;
function migrateComponentToSelfClosingTags(template) {
    const parsedTemplate = new bundled_angular_compiler_1.HtmlParser().parse(template, 'template.html', { tokenizeBlocks: true });
    const visitor = new ElementCollector();
    (0, bundled_angular_compiler_1.visitAll)(visitor, parsedTemplate.rootNodes);
    let changedOffset = 0;
    visitor.elements.forEach((element) => {
        const { start, end, tagName } = element;
        const currentLength = template.length;
        const templatePart = template.slice(start + changedOffset, end + changedOffset);
        function replaceWithSelfClosingTag(html, tagName) {
            const pattern = new RegExp(`<\\s*${tagName}\\s*([^>]*?(?:"[^"]*"|'[^']*'|[^'">])*)\\s*>([\\s\\S]*?)<\\s*/\\s*${tagName}\\s*>`, 'gi');
            const replacement = `<${tagName} $1 />`;
            return html.replace(pattern, replacement);
        }
        const convertedTemplate = replaceWithSelfClosingTag(templatePart, tagName);
        // if the template has changed, replace the original template with the new one
        if (convertedTemplate.length !== templatePart.length) {
            template = replaceTemplate(template, convertedTemplate, start, end, changedOffset);
            changedOffset += template.length - currentLength;
        }
    });
    return template;
}
exports.migrateComponentToSelfClosingTags = migrateComponentToSelfClosingTags;
class ElementCollector extends bundled_angular_compiler_1.RecursiveVisitor {
    constructor() {
        super();
        this.elements = [];
    }
    visitElement(element, context) {
        if (element.children.length) {
            if (element.children.length === 1) {
                const child = element.children[0];
                if (child instanceof bundled_angular_compiler_1.Text) {
                    if (child.value.trim() === '' || child.value.trim() === '\n') {
                        if (element.name.includes('-')) {
                            this.elements.push({
                                tagName: element.name,
                                start: element.sourceSpan.start.offset,
                                end: element.sourceSpan.end.offset,
                            });
                        }
                    }
                }
            }
            return super.visitElement(element, context);
        }
        if (element.name.includes('-')) {
            this.elements.push({
                tagName: element.name,
                start: element.sourceSpan.start.offset,
                end: element.sourceSpan.end.offset,
            });
        }
        return super.visitElement(element, context);
    }
}
/**
 * Replace the value in the template with the new value based on the start and end position + offset
 */
function replaceTemplate(template, replaceValue, start, end, offset) {
    return (template.slice(0, start + offset) +
        replaceValue +
        template.slice(end + offset));
}
exports.default = convertToSelfClosingTagGenerator;
//# sourceMappingURL=generator.js.map