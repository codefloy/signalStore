"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertDiToInjectGenerator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const node_fs_1 = require("node:fs");
const node_process_1 = require("node:process");
const ts_morph_1 = require("ts-morph");
const contents_store_1 = require("../shared-utils/contents-store");
function trackContents(tree, contentsStore, fullPath) {
    if (fullPath.endsWith('.ts')) {
        const fileContent = tree.read(fullPath, 'utf8') || (0, node_fs_1.readFileSync)(fullPath, 'utf8');
        if (!fileContent.includes('@Component') &&
            !fileContent.includes('constructor(') &&
            !fileContent.includes('@Pipe') &&
            !fileContent.includes('@Injectable') &&
            !fileContent.includes('@Directive')) {
            return;
        }
        if (fileContent.includes('constructor(')) {
            contentsStore.track(fullPath, fileContent);
        }
    }
}
function tokenIsTypeString(token) {
    // example: 'my-service' or "my-service"
    return token.includes("'") || token.includes('"');
}
function convertDiToInjectGenerator(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const contentsStore = new contents_store_1.ContentsStore();
        const packageJson = (0, devkit_1.readJson)(tree, 'package.json');
        const angularCorePackage = packageJson['dependencies']['@angular/core'];
        if (!angularCorePackage) {
            devkit_1.logger.error(`[ngxtension] No @angular/core detected`);
            return (0, node_process_1.exit)(1);
        }
        const { path, project } = options;
        if (path && project) {
            devkit_1.logger.error(`[ngxtension] Cannot pass both "path" and "project" to convertDiToInjectGenerator`);
            return (0, node_process_1.exit)(1);
        }
        if (path) {
            if (!tree.exists(path)) {
                devkit_1.logger.error(`[ngxtension] "${path}" does not exist`);
                return (0, node_process_1.exit)(1);
            }
            trackContents(tree, contentsStore, path);
        }
        else if (project) {
            try {
                const projectConfiguration = (0, devkit_1.readProjectConfiguration)(tree, project);
                if (!projectConfiguration) {
                    throw `"${project}" project not found`;
                }
                (0, devkit_1.visitNotIgnoredFiles)(tree, projectConfiguration.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
            catch (err) {
                devkit_1.logger.error(`[ngxtension] ${err}`);
                return;
            }
        }
        else {
            const projects = (0, devkit_1.getProjects)(tree);
            for (const project of projects.values()) {
                (0, devkit_1.visitNotIgnoredFiles)(tree, project.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
        }
        for (const { path: sourcePath } of contentsStore.collection) {
            const sourceFile = contentsStore.project.getSourceFile(sourcePath);
            const hasInjectImport = sourceFile.getImportDeclaration((importDecl) => importDecl.getModuleSpecifierValue() === '@angular/core' &&
                importDecl
                    .getNamedImports()
                    .some((namedImport) => namedImport.getName() === 'inject'));
            const classes = sourceFile.getClasses();
            for (const targetClass of classes) {
                const applicableDecorator = targetClass.getDecorator((decoratorDecl) => {
                    return ['Component', 'Directive', 'Pipe', 'Injectable'].includes(decoratorDecl.getName());
                });
                if (!applicableDecorator)
                    continue;
                const convertedDeps = new Set();
                const convertedPrivateDeps = new Set();
                let includeHostAttributeToken = false;
                targetClass.getConstructors().forEach((constructor) => {
                    constructor.getParameters().forEach((param, index) => {
                        var _a;
                        const { name, type, decorators, scope, isReadonly } = param.getStructure();
                        let shouldUseType = false;
                        let toBeInjected = type; // default to type
                        let tokenToBeInjectedIsString = false;
                        let isAttributeToken = false;
                        const flags = [];
                        if (decorators.length > 0) {
                            decorators.forEach((decorator) => {
                                if (decorator.name === 'Inject') {
                                    toBeInjected = decorator.arguments[0]; // use the argument of the @Inject decorator
                                    if (toBeInjected !== type) {
                                        shouldUseType = true;
                                    }
                                    if (tokenIsTypeString(toBeInjected)) {
                                        tokenToBeInjectedIsString = true;
                                    }
                                }
                                if (decorator.name === 'Attribute') {
                                    // ex: @Attribute('type') type: string
                                    toBeInjected = decorator.arguments[0];
                                    isAttributeToken = true;
                                    includeHostAttributeToken = true;
                                    shouldUseType = true;
                                }
                                if (decorator.name === 'Optional') {
                                    flags.push('optional');
                                }
                                if (decorator.name === 'Self') {
                                    flags.push('self');
                                }
                                if (decorator.name === 'SkipSelf') {
                                    flags.push('skipSelf');
                                }
                                if (decorator.name === 'Host') {
                                    flags.push('host');
                                }
                            });
                        }
                        // if type is (ElementRef or TemplateRef) or should use type, add it as inject generic
                        let injection = 'inject';
                        const typeHasGenerics = (_a = type === null || type === void 0 ? void 0 : type.toString().includes('<')) !== null && _a !== void 0 ? _a : false;
                        if (type && (shouldUseType || typeHasGenerics)) {
                            injection += `<${type}>`;
                        }
                        let initializer = '';
                        if (isAttributeToken) {
                            // inject(new HostAttributeToken('some-attr'));
                            initializer = `${injection}(new HostAttributeToken(${toBeInjected})${flags.length > 0 ? `, { ${flags.map((flag) => flag + ': true').join(', ')} }` : ''})`;
                        }
                        else {
                            initializer = `${injection}(${toBeInjected}${tokenToBeInjectedIsString ? ' as any /* TODO(inject-migration): Please check if the type is correct */' : ''}${flags.length > 0 ? `, { ${flags.map((flag) => flag + ': true').join(', ')} }` : ''})`;
                        }
                        if (!scope) {
                            // create the variable inside the constructor instead of creating it as a class property
                            constructor.insertVariableStatement(0, {
                                declarationKind: ts_morph_1.VariableDeclarationKind.Const,
                                declarations: [{ name, initializer }],
                            });
                            // check if the service was used inside the constructor with 'this.' prefix
                            // if so, remove the 'this.' prefix and use the service variable directly
                            constructor.getStatements().forEach((statement) => {
                                if (!ts_morph_1.Node.isExpressionStatement(statement)) {
                                    return;
                                }
                                const callExpression = statement.getExpression();
                                if (!ts_morph_1.Node.isCallExpression(callExpression)) {
                                    return;
                                }
                                const memberExpression = callExpression.getExpression();
                                if (!ts_morph_1.Node.isMemberExpression(memberExpression)) {
                                    return;
                                }
                                const text = memberExpression.getText();
                                const [thisKeyword, serviceName] = text.split('.');
                                if (thisKeyword === 'this' && serviceName === name.toString()) {
                                    const newExpression = text.replace(`this.${name.toString()}`, name.toString());
                                    memberExpression.replaceWithText(newExpression);
                                }
                            });
                        }
                        else {
                            const hasPrivateScope = scope === ts_morph_1.Scope.Private;
                            const propertyName = hasPrivateScope && options.useEsprivateFieldNotation
                                ? `#${name}`
                                : name;
                            if (hasPrivateScope) {
                                convertedPrivateDeps.add(name);
                            }
                            targetClass.insertProperty(index, {
                                name: propertyName,
                                initializer,
                                scope: hasPrivateScope && options.useEsprivateFieldNotation
                                    ? null
                                    : scope,
                                isReadonly: isReadonly || options.includeReadonlyByDefault || false,
                                leadingTrivia: '  ',
                            });
                            const updates = [];
                            param
                                .findReferences()
                                .flatMap((ref) => ref.getReferences())
                                .filter((ref) => !ref.isDefinition())
                                .forEach((ref) => {
                                const node = ref.getNode();
                                const parent = node.getParent();
                                const text = parent.getText();
                                if (text.includes(`this.${name}`)) {
                                    return;
                                }
                                updates.push(() => {
                                    parent.replaceWithText(text.replace(name.toString(), `this.${propertyName}`));
                                });
                            });
                            updates.forEach((update) => update());
                        }
                        convertedDeps.add(name);
                    });
                    if (convertedDeps.size > 0 && !hasInjectImport) {
                        const namedImports = ['inject'];
                        if (includeHostAttributeToken) {
                            namedImports.push('HostAttributeToken');
                        }
                        const angularCoreImports = sourceFile.getImportDeclaration((importDecl) => {
                            return importDecl.getModuleSpecifierValue() === '@angular/core';
                        });
                        if (angularCoreImports) {
                            angularCoreImports.addNamedImports(namedImports);
                        }
                        else {
                            sourceFile.insertImportDeclaration(0, {
                                namedImports,
                                moduleSpecifier: '@angular/core',
                                leadingTrivia: '  ',
                            });
                        }
                    }
                    constructor.getParameters().forEach((param) => {
                        if (convertedDeps.has(param.getName())) {
                            param.remove();
                        }
                    });
                    if (constructor.getParameters().length === 0 &&
                        constructor.getBodyText().trim() === '') {
                        constructor.remove();
                    }
                    for (const decorator of [
                        'Inject',
                        'Attribute',
                        'Optional',
                        'Self',
                        'SkipSelf',
                        'Host',
                    ]) {
                        // if @${Decorator} is not used anymore, remove the import
                        const hasDecoratorUsage = sourceFile
                            .getFullText()
                            .includes(`@${decorator}`);
                        if (!hasDecoratorUsage) {
                            const foundImport = sourceFile.getImportDeclaration((importDecl) => importDecl.getModuleSpecifierValue() === '@angular/core' &&
                                importDecl
                                    .getNamedImports()
                                    .some((namedImport) => namedImport.getName() === decorator));
                            if (foundImport) {
                                const classToRemove = foundImport
                                    .getNamedImports()
                                    .find((namedImport) => namedImport.getName() === decorator);
                                classToRemove.remove();
                            }
                        }
                    }
                });
                if (options.useEsprivateFieldNotation) {
                    Array.from(convertedPrivateDeps).forEach((convertedDepsName) => {
                        const startIndex = targetClass.getProperties().length;
                        const tempAddedProperty = targetClass.insertProperty(startIndex, {
                            name: convertedDepsName,
                            leadingTrivia: '  ',
                        });
                        tempAddedProperty
                            .findReferences()
                            .flatMap((ref) => ref.getReferences())
                            .filter((ref) => !ref.isDefinition())
                            .forEach((ref) => {
                            const node = ref.getNode();
                            const parent = node.getParent();
                            const text = parent.getText();
                            if (text.includes(`this.#${convertedDepsName}`) ||
                                text.includes(`#${convertedDepsName}`)) {
                                return;
                            }
                            parent.replaceWithText(text.replace(convertedDepsName, `#${convertedDepsName}`));
                        });
                        tempAddedProperty.remove();
                    });
                }
            }
            tree.write(sourcePath, sourceFile.getFullText());
        }
        yield (0, devkit_1.formatFiles)(tree);
        devkit_1.logger.info(`
[ngxtension] Conversion completed. Please check the content and run your formatter as needed.
`);
    });
}
exports.convertDiToInjectGenerator = convertDiToInjectGenerator;
exports.default = convertDiToInjectGenerator;
//# sourceMappingURL=generator.js.map